/*!
 * 
 *   red5pro-sdk - Red5 Pro HTML Publisher and Subscriber SDK.
 *   Author: Infrared5 Inc.
 *   Version: 0.5.3
 *   Url: https://github.com/red5pro/red5pro-html-sdk#readme
 *   License(s): MIT
 * 
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["red5prosdk"] = factory();
	else
		root["red5prosdk"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(1);
	module.exports = __webpack_require__(299);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {"use strict";
	
	__webpack_require__(2);
	
	__webpack_require__(294);
	
	__webpack_require__(296);
	
	/* eslint max-len: 0 */
	
	if (global._babelPolyfill) {
	  throw new Error("only one instance of babel-polyfill is allowed");
	}
	global._babelPolyfill = true;
	
	// Should be removed in the next major release:
	
	var DEFINE_PROPERTY = "defineProperty";
	function define(O, key, value) {
	  O[key] || Object[DEFINE_PROPERTY](O, key, {
	    writable: true,
	    configurable: true,
	    value: value
	  });
	}
	
	define(String.prototype, "padLeft", "".padStart);
	define(String.prototype, "padRight", "".padEnd);
	
	"pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function (key) {
	  [][key] && define(Array, key, Function.call.bind([][key]));
	});
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(3);
	__webpack_require__(52);
	__webpack_require__(53);
	__webpack_require__(54);
	__webpack_require__(55);
	__webpack_require__(57);
	__webpack_require__(60);
	__webpack_require__(61);
	__webpack_require__(62);
	__webpack_require__(63);
	__webpack_require__(64);
	__webpack_require__(65);
	__webpack_require__(66);
	__webpack_require__(67);
	__webpack_require__(68);
	__webpack_require__(70);
	__webpack_require__(72);
	__webpack_require__(74);
	__webpack_require__(76);
	__webpack_require__(79);
	__webpack_require__(80);
	__webpack_require__(81);
	__webpack_require__(85);
	__webpack_require__(87);
	__webpack_require__(89);
	__webpack_require__(93);
	__webpack_require__(94);
	__webpack_require__(95);
	__webpack_require__(96);
	__webpack_require__(98);
	__webpack_require__(99);
	__webpack_require__(100);
	__webpack_require__(101);
	__webpack_require__(102);
	__webpack_require__(103);
	__webpack_require__(104);
	__webpack_require__(106);
	__webpack_require__(107);
	__webpack_require__(108);
	__webpack_require__(110);
	__webpack_require__(111);
	__webpack_require__(112);
	__webpack_require__(114);
	__webpack_require__(115);
	__webpack_require__(116);
	__webpack_require__(117);
	__webpack_require__(118);
	__webpack_require__(119);
	__webpack_require__(120);
	__webpack_require__(121);
	__webpack_require__(122);
	__webpack_require__(123);
	__webpack_require__(124);
	__webpack_require__(125);
	__webpack_require__(126);
	__webpack_require__(127);
	__webpack_require__(132);
	__webpack_require__(133);
	__webpack_require__(137);
	__webpack_require__(138);
	__webpack_require__(139);
	__webpack_require__(140);
	__webpack_require__(142);
	__webpack_require__(143);
	__webpack_require__(144);
	__webpack_require__(145);
	__webpack_require__(146);
	__webpack_require__(147);
	__webpack_require__(148);
	__webpack_require__(149);
	__webpack_require__(150);
	__webpack_require__(151);
	__webpack_require__(152);
	__webpack_require__(153);
	__webpack_require__(154);
	__webpack_require__(155);
	__webpack_require__(156);
	__webpack_require__(157);
	__webpack_require__(158);
	__webpack_require__(160);
	__webpack_require__(161);
	__webpack_require__(167);
	__webpack_require__(168);
	__webpack_require__(170);
	__webpack_require__(171);
	__webpack_require__(172);
	__webpack_require__(176);
	__webpack_require__(177);
	__webpack_require__(178);
	__webpack_require__(179);
	__webpack_require__(180);
	__webpack_require__(182);
	__webpack_require__(183);
	__webpack_require__(184);
	__webpack_require__(185);
	__webpack_require__(188);
	__webpack_require__(190);
	__webpack_require__(191);
	__webpack_require__(192);
	__webpack_require__(194);
	__webpack_require__(196);
	__webpack_require__(198);
	__webpack_require__(199);
	__webpack_require__(200);
	__webpack_require__(202);
	__webpack_require__(203);
	__webpack_require__(204);
	__webpack_require__(205);
	__webpack_require__(211);
	__webpack_require__(214);
	__webpack_require__(215);
	__webpack_require__(217);
	__webpack_require__(218);
	__webpack_require__(221);
	__webpack_require__(222);
	__webpack_require__(225);
	__webpack_require__(226);
	__webpack_require__(227);
	__webpack_require__(228);
	__webpack_require__(229);
	__webpack_require__(230);
	__webpack_require__(231);
	__webpack_require__(232);
	__webpack_require__(233);
	__webpack_require__(234);
	__webpack_require__(235);
	__webpack_require__(236);
	__webpack_require__(237);
	__webpack_require__(238);
	__webpack_require__(239);
	__webpack_require__(240);
	__webpack_require__(241);
	__webpack_require__(242);
	__webpack_require__(243);
	__webpack_require__(245);
	__webpack_require__(246);
	__webpack_require__(247);
	__webpack_require__(248);
	__webpack_require__(249);
	__webpack_require__(250);
	__webpack_require__(252);
	__webpack_require__(253);
	__webpack_require__(254);
	__webpack_require__(255);
	__webpack_require__(256);
	__webpack_require__(257);
	__webpack_require__(258);
	__webpack_require__(259);
	__webpack_require__(261);
	__webpack_require__(262);
	__webpack_require__(264);
	__webpack_require__(265);
	__webpack_require__(266);
	__webpack_require__(267);
	__webpack_require__(270);
	__webpack_require__(271);
	__webpack_require__(272);
	__webpack_require__(273);
	__webpack_require__(274);
	__webpack_require__(275);
	__webpack_require__(276);
	__webpack_require__(277);
	__webpack_require__(279);
	__webpack_require__(280);
	__webpack_require__(281);
	__webpack_require__(282);
	__webpack_require__(283);
	__webpack_require__(284);
	__webpack_require__(285);
	__webpack_require__(286);
	__webpack_require__(287);
	__webpack_require__(288);
	__webpack_require__(289);
	__webpack_require__(292);
	__webpack_require__(293);
	module.exports = __webpack_require__(9);

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// ECMAScript 6 symbols shim
	var global         = __webpack_require__(4)
	  , has            = __webpack_require__(5)
	  , DESCRIPTORS    = __webpack_require__(6)
	  , $export        = __webpack_require__(8)
	  , redefine       = __webpack_require__(18)
	  , META           = __webpack_require__(22).KEY
	  , $fails         = __webpack_require__(7)
	  , shared         = __webpack_require__(23)
	  , setToStringTag = __webpack_require__(24)
	  , uid            = __webpack_require__(19)
	  , wks            = __webpack_require__(25)
	  , wksExt         = __webpack_require__(26)
	  , wksDefine      = __webpack_require__(27)
	  , keyOf          = __webpack_require__(29)
	  , enumKeys       = __webpack_require__(42)
	  , isArray        = __webpack_require__(45)
	  , anObject       = __webpack_require__(12)
	  , toIObject      = __webpack_require__(32)
	  , toPrimitive    = __webpack_require__(16)
	  , createDesc     = __webpack_require__(17)
	  , _create        = __webpack_require__(46)
	  , gOPNExt        = __webpack_require__(49)
	  , $GOPD          = __webpack_require__(51)
	  , $DP            = __webpack_require__(11)
	  , $keys          = __webpack_require__(30)
	  , gOPD           = $GOPD.f
	  , dP             = $DP.f
	  , gOPN           = gOPNExt.f
	  , $Symbol        = global.Symbol
	  , $JSON          = global.JSON
	  , _stringify     = $JSON && $JSON.stringify
	  , PROTOTYPE      = 'prototype'
	  , HIDDEN         = wks('_hidden')
	  , TO_PRIMITIVE   = wks('toPrimitive')
	  , isEnum         = {}.propertyIsEnumerable
	  , SymbolRegistry = shared('symbol-registry')
	  , AllSymbols     = shared('symbols')
	  , OPSymbols      = shared('op-symbols')
	  , ObjectProto    = Object[PROTOTYPE]
	  , USE_NATIVE     = typeof $Symbol == 'function'
	  , QObject        = global.QObject;
	// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
	var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
	
	// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
	var setSymbolDesc = DESCRIPTORS && $fails(function(){
	  return _create(dP({}, 'a', {
	    get: function(){ return dP(this, 'a', {value: 7}).a; }
	  })).a != 7;
	}) ? function(it, key, D){
	  var protoDesc = gOPD(ObjectProto, key);
	  if(protoDesc)delete ObjectProto[key];
	  dP(it, key, D);
	  if(protoDesc && it !== ObjectProto)dP(ObjectProto, key, protoDesc);
	} : dP;
	
	var wrap = function(tag){
	  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
	  sym._k = tag;
	  return sym;
	};
	
	var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function(it){
	  return typeof it == 'symbol';
	} : function(it){
	  return it instanceof $Symbol;
	};
	
	var $defineProperty = function defineProperty(it, key, D){
	  if(it === ObjectProto)$defineProperty(OPSymbols, key, D);
	  anObject(it);
	  key = toPrimitive(key, true);
	  anObject(D);
	  if(has(AllSymbols, key)){
	    if(!D.enumerable){
	      if(!has(it, HIDDEN))dP(it, HIDDEN, createDesc(1, {}));
	      it[HIDDEN][key] = true;
	    } else {
	      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
	      D = _create(D, {enumerable: createDesc(0, false)});
	    } return setSymbolDesc(it, key, D);
	  } return dP(it, key, D);
	};
	var $defineProperties = function defineProperties(it, P){
	  anObject(it);
	  var keys = enumKeys(P = toIObject(P))
	    , i    = 0
	    , l = keys.length
	    , key;
	  while(l > i)$defineProperty(it, key = keys[i++], P[key]);
	  return it;
	};
	var $create = function create(it, P){
	  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
	};
	var $propertyIsEnumerable = function propertyIsEnumerable(key){
	  var E = isEnum.call(this, key = toPrimitive(key, true));
	  if(this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return false;
	  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
	};
	var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){
	  it  = toIObject(it);
	  key = toPrimitive(key, true);
	  if(it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return;
	  var D = gOPD(it, key);
	  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
	  return D;
	};
	var $getOwnPropertyNames = function getOwnPropertyNames(it){
	  var names  = gOPN(toIObject(it))
	    , result = []
	    , i      = 0
	    , key;
	  while(names.length > i){
	    if(!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)result.push(key);
	  } return result;
	};
	var $getOwnPropertySymbols = function getOwnPropertySymbols(it){
	  var IS_OP  = it === ObjectProto
	    , names  = gOPN(IS_OP ? OPSymbols : toIObject(it))
	    , result = []
	    , i      = 0
	    , key;
	  while(names.length > i){
	    if(has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true))result.push(AllSymbols[key]);
	  } return result;
	};
	
	// 19.4.1.1 Symbol([description])
	if(!USE_NATIVE){
	  $Symbol = function Symbol(){
	    if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor!');
	    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
	    var $set = function(value){
	      if(this === ObjectProto)$set.call(OPSymbols, value);
	      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;
	      setSymbolDesc(this, tag, createDesc(1, value));
	    };
	    if(DESCRIPTORS && setter)setSymbolDesc(ObjectProto, tag, {configurable: true, set: $set});
	    return wrap(tag);
	  };
	  redefine($Symbol[PROTOTYPE], 'toString', function toString(){
	    return this._k;
	  });
	
	  $GOPD.f = $getOwnPropertyDescriptor;
	  $DP.f   = $defineProperty;
	  __webpack_require__(50).f = gOPNExt.f = $getOwnPropertyNames;
	  __webpack_require__(44).f  = $propertyIsEnumerable;
	  __webpack_require__(43).f = $getOwnPropertySymbols;
	
	  if(DESCRIPTORS && !__webpack_require__(28)){
	    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
	  }
	
	  wksExt.f = function(name){
	    return wrap(wks(name));
	  }
	}
	
	$export($export.G + $export.W + $export.F * !USE_NATIVE, {Symbol: $Symbol});
	
	for(var symbols = (
	  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
	  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
	).split(','), i = 0; symbols.length > i; )wks(symbols[i++]);
	
	for(var symbols = $keys(wks.store), i = 0; symbols.length > i; )wksDefine(symbols[i++]);
	
	$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
	  // 19.4.2.1 Symbol.for(key)
	  'for': function(key){
	    return has(SymbolRegistry, key += '')
	      ? SymbolRegistry[key]
	      : SymbolRegistry[key] = $Symbol(key);
	  },
	  // 19.4.2.5 Symbol.keyFor(sym)
	  keyFor: function keyFor(key){
	    if(isSymbol(key))return keyOf(SymbolRegistry, key);
	    throw TypeError(key + ' is not a symbol!');
	  },
	  useSetter: function(){ setter = true; },
	  useSimple: function(){ setter = false; }
	});
	
	$export($export.S + $export.F * !USE_NATIVE, 'Object', {
	  // 19.1.2.2 Object.create(O [, Properties])
	  create: $create,
	  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
	  defineProperty: $defineProperty,
	  // 19.1.2.3 Object.defineProperties(O, Properties)
	  defineProperties: $defineProperties,
	  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
	  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
	  // 19.1.2.7 Object.getOwnPropertyNames(O)
	  getOwnPropertyNames: $getOwnPropertyNames,
	  // 19.1.2.8 Object.getOwnPropertySymbols(O)
	  getOwnPropertySymbols: $getOwnPropertySymbols
	});
	
	// 24.3.2 JSON.stringify(value [, replacer [, space]])
	$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function(){
	  var S = $Symbol();
	  // MS Edge converts symbol values to JSON as {}
	  // WebKit converts symbol values to JSON as null
	  // V8 throws on boxed symbols
	  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
	})), 'JSON', {
	  stringify: function stringify(it){
	    if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined
	    var args = [it]
	      , i    = 1
	      , replacer, $replacer;
	    while(arguments.length > i)args.push(arguments[i++]);
	    replacer = args[1];
	    if(typeof replacer == 'function')$replacer = replacer;
	    if($replacer || !isArray(replacer))replacer = function(key, value){
	      if($replacer)value = $replacer.call(this, key, value);
	      if(!isSymbol(value))return value;
	    };
	    args[1] = replacer;
	    return _stringify.apply($JSON, args);
	  }
	});
	
	// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
	$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(10)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
	// 19.4.3.5 Symbol.prototype[@@toStringTag]
	setToStringTag($Symbol, 'Symbol');
	// 20.2.1.9 Math[@@toStringTag]
	setToStringTag(Math, 'Math', true);
	// 24.3.3 JSON[@@toStringTag]
	setToStringTag(global.JSON, 'JSON', true);

/***/ },
/* 4 */
/***/ function(module, exports) {

	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global = module.exports = typeof window != 'undefined' && window.Math == Math
	  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
	if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef

/***/ },
/* 5 */
/***/ function(module, exports) {

	var hasOwnProperty = {}.hasOwnProperty;
	module.exports = function(it, key){
	  return hasOwnProperty.call(it, key);
	};

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	// Thank's IE8 for his funny defineProperty
	module.exports = !__webpack_require__(7)(function(){
	  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 7 */
/***/ function(module, exports) {

	module.exports = function(exec){
	  try {
	    return !!exec();
	  } catch(e){
	    return true;
	  }
	};

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(4)
	  , core      = __webpack_require__(9)
	  , hide      = __webpack_require__(10)
	  , redefine  = __webpack_require__(18)
	  , ctx       = __webpack_require__(20)
	  , PROTOTYPE = 'prototype';
	
	var $export = function(type, name, source){
	  var IS_FORCED = type & $export.F
	    , IS_GLOBAL = type & $export.G
	    , IS_STATIC = type & $export.S
	    , IS_PROTO  = type & $export.P
	    , IS_BIND   = type & $export.B
	    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE]
	    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
	    , expProto  = exports[PROTOTYPE] || (exports[PROTOTYPE] = {})
	    , key, own, out, exp;
	  if(IS_GLOBAL)source = name;
	  for(key in source){
	    // contains in native
	    own = !IS_FORCED && target && target[key] !== undefined;
	    // export native or passed
	    out = (own ? target : source)[key];
	    // bind timers to global for call from export context
	    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
	    // extend global
	    if(target)redefine(target, key, out, type & $export.U);
	    // export
	    if(exports[key] != out)hide(exports, key, exp);
	    if(IS_PROTO && expProto[key] != out)expProto[key] = out;
	  }
	};
	global.core = core;
	// type bitmap
	$export.F = 1;   // forced
	$export.G = 2;   // global
	$export.S = 4;   // static
	$export.P = 8;   // proto
	$export.B = 16;  // bind
	$export.W = 32;  // wrap
	$export.U = 64;  // safe
	$export.R = 128; // real proto method for `library` 
	module.exports = $export;

/***/ },
/* 9 */
/***/ function(module, exports) {

	var core = module.exports = {version: '2.4.0'};
	if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	var dP         = __webpack_require__(11)
	  , createDesc = __webpack_require__(17);
	module.exports = __webpack_require__(6) ? function(object, key, value){
	  return dP.f(object, key, createDesc(1, value));
	} : function(object, key, value){
	  object[key] = value;
	  return object;
	};

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	var anObject       = __webpack_require__(12)
	  , IE8_DOM_DEFINE = __webpack_require__(14)
	  , toPrimitive    = __webpack_require__(16)
	  , dP             = Object.defineProperty;
	
	exports.f = __webpack_require__(6) ? Object.defineProperty : function defineProperty(O, P, Attributes){
	  anObject(O);
	  P = toPrimitive(P, true);
	  anObject(Attributes);
	  if(IE8_DOM_DEFINE)try {
	    return dP(O, P, Attributes);
	  } catch(e){ /* empty */ }
	  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
	  if('value' in Attributes)O[P] = Attributes.value;
	  return O;
	};

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(13);
	module.exports = function(it){
	  if(!isObject(it))throw TypeError(it + ' is not an object!');
	  return it;
	};

/***/ },
/* 13 */
/***/ function(module, exports) {

	module.exports = function(it){
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = !__webpack_require__(6) && !__webpack_require__(7)(function(){
	  return Object.defineProperty(__webpack_require__(15)('div'), 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(13)
	  , document = __webpack_require__(4).document
	  // in old IE typeof document.createElement is 'object'
	  , is = isObject(document) && isObject(document.createElement);
	module.exports = function(it){
	  return is ? document.createElement(it) : {};
	};

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.1 ToPrimitive(input [, PreferredType])
	var isObject = __webpack_require__(13);
	// instead of the ES6 spec version, we didn't implement @@toPrimitive case
	// and the second argument - flag - preferred type is a string
	module.exports = function(it, S){
	  if(!isObject(it))return it;
	  var fn, val;
	  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  throw TypeError("Can't convert object to primitive value");
	};

/***/ },
/* 17 */
/***/ function(module, exports) {

	module.exports = function(bitmap, value){
	  return {
	    enumerable  : !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable    : !(bitmap & 4),
	    value       : value
	  };
	};

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(4)
	  , hide      = __webpack_require__(10)
	  , has       = __webpack_require__(5)
	  , SRC       = __webpack_require__(19)('src')
	  , TO_STRING = 'toString'
	  , $toString = Function[TO_STRING]
	  , TPL       = ('' + $toString).split(TO_STRING);
	
	__webpack_require__(9).inspectSource = function(it){
	  return $toString.call(it);
	};
	
	(module.exports = function(O, key, val, safe){
	  var isFunction = typeof val == 'function';
	  if(isFunction)has(val, 'name') || hide(val, 'name', key);
	  if(O[key] === val)return;
	  if(isFunction)has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
	  if(O === global){
	    O[key] = val;
	  } else {
	    if(!safe){
	      delete O[key];
	      hide(O, key, val);
	    } else {
	      if(O[key])O[key] = val;
	      else hide(O, key, val);
	    }
	  }
	// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
	})(Function.prototype, TO_STRING, function toString(){
	  return typeof this == 'function' && this[SRC] || $toString.call(this);
	});

/***/ },
/* 19 */
/***/ function(module, exports) {

	var id = 0
	  , px = Math.random();
	module.exports = function(key){
	  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
	};

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	// optional / simple context binding
	var aFunction = __webpack_require__(21);
	module.exports = function(fn, that, length){
	  aFunction(fn);
	  if(that === undefined)return fn;
	  switch(length){
	    case 1: return function(a){
	      return fn.call(that, a);
	    };
	    case 2: return function(a, b){
	      return fn.call(that, a, b);
	    };
	    case 3: return function(a, b, c){
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function(/* ...args */){
	    return fn.apply(that, arguments);
	  };
	};

/***/ },
/* 21 */
/***/ function(module, exports) {

	module.exports = function(it){
	  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
	  return it;
	};

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	var META     = __webpack_require__(19)('meta')
	  , isObject = __webpack_require__(13)
	  , has      = __webpack_require__(5)
	  , setDesc  = __webpack_require__(11).f
	  , id       = 0;
	var isExtensible = Object.isExtensible || function(){
	  return true;
	};
	var FREEZE = !__webpack_require__(7)(function(){
	  return isExtensible(Object.preventExtensions({}));
	});
	var setMeta = function(it){
	  setDesc(it, META, {value: {
	    i: 'O' + ++id, // object ID
	    w: {}          // weak collections IDs
	  }});
	};
	var fastKey = function(it, create){
	  // return primitive with prefix
	  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
	  if(!has(it, META)){
	    // can't set metadata to uncaught frozen object
	    if(!isExtensible(it))return 'F';
	    // not necessary to add metadata
	    if(!create)return 'E';
	    // add missing metadata
	    setMeta(it);
	  // return object ID
	  } return it[META].i;
	};
	var getWeak = function(it, create){
	  if(!has(it, META)){
	    // can't set metadata to uncaught frozen object
	    if(!isExtensible(it))return true;
	    // not necessary to add metadata
	    if(!create)return false;
	    // add missing metadata
	    setMeta(it);
	  // return hash weak collections IDs
	  } return it[META].w;
	};
	// add metadata on freeze-family methods calling
	var onFreeze = function(it){
	  if(FREEZE && meta.NEED && isExtensible(it) && !has(it, META))setMeta(it);
	  return it;
	};
	var meta = module.exports = {
	  KEY:      META,
	  NEED:     false,
	  fastKey:  fastKey,
	  getWeak:  getWeak,
	  onFreeze: onFreeze
	};

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	var global = __webpack_require__(4)
	  , SHARED = '__core-js_shared__'
	  , store  = global[SHARED] || (global[SHARED] = {});
	module.exports = function(key){
	  return store[key] || (store[key] = {});
	};

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	var def = __webpack_require__(11).f
	  , has = __webpack_require__(5)
	  , TAG = __webpack_require__(25)('toStringTag');
	
	module.exports = function(it, tag, stat){
	  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});
	};

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	var store      = __webpack_require__(23)('wks')
	  , uid        = __webpack_require__(19)
	  , Symbol     = __webpack_require__(4).Symbol
	  , USE_SYMBOL = typeof Symbol == 'function';
	
	var $exports = module.exports = function(name){
	  return store[name] || (store[name] =
	    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
	};
	
	$exports.store = store;

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	exports.f = __webpack_require__(25);

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	var global         = __webpack_require__(4)
	  , core           = __webpack_require__(9)
	  , LIBRARY        = __webpack_require__(28)
	  , wksExt         = __webpack_require__(26)
	  , defineProperty = __webpack_require__(11).f;
	module.exports = function(name){
	  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
	  if(name.charAt(0) != '_' && !(name in $Symbol))defineProperty($Symbol, name, {value: wksExt.f(name)});
	};

/***/ },
/* 28 */
/***/ function(module, exports) {

	module.exports = false;

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	var getKeys   = __webpack_require__(30)
	  , toIObject = __webpack_require__(32);
	module.exports = function(object, el){
	  var O      = toIObject(object)
	    , keys   = getKeys(O)
	    , length = keys.length
	    , index  = 0
	    , key;
	  while(length > index)if(O[key = keys[index++]] === el)return key;
	};

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.14 / 15.2.3.14 Object.keys(O)
	var $keys       = __webpack_require__(31)
	  , enumBugKeys = __webpack_require__(41);
	
	module.exports = Object.keys || function keys(O){
	  return $keys(O, enumBugKeys);
	};

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	var has          = __webpack_require__(5)
	  , toIObject    = __webpack_require__(32)
	  , arrayIndexOf = __webpack_require__(36)(false)
	  , IE_PROTO     = __webpack_require__(40)('IE_PROTO');
	
	module.exports = function(object, names){
	  var O      = toIObject(object)
	    , i      = 0
	    , result = []
	    , key;
	  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
	  // Don't enum bug & hidden keys
	  while(names.length > i)if(has(O, key = names[i++])){
	    ~arrayIndexOf(result, key) || result.push(key);
	  }
	  return result;
	};

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	// to indexed object, toObject with fallback for non-array-like ES3 strings
	var IObject = __webpack_require__(33)
	  , defined = __webpack_require__(35);
	module.exports = function(it){
	  return IObject(defined(it));
	};

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	// fallback for non-array-like ES3 and non-enumerable old V8 strings
	var cof = __webpack_require__(34);
	module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
	  return cof(it) == 'String' ? it.split('') : Object(it);
	};

/***/ },
/* 34 */
/***/ function(module, exports) {

	var toString = {}.toString;
	
	module.exports = function(it){
	  return toString.call(it).slice(8, -1);
	};

/***/ },
/* 35 */
/***/ function(module, exports) {

	// 7.2.1 RequireObjectCoercible(argument)
	module.exports = function(it){
	  if(it == undefined)throw TypeError("Can't call method on  " + it);
	  return it;
	};

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	// false -> Array#indexOf
	// true  -> Array#includes
	var toIObject = __webpack_require__(32)
	  , toLength  = __webpack_require__(37)
	  , toIndex   = __webpack_require__(39);
	module.exports = function(IS_INCLUDES){
	  return function($this, el, fromIndex){
	    var O      = toIObject($this)
	      , length = toLength(O.length)
	      , index  = toIndex(fromIndex, length)
	      , value;
	    // Array#includes uses SameValueZero equality algorithm
	    if(IS_INCLUDES && el != el)while(length > index){
	      value = O[index++];
	      if(value != value)return true;
	    // Array#toIndex ignores holes, Array#includes - not
	    } else for(;length > index; index++)if(IS_INCLUDES || index in O){
	      if(O[index] === el)return IS_INCLUDES || index || 0;
	    } return !IS_INCLUDES && -1;
	  };
	};

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.15 ToLength
	var toInteger = __webpack_require__(38)
	  , min       = Math.min;
	module.exports = function(it){
	  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
	};

/***/ },
/* 38 */
/***/ function(module, exports) {

	// 7.1.4 ToInteger
	var ceil  = Math.ceil
	  , floor = Math.floor;
	module.exports = function(it){
	  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
	};

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(38)
	  , max       = Math.max
	  , min       = Math.min;
	module.exports = function(index, length){
	  index = toInteger(index);
	  return index < 0 ? max(index + length, 0) : min(index, length);
	};

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	var shared = __webpack_require__(23)('keys')
	  , uid    = __webpack_require__(19);
	module.exports = function(key){
	  return shared[key] || (shared[key] = uid(key));
	};

/***/ },
/* 41 */
/***/ function(module, exports) {

	// IE 8- don't enum bug keys
	module.exports = (
	  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
	).split(',');

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	// all enumerable object keys, includes symbols
	var getKeys = __webpack_require__(30)
	  , gOPS    = __webpack_require__(43)
	  , pIE     = __webpack_require__(44);
	module.exports = function(it){
	  var result     = getKeys(it)
	    , getSymbols = gOPS.f;
	  if(getSymbols){
	    var symbols = getSymbols(it)
	      , isEnum  = pIE.f
	      , i       = 0
	      , key;
	    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))result.push(key);
	  } return result;
	};

/***/ },
/* 43 */
/***/ function(module, exports) {

	exports.f = Object.getOwnPropertySymbols;

/***/ },
/* 44 */
/***/ function(module, exports) {

	exports.f = {}.propertyIsEnumerable;

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	// 7.2.2 IsArray(argument)
	var cof = __webpack_require__(34);
	module.exports = Array.isArray || function isArray(arg){
	  return cof(arg) == 'Array';
	};

/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	var anObject    = __webpack_require__(12)
	  , dPs         = __webpack_require__(47)
	  , enumBugKeys = __webpack_require__(41)
	  , IE_PROTO    = __webpack_require__(40)('IE_PROTO')
	  , Empty       = function(){ /* empty */ }
	  , PROTOTYPE   = 'prototype';
	
	// Create object with fake `null` prototype: use iframe Object with cleared prototype
	var createDict = function(){
	  // Thrash, waste and sodomy: IE GC bug
	  var iframe = __webpack_require__(15)('iframe')
	    , i      = enumBugKeys.length
	    , gt     = '>'
	    , iframeDocument;
	  iframe.style.display = 'none';
	  __webpack_require__(48).appendChild(iframe);
	  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
	  // createDict = iframe.contentWindow.Object;
	  // html.removeChild(iframe);
	  iframeDocument = iframe.contentWindow.document;
	  iframeDocument.open();
	  iframeDocument.write('<script>document.F=Object</script' + gt);
	  iframeDocument.close();
	  createDict = iframeDocument.F;
	  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];
	  return createDict();
	};
	
	module.exports = Object.create || function create(O, Properties){
	  var result;
	  if(O !== null){
	    Empty[PROTOTYPE] = anObject(O);
	    result = new Empty;
	    Empty[PROTOTYPE] = null;
	    // add "__proto__" for Object.getPrototypeOf polyfill
	    result[IE_PROTO] = O;
	  } else result = createDict();
	  return Properties === undefined ? result : dPs(result, Properties);
	};

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	var dP       = __webpack_require__(11)
	  , anObject = __webpack_require__(12)
	  , getKeys  = __webpack_require__(30);
	
	module.exports = __webpack_require__(6) ? Object.defineProperties : function defineProperties(O, Properties){
	  anObject(O);
	  var keys   = getKeys(Properties)
	    , length = keys.length
	    , i = 0
	    , P;
	  while(length > i)dP.f(O, P = keys[i++], Properties[P]);
	  return O;
	};

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(4).document && document.documentElement;

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
	var toIObject = __webpack_require__(32)
	  , gOPN      = __webpack_require__(50).f
	  , toString  = {}.toString;
	
	var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
	  ? Object.getOwnPropertyNames(window) : [];
	
	var getWindowNames = function(it){
	  try {
	    return gOPN(it);
	  } catch(e){
	    return windowNames.slice();
	  }
	};
	
	module.exports.f = function getOwnPropertyNames(it){
	  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
	};


/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
	var $keys      = __webpack_require__(31)
	  , hiddenKeys = __webpack_require__(41).concat('length', 'prototype');
	
	exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O){
	  return $keys(O, hiddenKeys);
	};

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	var pIE            = __webpack_require__(44)
	  , createDesc     = __webpack_require__(17)
	  , toIObject      = __webpack_require__(32)
	  , toPrimitive    = __webpack_require__(16)
	  , has            = __webpack_require__(5)
	  , IE8_DOM_DEFINE = __webpack_require__(14)
	  , gOPD           = Object.getOwnPropertyDescriptor;
	
	exports.f = __webpack_require__(6) ? gOPD : function getOwnPropertyDescriptor(O, P){
	  O = toIObject(O);
	  P = toPrimitive(P, true);
	  if(IE8_DOM_DEFINE)try {
	    return gOPD(O, P);
	  } catch(e){ /* empty */ }
	  if(has(O, P))return createDesc(!pIE.f.call(O, P), O[P]);
	};

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(8)
	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	$export($export.S, 'Object', {create: __webpack_require__(46)});

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(8);
	// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
	$export($export.S + $export.F * !__webpack_require__(6), 'Object', {defineProperty: __webpack_require__(11).f});

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(8);
	// 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
	$export($export.S + $export.F * !__webpack_require__(6), 'Object', {defineProperties: __webpack_require__(47)});

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
	var toIObject                 = __webpack_require__(32)
	  , $getOwnPropertyDescriptor = __webpack_require__(51).f;
	
	__webpack_require__(56)('getOwnPropertyDescriptor', function(){
	  return function getOwnPropertyDescriptor(it, key){
	    return $getOwnPropertyDescriptor(toIObject(it), key);
	  };
	});

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	// most Object methods by ES6 should accept primitives
	var $export = __webpack_require__(8)
	  , core    = __webpack_require__(9)
	  , fails   = __webpack_require__(7);
	module.exports = function(KEY, exec){
	  var fn  = (core.Object || {})[KEY] || Object[KEY]
	    , exp = {};
	  exp[KEY] = exec(fn);
	  $export($export.S + $export.F * fails(function(){ fn(1); }), 'Object', exp);
	};

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.9 Object.getPrototypeOf(O)
	var toObject        = __webpack_require__(58)
	  , $getPrototypeOf = __webpack_require__(59);
	
	__webpack_require__(56)('getPrototypeOf', function(){
	  return function getPrototypeOf(it){
	    return $getPrototypeOf(toObject(it));
	  };
	});

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.13 ToObject(argument)
	var defined = __webpack_require__(35);
	module.exports = function(it){
	  return Object(defined(it));
	};

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
	var has         = __webpack_require__(5)
	  , toObject    = __webpack_require__(58)
	  , IE_PROTO    = __webpack_require__(40)('IE_PROTO')
	  , ObjectProto = Object.prototype;
	
	module.exports = Object.getPrototypeOf || function(O){
	  O = toObject(O);
	  if(has(O, IE_PROTO))return O[IE_PROTO];
	  if(typeof O.constructor == 'function' && O instanceof O.constructor){
	    return O.constructor.prototype;
	  } return O instanceof Object ? ObjectProto : null;
	};

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.14 Object.keys(O)
	var toObject = __webpack_require__(58)
	  , $keys    = __webpack_require__(30);
	
	__webpack_require__(56)('keys', function(){
	  return function keys(it){
	    return $keys(toObject(it));
	  };
	});

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.7 Object.getOwnPropertyNames(O)
	__webpack_require__(56)('getOwnPropertyNames', function(){
	  return __webpack_require__(49).f;
	});

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.5 Object.freeze(O)
	var isObject = __webpack_require__(13)
	  , meta     = __webpack_require__(22).onFreeze;
	
	__webpack_require__(56)('freeze', function($freeze){
	  return function freeze(it){
	    return $freeze && isObject(it) ? $freeze(meta(it)) : it;
	  };
	});

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.17 Object.seal(O)
	var isObject = __webpack_require__(13)
	  , meta     = __webpack_require__(22).onFreeze;
	
	__webpack_require__(56)('seal', function($seal){
	  return function seal(it){
	    return $seal && isObject(it) ? $seal(meta(it)) : it;
	  };
	});

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.15 Object.preventExtensions(O)
	var isObject = __webpack_require__(13)
	  , meta     = __webpack_require__(22).onFreeze;
	
	__webpack_require__(56)('preventExtensions', function($preventExtensions){
	  return function preventExtensions(it){
	    return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it;
	  };
	});

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.12 Object.isFrozen(O)
	var isObject = __webpack_require__(13);
	
	__webpack_require__(56)('isFrozen', function($isFrozen){
	  return function isFrozen(it){
	    return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
	  };
	});

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.13 Object.isSealed(O)
	var isObject = __webpack_require__(13);
	
	__webpack_require__(56)('isSealed', function($isSealed){
	  return function isSealed(it){
	    return isObject(it) ? $isSealed ? $isSealed(it) : false : true;
	  };
	});

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.11 Object.isExtensible(O)
	var isObject = __webpack_require__(13);
	
	__webpack_require__(56)('isExtensible', function($isExtensible){
	  return function isExtensible(it){
	    return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
	  };
	});

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.3.1 Object.assign(target, source)
	var $export = __webpack_require__(8);
	
	$export($export.S + $export.F, 'Object', {assign: __webpack_require__(69)});

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 19.1.2.1 Object.assign(target, source, ...)
	var getKeys  = __webpack_require__(30)
	  , gOPS     = __webpack_require__(43)
	  , pIE      = __webpack_require__(44)
	  , toObject = __webpack_require__(58)
	  , IObject  = __webpack_require__(33)
	  , $assign  = Object.assign;
	
	// should work with symbols and should have deterministic property order (V8 bug)
	module.exports = !$assign || __webpack_require__(7)(function(){
	  var A = {}
	    , B = {}
	    , S = Symbol()
	    , K = 'abcdefghijklmnopqrst';
	  A[S] = 7;
	  K.split('').forEach(function(k){ B[k] = k; });
	  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
	}) ? function assign(target, source){ // eslint-disable-line no-unused-vars
	  var T     = toObject(target)
	    , aLen  = arguments.length
	    , index = 1
	    , getSymbols = gOPS.f
	    , isEnum     = pIE.f;
	  while(aLen > index){
	    var S      = IObject(arguments[index++])
	      , keys   = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S)
	      , length = keys.length
	      , j      = 0
	      , key;
	    while(length > j)if(isEnum.call(S, key = keys[j++]))T[key] = S[key];
	  } return T;
	} : $assign;

/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.3.10 Object.is(value1, value2)
	var $export = __webpack_require__(8);
	$export($export.S, 'Object', {is: __webpack_require__(71)});

/***/ },
/* 71 */
/***/ function(module, exports) {

	// 7.2.9 SameValue(x, y)
	module.exports = Object.is || function is(x, y){
	  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
	};

/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.3.19 Object.setPrototypeOf(O, proto)
	var $export = __webpack_require__(8);
	$export($export.S, 'Object', {setPrototypeOf: __webpack_require__(73).set});

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	// Works with __proto__ only. Old v8 can't work with null proto objects.
	/* eslint-disable no-proto */
	var isObject = __webpack_require__(13)
	  , anObject = __webpack_require__(12);
	var check = function(O, proto){
	  anObject(O);
	  if(!isObject(proto) && proto !== null)throw TypeError(proto + ": can't set as prototype!");
	};
	module.exports = {
	  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
	    function(test, buggy, set){
	      try {
	        set = __webpack_require__(20)(Function.call, __webpack_require__(51).f(Object.prototype, '__proto__').set, 2);
	        set(test, []);
	        buggy = !(test instanceof Array);
	      } catch(e){ buggy = true; }
	      return function setPrototypeOf(O, proto){
	        check(O, proto);
	        if(buggy)O.__proto__ = proto;
	        else set(O, proto);
	        return O;
	      };
	    }({}, false) : undefined),
	  check: check
	};

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 19.1.3.6 Object.prototype.toString()
	var classof = __webpack_require__(75)
	  , test    = {};
	test[__webpack_require__(25)('toStringTag')] = 'z';
	if(test + '' != '[object z]'){
	  __webpack_require__(18)(Object.prototype, 'toString', function toString(){
	    return '[object ' + classof(this) + ']';
	  }, true);
	}

/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	// getting tag from 19.1.3.6 Object.prototype.toString()
	var cof = __webpack_require__(34)
	  , TAG = __webpack_require__(25)('toStringTag')
	  // ES3 wrong here
	  , ARG = cof(function(){ return arguments; }()) == 'Arguments';
	
	// fallback for IE11 Script Access Denied error
	var tryGet = function(it, key){
	  try {
	    return it[key];
	  } catch(e){ /* empty */ }
	};
	
	module.exports = function(it){
	  var O, T, B;
	  return it === undefined ? 'Undefined' : it === null ? 'Null'
	    // @@toStringTag case
	    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
	    // builtinTag case
	    : ARG ? cof(O)
	    // ES3 arguments fallback
	    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
	};

/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)
	var $export = __webpack_require__(8);
	
	$export($export.P, 'Function', {bind: __webpack_require__(77)});

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var aFunction  = __webpack_require__(21)
	  , isObject   = __webpack_require__(13)
	  , invoke     = __webpack_require__(78)
	  , arraySlice = [].slice
	  , factories  = {};
	
	var construct = function(F, len, args){
	  if(!(len in factories)){
	    for(var n = [], i = 0; i < len; i++)n[i] = 'a[' + i + ']';
	    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
	  } return factories[len](F, args);
	};
	
	module.exports = Function.bind || function bind(that /*, args... */){
	  var fn       = aFunction(this)
	    , partArgs = arraySlice.call(arguments, 1);
	  var bound = function(/* args... */){
	    var args = partArgs.concat(arraySlice.call(arguments));
	    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
	  };
	  if(isObject(fn.prototype))bound.prototype = fn.prototype;
	  return bound;
	};

/***/ },
/* 78 */
/***/ function(module, exports) {

	// fast apply, http://jsperf.lnkit.com/fast-apply/5
	module.exports = function(fn, args, that){
	  var un = that === undefined;
	  switch(args.length){
	    case 0: return un ? fn()
	                      : fn.call(that);
	    case 1: return un ? fn(args[0])
	                      : fn.call(that, args[0]);
	    case 2: return un ? fn(args[0], args[1])
	                      : fn.call(that, args[0], args[1]);
	    case 3: return un ? fn(args[0], args[1], args[2])
	                      : fn.call(that, args[0], args[1], args[2]);
	    case 4: return un ? fn(args[0], args[1], args[2], args[3])
	                      : fn.call(that, args[0], args[1], args[2], args[3]);
	  } return              fn.apply(that, args);
	};

/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	var dP         = __webpack_require__(11).f
	  , createDesc = __webpack_require__(17)
	  , has        = __webpack_require__(5)
	  , FProto     = Function.prototype
	  , nameRE     = /^\s*function ([^ (]*)/
	  , NAME       = 'name';
	
	var isExtensible = Object.isExtensible || function(){
	  return true;
	};
	
	// 19.2.4.2 name
	NAME in FProto || __webpack_require__(6) && dP(FProto, NAME, {
	  configurable: true,
	  get: function(){
	    try {
	      var that = this
	        , name = ('' + that).match(nameRE)[1];
	      has(that, NAME) || !isExtensible(that) || dP(that, NAME, createDesc(5, name));
	      return name;
	    } catch(e){
	      return '';
	    }
	  }
	});

/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var isObject       = __webpack_require__(13)
	  , getPrototypeOf = __webpack_require__(59)
	  , HAS_INSTANCE   = __webpack_require__(25)('hasInstance')
	  , FunctionProto  = Function.prototype;
	// 19.2.3.6 Function.prototype[@@hasInstance](V)
	if(!(HAS_INSTANCE in FunctionProto))__webpack_require__(11).f(FunctionProto, HAS_INSTANCE, {value: function(O){
	  if(typeof this != 'function' || !isObject(O))return false;
	  if(!isObject(this.prototype))return O instanceof this;
	  // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:
	  while(O = getPrototypeOf(O))if(this.prototype === O)return true;
	  return false;
	}});

/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	var $export   = __webpack_require__(8)
	  , $parseInt = __webpack_require__(82);
	// 18.2.5 parseInt(string, radix)
	$export($export.G + $export.F * (parseInt != $parseInt), {parseInt: $parseInt});

/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	var $parseInt = __webpack_require__(4).parseInt
	  , $trim     = __webpack_require__(83).trim
	  , ws        = __webpack_require__(84)
	  , hex       = /^[\-+]?0[xX]/;
	
	module.exports = $parseInt(ws + '08') !== 8 || $parseInt(ws + '0x16') !== 22 ? function parseInt(str, radix){
	  var string = $trim(String(str), 3);
	  return $parseInt(string, (radix >>> 0) || (hex.test(string) ? 16 : 10));
	} : $parseInt;

/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(8)
	  , defined = __webpack_require__(35)
	  , fails   = __webpack_require__(7)
	  , spaces  = __webpack_require__(84)
	  , space   = '[' + spaces + ']'
	  , non     = '\u200b\u0085'
	  , ltrim   = RegExp('^' + space + space + '*')
	  , rtrim   = RegExp(space + space + '*$');
	
	var exporter = function(KEY, exec, ALIAS){
	  var exp   = {};
	  var FORCE = fails(function(){
	    return !!spaces[KEY]() || non[KEY]() != non;
	  });
	  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
	  if(ALIAS)exp[ALIAS] = fn;
	  $export($export.P + $export.F * FORCE, 'String', exp);
	};
	
	// 1 -> String#trimLeft
	// 2 -> String#trimRight
	// 3 -> String#trim
	var trim = exporter.trim = function(string, TYPE){
	  string = String(defined(string));
	  if(TYPE & 1)string = string.replace(ltrim, '');
	  if(TYPE & 2)string = string.replace(rtrim, '');
	  return string;
	};
	
	module.exports = exporter;

/***/ },
/* 84 */
/***/ function(module, exports) {

	module.exports = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
	  '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	var $export     = __webpack_require__(8)
	  , $parseFloat = __webpack_require__(86);
	// 18.2.4 parseFloat(string)
	$export($export.G + $export.F * (parseFloat != $parseFloat), {parseFloat: $parseFloat});

/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	var $parseFloat = __webpack_require__(4).parseFloat
	  , $trim       = __webpack_require__(83).trim;
	
	module.exports = 1 / $parseFloat(__webpack_require__(84) + '-0') !== -Infinity ? function parseFloat(str){
	  var string = $trim(String(str), 3)
	    , result = $parseFloat(string);
	  return result === 0 && string.charAt(0) == '-' ? -0 : result;
	} : $parseFloat;

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var global            = __webpack_require__(4)
	  , has               = __webpack_require__(5)
	  , cof               = __webpack_require__(34)
	  , inheritIfRequired = __webpack_require__(88)
	  , toPrimitive       = __webpack_require__(16)
	  , fails             = __webpack_require__(7)
	  , gOPN              = __webpack_require__(50).f
	  , gOPD              = __webpack_require__(51).f
	  , dP                = __webpack_require__(11).f
	  , $trim             = __webpack_require__(83).trim
	  , NUMBER            = 'Number'
	  , $Number           = global[NUMBER]
	  , Base              = $Number
	  , proto             = $Number.prototype
	  // Opera ~12 has broken Object#toString
	  , BROKEN_COF        = cof(__webpack_require__(46)(proto)) == NUMBER
	  , TRIM              = 'trim' in String.prototype;
	
	// 7.1.3 ToNumber(argument)
	var toNumber = function(argument){
	  var it = toPrimitive(argument, false);
	  if(typeof it == 'string' && it.length > 2){
	    it = TRIM ? it.trim() : $trim(it, 3);
	    var first = it.charCodeAt(0)
	      , third, radix, maxCode;
	    if(first === 43 || first === 45){
	      third = it.charCodeAt(2);
	      if(third === 88 || third === 120)return NaN; // Number('+0x1') should be NaN, old V8 fix
	    } else if(first === 48){
	      switch(it.charCodeAt(1)){
	        case 66 : case 98  : radix = 2; maxCode = 49; break; // fast equal /^0b[01]+$/i
	        case 79 : case 111 : radix = 8; maxCode = 55; break; // fast equal /^0o[0-7]+$/i
	        default : return +it;
	      }
	      for(var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++){
	        code = digits.charCodeAt(i);
	        // parseInt parses a string to a first unavailable symbol
	        // but ToNumber should return NaN if a string contains unavailable symbols
	        if(code < 48 || code > maxCode)return NaN;
	      } return parseInt(digits, radix);
	    }
	  } return +it;
	};
	
	if(!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')){
	  $Number = function Number(value){
	    var it = arguments.length < 1 ? 0 : value
	      , that = this;
	    return that instanceof $Number
	      // check on 1..constructor(foo) case
	      && (BROKEN_COF ? fails(function(){ proto.valueOf.call(that); }) : cof(that) != NUMBER)
	        ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
	  };
	  for(var keys = __webpack_require__(6) ? gOPN(Base) : (
	    // ES3:
	    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
	    // ES6 (in case, if modules with ES6 Number statics required before):
	    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
	    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
	  ).split(','), j = 0, key; keys.length > j; j++){
	    if(has(Base, key = keys[j]) && !has($Number, key)){
	      dP($Number, key, gOPD(Base, key));
	    }
	  }
	  $Number.prototype = proto;
	  proto.constructor = $Number;
	  __webpack_require__(18)(global, NUMBER, $Number);
	}

/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	var isObject       = __webpack_require__(13)
	  , setPrototypeOf = __webpack_require__(73).set;
	module.exports = function(that, target, C){
	  var P, S = target.constructor;
	  if(S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf){
	    setPrototypeOf(that, P);
	  } return that;
	};

/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export      = __webpack_require__(8)
	  , anInstance   = __webpack_require__(90)
	  , toInteger    = __webpack_require__(38)
	  , aNumberValue = __webpack_require__(91)
	  , repeat       = __webpack_require__(92)
	  , $toFixed     = 1..toFixed
	  , floor        = Math.floor
	  , data         = [0, 0, 0, 0, 0, 0]
	  , ERROR        = 'Number.toFixed: incorrect invocation!'
	  , ZERO         = '0';
	
	var multiply = function(n, c){
	  var i  = -1
	    , c2 = c;
	  while(++i < 6){
	    c2 += n * data[i];
	    data[i] = c2 % 1e7;
	    c2 = floor(c2 / 1e7);
	  }
	};
	var divide = function(n){
	  var i = 6
	    , c = 0;
	  while(--i >= 0){
	    c += data[i];
	    data[i] = floor(c / n);
	    c = (c % n) * 1e7;
	  }
	};
	var numToString = function(){
	  var i = 6
	    , s = '';
	  while(--i >= 0){
	    if(s !== '' || i === 0 || data[i] !== 0){
	      var t = String(data[i]);
	      s = s === '' ? t : s + repeat.call(ZERO, 7 - t.length) + t;
	    }
	  } return s;
	};
	var pow = function(x, n, acc){
	  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
	};
	var log = function(x){
	  var n  = 0
	    , x2 = x;
	  while(x2 >= 4096){
	    n += 12;
	    x2 /= 4096;
	  }
	  while(x2 >= 2){
	    n  += 1;
	    x2 /= 2;
	  } return n;
	};
	
	$export($export.P + $export.F * (!!$toFixed && (
	  0.00008.toFixed(3) !== '0.000' ||
	  0.9.toFixed(0) !== '1' ||
	  1.255.toFixed(2) !== '1.25' ||
	  1000000000000000128..toFixed(0) !== '1000000000000000128'
	) || !__webpack_require__(7)(function(){
	  // V8 ~ Android 4.3-
	  $toFixed.call({});
	})), 'Number', {
	  toFixed: function toFixed(fractionDigits){
	    var x = aNumberValue(this, ERROR)
	      , f = toInteger(fractionDigits)
	      , s = ''
	      , m = ZERO
	      , e, z, j, k;
	    if(f < 0 || f > 20)throw RangeError(ERROR);
	    if(x != x)return 'NaN';
	    if(x <= -1e21 || x >= 1e21)return String(x);
	    if(x < 0){
	      s = '-';
	      x = -x;
	    }
	    if(x > 1e-21){
	      e = log(x * pow(2, 69, 1)) - 69;
	      z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1);
	      z *= 0x10000000000000;
	      e = 52 - e;
	      if(e > 0){
	        multiply(0, z);
	        j = f;
	        while(j >= 7){
	          multiply(1e7, 0);
	          j -= 7;
	        }
	        multiply(pow(10, j, 1), 0);
	        j = e - 1;
	        while(j >= 23){
	          divide(1 << 23);
	          j -= 23;
	        }
	        divide(1 << j);
	        multiply(1, 1);
	        divide(2);
	        m = numToString();
	      } else {
	        multiply(0, z);
	        multiply(1 << -e, 0);
	        m = numToString() + repeat.call(ZERO, f);
	      }
	    }
	    if(f > 0){
	      k = m.length;
	      m = s + (k <= f ? '0.' + repeat.call(ZERO, f - k) + m : m.slice(0, k - f) + '.' + m.slice(k - f));
	    } else {
	      m = s + m;
	    } return m;
	  }
	});

/***/ },
/* 90 */
/***/ function(module, exports) {

	module.exports = function(it, Constructor, name, forbiddenField){
	  if(!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)){
	    throw TypeError(name + ': incorrect invocation!');
	  } return it;
	};

/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	var cof = __webpack_require__(34);
	module.exports = function(it, msg){
	  if(typeof it != 'number' && cof(it) != 'Number')throw TypeError(msg);
	  return +it;
	};

/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var toInteger = __webpack_require__(38)
	  , defined   = __webpack_require__(35);
	
	module.exports = function repeat(count){
	  var str = String(defined(this))
	    , res = ''
	    , n   = toInteger(count);
	  if(n < 0 || n == Infinity)throw RangeError("Count can't be negative");
	  for(;n > 0; (n >>>= 1) && (str += str))if(n & 1)res += str;
	  return res;
	};

/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export      = __webpack_require__(8)
	  , $fails       = __webpack_require__(7)
	  , aNumberValue = __webpack_require__(91)
	  , $toPrecision = 1..toPrecision;
	
	$export($export.P + $export.F * ($fails(function(){
	  // IE7-
	  return $toPrecision.call(1, undefined) !== '1';
	}) || !$fails(function(){
	  // V8 ~ Android 4.3-
	  $toPrecision.call({});
	})), 'Number', {
	  toPrecision: function toPrecision(precision){
	    var that = aNumberValue(this, 'Number#toPrecision: incorrect invocation!');
	    return precision === undefined ? $toPrecision.call(that) : $toPrecision.call(that, precision); 
	  }
	});

/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.1 Number.EPSILON
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Number', {EPSILON: Math.pow(2, -52)});

/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.2 Number.isFinite(number)
	var $export   = __webpack_require__(8)
	  , _isFinite = __webpack_require__(4).isFinite;
	
	$export($export.S, 'Number', {
	  isFinite: function isFinite(it){
	    return typeof it == 'number' && _isFinite(it);
	  }
	});

/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.3 Number.isInteger(number)
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Number', {isInteger: __webpack_require__(97)});

/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.3 Number.isInteger(number)
	var isObject = __webpack_require__(13)
	  , floor    = Math.floor;
	module.exports = function isInteger(it){
	  return !isObject(it) && isFinite(it) && floor(it) === it;
	};

/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.4 Number.isNaN(number)
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Number', {
	  isNaN: function isNaN(number){
	    return number != number;
	  }
	});

/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.5 Number.isSafeInteger(number)
	var $export   = __webpack_require__(8)
	  , isInteger = __webpack_require__(97)
	  , abs       = Math.abs;
	
	$export($export.S, 'Number', {
	  isSafeInteger: function isSafeInteger(number){
	    return isInteger(number) && abs(number) <= 0x1fffffffffffff;
	  }
	});

/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.6 Number.MAX_SAFE_INTEGER
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Number', {MAX_SAFE_INTEGER: 0x1fffffffffffff});

/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.10 Number.MIN_SAFE_INTEGER
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Number', {MIN_SAFE_INTEGER: -0x1fffffffffffff});

/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	var $export     = __webpack_require__(8)
	  , $parseFloat = __webpack_require__(86);
	// 20.1.2.12 Number.parseFloat(string)
	$export($export.S + $export.F * (Number.parseFloat != $parseFloat), 'Number', {parseFloat: $parseFloat});

/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	var $export   = __webpack_require__(8)
	  , $parseInt = __webpack_require__(82);
	// 20.1.2.13 Number.parseInt(string, radix)
	$export($export.S + $export.F * (Number.parseInt != $parseInt), 'Number', {parseInt: $parseInt});

/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.3 Math.acosh(x)
	var $export = __webpack_require__(8)
	  , log1p   = __webpack_require__(105)
	  , sqrt    = Math.sqrt
	  , $acosh  = Math.acosh;
	
	$export($export.S + $export.F * !($acosh
	  // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
	  && Math.floor($acosh(Number.MAX_VALUE)) == 710
	  // Tor Browser bug: Math.acosh(Infinity) -> NaN 
	  && $acosh(Infinity) == Infinity
	), 'Math', {
	  acosh: function acosh(x){
	    return (x = +x) < 1 ? NaN : x > 94906265.62425156
	      ? Math.log(x) + Math.LN2
	      : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
	  }
	});

/***/ },
/* 105 */
/***/ function(module, exports) {

	// 20.2.2.20 Math.log1p(x)
	module.exports = Math.log1p || function log1p(x){
	  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
	};

/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.5 Math.asinh(x)
	var $export = __webpack_require__(8)
	  , $asinh  = Math.asinh;
	
	function asinh(x){
	  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
	}
	
	// Tor Browser bug: Math.asinh(0) -> -0 
	$export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', {asinh: asinh});

/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.7 Math.atanh(x)
	var $export = __webpack_require__(8)
	  , $atanh  = Math.atanh;
	
	// Tor Browser bug: Math.atanh(-0) -> 0 
	$export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {
	  atanh: function atanh(x){
	    return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
	  }
	});

/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.9 Math.cbrt(x)
	var $export = __webpack_require__(8)
	  , sign    = __webpack_require__(109);
	
	$export($export.S, 'Math', {
	  cbrt: function cbrt(x){
	    return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
	  }
	});

/***/ },
/* 109 */
/***/ function(module, exports) {

	// 20.2.2.28 Math.sign(x)
	module.exports = Math.sign || function sign(x){
	  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
	};

/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.11 Math.clz32(x)
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Math', {
	  clz32: function clz32(x){
	    return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
	  }
	});

/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.12 Math.cosh(x)
	var $export = __webpack_require__(8)
	  , exp     = Math.exp;
	
	$export($export.S, 'Math', {
	  cosh: function cosh(x){
	    return (exp(x = +x) + exp(-x)) / 2;
	  }
	});

/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.14 Math.expm1(x)
	var $export = __webpack_require__(8)
	  , $expm1  = __webpack_require__(113);
	
	$export($export.S + $export.F * ($expm1 != Math.expm1), 'Math', {expm1: $expm1});

/***/ },
/* 113 */
/***/ function(module, exports) {

	// 20.2.2.14 Math.expm1(x)
	var $expm1 = Math.expm1;
	module.exports = (!$expm1
	  // Old FF bug
	  || $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168
	  // Tor Browser bug
	  || $expm1(-2e-17) != -2e-17
	) ? function expm1(x){
	  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
	} : $expm1;

/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.16 Math.fround(x)
	var $export   = __webpack_require__(8)
	  , sign      = __webpack_require__(109)
	  , pow       = Math.pow
	  , EPSILON   = pow(2, -52)
	  , EPSILON32 = pow(2, -23)
	  , MAX32     = pow(2, 127) * (2 - EPSILON32)
	  , MIN32     = pow(2, -126);
	
	var roundTiesToEven = function(n){
	  return n + 1 / EPSILON - 1 / EPSILON;
	};
	
	
	$export($export.S, 'Math', {
	  fround: function fround(x){
	    var $abs  = Math.abs(x)
	      , $sign = sign(x)
	      , a, result;
	    if($abs < MIN32)return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
	    a = (1 + EPSILON32 / EPSILON) * $abs;
	    result = a - (a - $abs);
	    if(result > MAX32 || result != result)return $sign * Infinity;
	    return $sign * result;
	  }
	});

/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.17 Math.hypot([value1[, value2[,  ]]])
	var $export = __webpack_require__(8)
	  , abs     = Math.abs;
	
	$export($export.S, 'Math', {
	  hypot: function hypot(value1, value2){ // eslint-disable-line no-unused-vars
	    var sum  = 0
	      , i    = 0
	      , aLen = arguments.length
	      , larg = 0
	      , arg, div;
	    while(i < aLen){
	      arg = abs(arguments[i++]);
	      if(larg < arg){
	        div  = larg / arg;
	        sum  = sum * div * div + 1;
	        larg = arg;
	      } else if(arg > 0){
	        div  = arg / larg;
	        sum += div * div;
	      } else sum += arg;
	    }
	    return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
	  }
	});

/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.18 Math.imul(x, y)
	var $export = __webpack_require__(8)
	  , $imul   = Math.imul;
	
	// some WebKit versions fails with big numbers, some has wrong arity
	$export($export.S + $export.F * __webpack_require__(7)(function(){
	  return $imul(0xffffffff, 5) != -5 || $imul.length != 2;
	}), 'Math', {
	  imul: function imul(x, y){
	    var UINT16 = 0xffff
	      , xn = +x
	      , yn = +y
	      , xl = UINT16 & xn
	      , yl = UINT16 & yn;
	    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
	  }
	});

/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.21 Math.log10(x)
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Math', {
	  log10: function log10(x){
	    return Math.log(x) / Math.LN10;
	  }
	});

/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.20 Math.log1p(x)
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Math', {log1p: __webpack_require__(105)});

/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.22 Math.log2(x)
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Math', {
	  log2: function log2(x){
	    return Math.log(x) / Math.LN2;
	  }
	});

/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.28 Math.sign(x)
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Math', {sign: __webpack_require__(109)});

/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.30 Math.sinh(x)
	var $export = __webpack_require__(8)
	  , expm1   = __webpack_require__(113)
	  , exp     = Math.exp;
	
	// V8 near Chromium 38 has a problem with very small numbers
	$export($export.S + $export.F * __webpack_require__(7)(function(){
	  return !Math.sinh(-2e-17) != -2e-17;
	}), 'Math', {
	  sinh: function sinh(x){
	    return Math.abs(x = +x) < 1
	      ? (expm1(x) - expm1(-x)) / 2
	      : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);
	  }
	});

/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.33 Math.tanh(x)
	var $export = __webpack_require__(8)
	  , expm1   = __webpack_require__(113)
	  , exp     = Math.exp;
	
	$export($export.S, 'Math', {
	  tanh: function tanh(x){
	    var a = expm1(x = +x)
	      , b = expm1(-x);
	    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
	  }
	});

/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.34 Math.trunc(x)
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Math', {
	  trunc: function trunc(it){
	    return (it > 0 ? Math.floor : Math.ceil)(it);
	  }
	});

/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

	var $export        = __webpack_require__(8)
	  , toIndex        = __webpack_require__(39)
	  , fromCharCode   = String.fromCharCode
	  , $fromCodePoint = String.fromCodePoint;
	
	// length should be 1, old FF problem
	$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
	  // 21.1.2.2 String.fromCodePoint(...codePoints)
	  fromCodePoint: function fromCodePoint(x){ // eslint-disable-line no-unused-vars
	    var res  = []
	      , aLen = arguments.length
	      , i    = 0
	      , code;
	    while(aLen > i){
	      code = +arguments[i++];
	      if(toIndex(code, 0x10ffff) !== code)throw RangeError(code + ' is not a valid code point');
	      res.push(code < 0x10000
	        ? fromCharCode(code)
	        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)
	      );
	    } return res.join('');
	  }
	});

/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	var $export   = __webpack_require__(8)
	  , toIObject = __webpack_require__(32)
	  , toLength  = __webpack_require__(37);
	
	$export($export.S, 'String', {
	  // 21.1.2.4 String.raw(callSite, ...substitutions)
	  raw: function raw(callSite){
	    var tpl  = toIObject(callSite.raw)
	      , len  = toLength(tpl.length)
	      , aLen = arguments.length
	      , res  = []
	      , i    = 0;
	    while(len > i){
	      res.push(String(tpl[i++]));
	      if(i < aLen)res.push(String(arguments[i]));
	    } return res.join('');
	  }
	});

/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 21.1.3.25 String.prototype.trim()
	__webpack_require__(83)('trim', function($trim){
	  return function trim(){
	    return $trim(this, 3);
	  };
	});

/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $at  = __webpack_require__(128)(true);
	
	// 21.1.3.27 String.prototype[@@iterator]()
	__webpack_require__(129)(String, 'String', function(iterated){
	  this._t = String(iterated); // target
	  this._i = 0;                // next index
	// 21.1.5.2.1 %StringIteratorPrototype%.next()
	}, function(){
	  var O     = this._t
	    , index = this._i
	    , point;
	  if(index >= O.length)return {value: undefined, done: true};
	  point = $at(O, index);
	  this._i += point.length;
	  return {value: point, done: false};
	});

/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(38)
	  , defined   = __webpack_require__(35);
	// true  -> String#at
	// false -> String#codePointAt
	module.exports = function(TO_STRING){
	  return function(that, pos){
	    var s = String(defined(that))
	      , i = toInteger(pos)
	      , l = s.length
	      , a, b;
	    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
	    a = s.charCodeAt(i);
	    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
	      ? TO_STRING ? s.charAt(i) : a
	      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
	  };
	};

/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var LIBRARY        = __webpack_require__(28)
	  , $export        = __webpack_require__(8)
	  , redefine       = __webpack_require__(18)
	  , hide           = __webpack_require__(10)
	  , has            = __webpack_require__(5)
	  , Iterators      = __webpack_require__(130)
	  , $iterCreate    = __webpack_require__(131)
	  , setToStringTag = __webpack_require__(24)
	  , getPrototypeOf = __webpack_require__(59)
	  , ITERATOR       = __webpack_require__(25)('iterator')
	  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`
	  , FF_ITERATOR    = '@@iterator'
	  , KEYS           = 'keys'
	  , VALUES         = 'values';
	
	var returnThis = function(){ return this; };
	
	module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){
	  $iterCreate(Constructor, NAME, next);
	  var getMethod = function(kind){
	    if(!BUGGY && kind in proto)return proto[kind];
	    switch(kind){
	      case KEYS: return function keys(){ return new Constructor(this, kind); };
	      case VALUES: return function values(){ return new Constructor(this, kind); };
	    } return function entries(){ return new Constructor(this, kind); };
	  };
	  var TAG        = NAME + ' Iterator'
	    , DEF_VALUES = DEFAULT == VALUES
	    , VALUES_BUG = false
	    , proto      = Base.prototype
	    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
	    , $default   = $native || getMethod(DEFAULT)
	    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined
	    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native
	    , methods, key, IteratorPrototype;
	  // Fix native
	  if($anyNative){
	    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));
	    if(IteratorPrototype !== Object.prototype){
	      // Set @@toStringTag to native iterators
	      setToStringTag(IteratorPrototype, TAG, true);
	      // fix for some old engines
	      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);
	    }
	  }
	  // fix Array#{values, @@iterator}.name in V8 / FF
	  if(DEF_VALUES && $native && $native.name !== VALUES){
	    VALUES_BUG = true;
	    $default = function values(){ return $native.call(this); };
	  }
	  // Define iterator
	  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){
	    hide(proto, ITERATOR, $default);
	  }
	  // Plug for library
	  Iterators[NAME] = $default;
	  Iterators[TAG]  = returnThis;
	  if(DEFAULT){
	    methods = {
	      values:  DEF_VALUES ? $default : getMethod(VALUES),
	      keys:    IS_SET     ? $default : getMethod(KEYS),
	      entries: $entries
	    };
	    if(FORCED)for(key in methods){
	      if(!(key in proto))redefine(proto, key, methods[key]);
	    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
	  }
	  return methods;
	};

/***/ },
/* 130 */
/***/ function(module, exports) {

	module.exports = {};

/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var create         = __webpack_require__(46)
	  , descriptor     = __webpack_require__(17)
	  , setToStringTag = __webpack_require__(24)
	  , IteratorPrototype = {};
	
	// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
	__webpack_require__(10)(IteratorPrototype, __webpack_require__(25)('iterator'), function(){ return this; });
	
	module.exports = function(Constructor, NAME, next){
	  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});
	  setToStringTag(Constructor, NAME + ' Iterator');
	};

/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(8)
	  , $at     = __webpack_require__(128)(false);
	$export($export.P, 'String', {
	  // 21.1.3.3 String.prototype.codePointAt(pos)
	  codePointAt: function codePointAt(pos){
	    return $at(this, pos);
	  }
	});

/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	// 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])
	'use strict';
	var $export   = __webpack_require__(8)
	  , toLength  = __webpack_require__(37)
	  , context   = __webpack_require__(134)
	  , ENDS_WITH = 'endsWith'
	  , $endsWith = ''[ENDS_WITH];
	
	$export($export.P + $export.F * __webpack_require__(136)(ENDS_WITH), 'String', {
	  endsWith: function endsWith(searchString /*, endPosition = @length */){
	    var that = context(this, searchString, ENDS_WITH)
	      , endPosition = arguments.length > 1 ? arguments[1] : undefined
	      , len    = toLength(that.length)
	      , end    = endPosition === undefined ? len : Math.min(toLength(endPosition), len)
	      , search = String(searchString);
	    return $endsWith
	      ? $endsWith.call(that, search, end)
	      : that.slice(end - search.length, end) === search;
	  }
	});

/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	// helper for String#{startsWith, endsWith, includes}
	var isRegExp = __webpack_require__(135)
	  , defined  = __webpack_require__(35);
	
	module.exports = function(that, searchString, NAME){
	  if(isRegExp(searchString))throw TypeError('String#' + NAME + " doesn't accept regex!");
	  return String(defined(that));
	};

/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	// 7.2.8 IsRegExp(argument)
	var isObject = __webpack_require__(13)
	  , cof      = __webpack_require__(34)
	  , MATCH    = __webpack_require__(25)('match');
	module.exports = function(it){
	  var isRegExp;
	  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
	};

/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	var MATCH = __webpack_require__(25)('match');
	module.exports = function(KEY){
	  var re = /./;
	  try {
	    '/./'[KEY](re);
	  } catch(e){
	    try {
	      re[MATCH] = false;
	      return !'/./'[KEY](re);
	    } catch(f){ /* empty */ }
	  } return true;
	};

/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	// 21.1.3.7 String.prototype.includes(searchString, position = 0)
	'use strict';
	var $export  = __webpack_require__(8)
	  , context  = __webpack_require__(134)
	  , INCLUDES = 'includes';
	
	$export($export.P + $export.F * __webpack_require__(136)(INCLUDES), 'String', {
	  includes: function includes(searchString /*, position = 0 */){
	    return !!~context(this, searchString, INCLUDES)
	      .indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(8);
	
	$export($export.P, 'String', {
	  // 21.1.3.13 String.prototype.repeat(count)
	  repeat: __webpack_require__(92)
	});

/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	// 21.1.3.18 String.prototype.startsWith(searchString [, position ])
	'use strict';
	var $export     = __webpack_require__(8)
	  , toLength    = __webpack_require__(37)
	  , context     = __webpack_require__(134)
	  , STARTS_WITH = 'startsWith'
	  , $startsWith = ''[STARTS_WITH];
	
	$export($export.P + $export.F * __webpack_require__(136)(STARTS_WITH), 'String', {
	  startsWith: function startsWith(searchString /*, position = 0 */){
	    var that   = context(this, searchString, STARTS_WITH)
	      , index  = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length))
	      , search = String(searchString);
	    return $startsWith
	      ? $startsWith.call(that, search, index)
	      : that.slice(index, index + search.length) === search;
	  }
	});

/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.2 String.prototype.anchor(name)
	__webpack_require__(141)('anchor', function(createHTML){
	  return function anchor(name){
	    return createHTML(this, 'a', 'name', name);
	  }
	});

/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(8)
	  , fails   = __webpack_require__(7)
	  , defined = __webpack_require__(35)
	  , quot    = /"/g;
	// B.2.3.2.1 CreateHTML(string, tag, attribute, value)
	var createHTML = function(string, tag, attribute, value) {
	  var S  = String(defined(string))
	    , p1 = '<' + tag;
	  if(attribute !== '')p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
	  return p1 + '>' + S + '</' + tag + '>';
	};
	module.exports = function(NAME, exec){
	  var O = {};
	  O[NAME] = exec(createHTML);
	  $export($export.P + $export.F * fails(function(){
	    var test = ''[NAME]('"');
	    return test !== test.toLowerCase() || test.split('"').length > 3;
	  }), 'String', O);
	};

/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.3 String.prototype.big()
	__webpack_require__(141)('big', function(createHTML){
	  return function big(){
	    return createHTML(this, 'big', '', '');
	  }
	});

/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.4 String.prototype.blink()
	__webpack_require__(141)('blink', function(createHTML){
	  return function blink(){
	    return createHTML(this, 'blink', '', '');
	  }
	});

/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.5 String.prototype.bold()
	__webpack_require__(141)('bold', function(createHTML){
	  return function bold(){
	    return createHTML(this, 'b', '', '');
	  }
	});

/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.6 String.prototype.fixed()
	__webpack_require__(141)('fixed', function(createHTML){
	  return function fixed(){
	    return createHTML(this, 'tt', '', '');
	  }
	});

/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.7 String.prototype.fontcolor(color)
	__webpack_require__(141)('fontcolor', function(createHTML){
	  return function fontcolor(color){
	    return createHTML(this, 'font', 'color', color);
	  }
	});

/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.8 String.prototype.fontsize(size)
	__webpack_require__(141)('fontsize', function(createHTML){
	  return function fontsize(size){
	    return createHTML(this, 'font', 'size', size);
	  }
	});

/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.9 String.prototype.italics()
	__webpack_require__(141)('italics', function(createHTML){
	  return function italics(){
	    return createHTML(this, 'i', '', '');
	  }
	});

/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.10 String.prototype.link(url)
	__webpack_require__(141)('link', function(createHTML){
	  return function link(url){
	    return createHTML(this, 'a', 'href', url);
	  }
	});

/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.11 String.prototype.small()
	__webpack_require__(141)('small', function(createHTML){
	  return function small(){
	    return createHTML(this, 'small', '', '');
	  }
	});

/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.12 String.prototype.strike()
	__webpack_require__(141)('strike', function(createHTML){
	  return function strike(){
	    return createHTML(this, 'strike', '', '');
	  }
	});

/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.13 String.prototype.sub()
	__webpack_require__(141)('sub', function(createHTML){
	  return function sub(){
	    return createHTML(this, 'sub', '', '');
	  }
	});

/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.14 String.prototype.sup()
	__webpack_require__(141)('sup', function(createHTML){
	  return function sup(){
	    return createHTML(this, 'sup', '', '');
	  }
	});

/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	// 20.3.3.1 / 15.9.4.4 Date.now()
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Date', {now: function(){ return new Date().getTime(); }});

/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export     = __webpack_require__(8)
	  , toObject    = __webpack_require__(58)
	  , toPrimitive = __webpack_require__(16);
	
	$export($export.P + $export.F * __webpack_require__(7)(function(){
	  return new Date(NaN).toJSON() !== null || Date.prototype.toJSON.call({toISOString: function(){ return 1; }}) !== 1;
	}), 'Date', {
	  toJSON: function toJSON(key){
	    var O  = toObject(this)
	      , pv = toPrimitive(O);
	    return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
	  }
	});

/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
	var $export = __webpack_require__(8)
	  , fails   = __webpack_require__(7)
	  , getTime = Date.prototype.getTime;
	
	var lz = function(num){
	  return num > 9 ? num : '0' + num;
	};
	
	// PhantomJS / old WebKit has a broken implementations
	$export($export.P + $export.F * (fails(function(){
	  return new Date(-5e13 - 1).toISOString() != '0385-07-25T07:06:39.999Z';
	}) || !fails(function(){
	  new Date(NaN).toISOString();
	})), 'Date', {
	  toISOString: function toISOString(){
	    if(!isFinite(getTime.call(this)))throw RangeError('Invalid time value');
	    var d = this
	      , y = d.getUTCFullYear()
	      , m = d.getUTCMilliseconds()
	      , s = y < 0 ? '-' : y > 9999 ? '+' : '';
	    return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) +
	      '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) +
	      'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) +
	      ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
	  }
	});

/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	var DateProto    = Date.prototype
	  , INVALID_DATE = 'Invalid Date'
	  , TO_STRING    = 'toString'
	  , $toString    = DateProto[TO_STRING]
	  , getTime      = DateProto.getTime;
	if(new Date(NaN) + '' != INVALID_DATE){
	  __webpack_require__(18)(DateProto, TO_STRING, function toString(){
	    var value = getTime.call(this);
	    return value === value ? $toString.call(this) : INVALID_DATE;
	  });
	}

/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

	var TO_PRIMITIVE = __webpack_require__(25)('toPrimitive')
	  , proto        = Date.prototype;
	
	if(!(TO_PRIMITIVE in proto))__webpack_require__(10)(proto, TO_PRIMITIVE, __webpack_require__(159));

/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var anObject    = __webpack_require__(12)
	  , toPrimitive = __webpack_require__(16)
	  , NUMBER      = 'number';
	
	module.exports = function(hint){
	  if(hint !== 'string' && hint !== NUMBER && hint !== 'default')throw TypeError('Incorrect hint');
	  return toPrimitive(anObject(this), hint != NUMBER);
	};

/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {

	// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Array', {isArray: __webpack_require__(45)});

/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var ctx            = __webpack_require__(20)
	  , $export        = __webpack_require__(8)
	  , toObject       = __webpack_require__(58)
	  , call           = __webpack_require__(162)
	  , isArrayIter    = __webpack_require__(163)
	  , toLength       = __webpack_require__(37)
	  , createProperty = __webpack_require__(164)
	  , getIterFn      = __webpack_require__(165);
	
	$export($export.S + $export.F * !__webpack_require__(166)(function(iter){ Array.from(iter); }), 'Array', {
	  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
	  from: function from(arrayLike/*, mapfn = undefined, thisArg = undefined*/){
	    var O       = toObject(arrayLike)
	      , C       = typeof this == 'function' ? this : Array
	      , aLen    = arguments.length
	      , mapfn   = aLen > 1 ? arguments[1] : undefined
	      , mapping = mapfn !== undefined
	      , index   = 0
	      , iterFn  = getIterFn(O)
	      , length, result, step, iterator;
	    if(mapping)mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
	    // if object isn't iterable or it's array with default iterator - use simple case
	    if(iterFn != undefined && !(C == Array && isArrayIter(iterFn))){
	      for(iterator = iterFn.call(O), result = new C; !(step = iterator.next()).done; index++){
	        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
	      }
	    } else {
	      length = toLength(O.length);
	      for(result = new C(length); length > index; index++){
	        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
	      }
	    }
	    result.length = index;
	    return result;
	  }
	});


/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

	// call something on iterator step with safe closing on error
	var anObject = __webpack_require__(12);
	module.exports = function(iterator, fn, value, entries){
	  try {
	    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
	  // 7.4.6 IteratorClose(iterator, completion)
	  } catch(e){
	    var ret = iterator['return'];
	    if(ret !== undefined)anObject(ret.call(iterator));
	    throw e;
	  }
	};

/***/ },
/* 163 */
/***/ function(module, exports, __webpack_require__) {

	// check on default Array iterator
	var Iterators  = __webpack_require__(130)
	  , ITERATOR   = __webpack_require__(25)('iterator')
	  , ArrayProto = Array.prototype;
	
	module.exports = function(it){
	  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
	};

/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $defineProperty = __webpack_require__(11)
	  , createDesc      = __webpack_require__(17);
	
	module.exports = function(object, index, value){
	  if(index in object)$defineProperty.f(object, index, createDesc(0, value));
	  else object[index] = value;
	};

/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	var classof   = __webpack_require__(75)
	  , ITERATOR  = __webpack_require__(25)('iterator')
	  , Iterators = __webpack_require__(130);
	module.exports = __webpack_require__(9).getIteratorMethod = function(it){
	  if(it != undefined)return it[ITERATOR]
	    || it['@@iterator']
	    || Iterators[classof(it)];
	};

/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	var ITERATOR     = __webpack_require__(25)('iterator')
	  , SAFE_CLOSING = false;
	
	try {
	  var riter = [7][ITERATOR]();
	  riter['return'] = function(){ SAFE_CLOSING = true; };
	  Array.from(riter, function(){ throw 2; });
	} catch(e){ /* empty */ }
	
	module.exports = function(exec, skipClosing){
	  if(!skipClosing && !SAFE_CLOSING)return false;
	  var safe = false;
	  try {
	    var arr  = [7]
	      , iter = arr[ITERATOR]();
	    iter.next = function(){ return {done: safe = true}; };
	    arr[ITERATOR] = function(){ return iter; };
	    exec(arr);
	  } catch(e){ /* empty */ }
	  return safe;
	};

/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export        = __webpack_require__(8)
	  , createProperty = __webpack_require__(164);
	
	// WebKit Array.of isn't generic
	$export($export.S + $export.F * __webpack_require__(7)(function(){
	  function F(){}
	  return !(Array.of.call(F) instanceof F);
	}), 'Array', {
	  // 22.1.2.3 Array.of( ...items)
	  of: function of(/* ...args */){
	    var index  = 0
	      , aLen   = arguments.length
	      , result = new (typeof this == 'function' ? this : Array)(aLen);
	    while(aLen > index)createProperty(result, index, arguments[index++]);
	    result.length = aLen;
	    return result;
	  }
	});

/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 22.1.3.13 Array.prototype.join(separator)
	var $export   = __webpack_require__(8)
	  , toIObject = __webpack_require__(32)
	  , arrayJoin = [].join;
	
	// fallback for not array-like strings
	$export($export.P + $export.F * (__webpack_require__(33) != Object || !__webpack_require__(169)(arrayJoin)), 'Array', {
	  join: function join(separator){
	    return arrayJoin.call(toIObject(this), separator === undefined ? ',' : separator);
	  }
	});

/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

	var fails = __webpack_require__(7);
	
	module.exports = function(method, arg){
	  return !!method && fails(function(){
	    arg ? method.call(null, function(){}, 1) : method.call(null);
	  });
	};

/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export    = __webpack_require__(8)
	  , html       = __webpack_require__(48)
	  , cof        = __webpack_require__(34)
	  , toIndex    = __webpack_require__(39)
	  , toLength   = __webpack_require__(37)
	  , arraySlice = [].slice;
	
	// fallback for not array-like ES3 strings and DOM objects
	$export($export.P + $export.F * __webpack_require__(7)(function(){
	  if(html)arraySlice.call(html);
	}), 'Array', {
	  slice: function slice(begin, end){
	    var len   = toLength(this.length)
	      , klass = cof(this);
	    end = end === undefined ? len : end;
	    if(klass == 'Array')return arraySlice.call(this, begin, end);
	    var start  = toIndex(begin, len)
	      , upTo   = toIndex(end, len)
	      , size   = toLength(upTo - start)
	      , cloned = Array(size)
	      , i      = 0;
	    for(; i < size; i++)cloned[i] = klass == 'String'
	      ? this.charAt(start + i)
	      : this[start + i];
	    return cloned;
	  }
	});

/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export   = __webpack_require__(8)
	  , aFunction = __webpack_require__(21)
	  , toObject  = __webpack_require__(58)
	  , fails     = __webpack_require__(7)
	  , $sort     = [].sort
	  , test      = [1, 2, 3];
	
	$export($export.P + $export.F * (fails(function(){
	  // IE8-
	  test.sort(undefined);
	}) || !fails(function(){
	  // V8 bug
	  test.sort(null);
	  // Old WebKit
	}) || !__webpack_require__(169)($sort)), 'Array', {
	  // 22.1.3.25 Array.prototype.sort(comparefn)
	  sort: function sort(comparefn){
	    return comparefn === undefined
	      ? $sort.call(toObject(this))
	      : $sort.call(toObject(this), aFunction(comparefn));
	  }
	});

/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export  = __webpack_require__(8)
	  , $forEach = __webpack_require__(173)(0)
	  , STRICT   = __webpack_require__(169)([].forEach, true);
	
	$export($export.P + $export.F * !STRICT, 'Array', {
	  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
	  forEach: function forEach(callbackfn /* , thisArg */){
	    return $forEach(this, callbackfn, arguments[1]);
	  }
	});

/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	// 0 -> Array#forEach
	// 1 -> Array#map
	// 2 -> Array#filter
	// 3 -> Array#some
	// 4 -> Array#every
	// 5 -> Array#find
	// 6 -> Array#findIndex
	var ctx      = __webpack_require__(20)
	  , IObject  = __webpack_require__(33)
	  , toObject = __webpack_require__(58)
	  , toLength = __webpack_require__(37)
	  , asc      = __webpack_require__(174);
	module.exports = function(TYPE, $create){
	  var IS_MAP        = TYPE == 1
	    , IS_FILTER     = TYPE == 2
	    , IS_SOME       = TYPE == 3
	    , IS_EVERY      = TYPE == 4
	    , IS_FIND_INDEX = TYPE == 6
	    , NO_HOLES      = TYPE == 5 || IS_FIND_INDEX
	    , create        = $create || asc;
	  return function($this, callbackfn, that){
	    var O      = toObject($this)
	      , self   = IObject(O)
	      , f      = ctx(callbackfn, that, 3)
	      , length = toLength(self.length)
	      , index  = 0
	      , result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined
	      , val, res;
	    for(;length > index; index++)if(NO_HOLES || index in self){
	      val = self[index];
	      res = f(val, index, O);
	      if(TYPE){
	        if(IS_MAP)result[index] = res;            // map
	        else if(res)switch(TYPE){
	          case 3: return true;                    // some
	          case 5: return val;                     // find
	          case 6: return index;                   // findIndex
	          case 2: result.push(val);               // filter
	        } else if(IS_EVERY)return false;          // every
	      }
	    }
	    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
	  };
	};

/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

	// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
	var speciesConstructor = __webpack_require__(175);
	
	module.exports = function(original, length){
	  return new (speciesConstructor(original))(length);
	};

/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(13)
	  , isArray  = __webpack_require__(45)
	  , SPECIES  = __webpack_require__(25)('species');
	
	module.exports = function(original){
	  var C;
	  if(isArray(original)){
	    C = original.constructor;
	    // cross-realm fallback
	    if(typeof C == 'function' && (C === Array || isArray(C.prototype)))C = undefined;
	    if(isObject(C)){
	      C = C[SPECIES];
	      if(C === null)C = undefined;
	    }
	  } return C === undefined ? Array : C;
	};

/***/ },
/* 176 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(8)
	  , $map    = __webpack_require__(173)(1);
	
	$export($export.P + $export.F * !__webpack_require__(169)([].map, true), 'Array', {
	  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
	  map: function map(callbackfn /* , thisArg */){
	    return $map(this, callbackfn, arguments[1]);
	  }
	});

/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(8)
	  , $filter = __webpack_require__(173)(2);
	
	$export($export.P + $export.F * !__webpack_require__(169)([].filter, true), 'Array', {
	  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
	  filter: function filter(callbackfn /* , thisArg */){
	    return $filter(this, callbackfn, arguments[1]);
	  }
	});

/***/ },
/* 178 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(8)
	  , $some   = __webpack_require__(173)(3);
	
	$export($export.P + $export.F * !__webpack_require__(169)([].some, true), 'Array', {
	  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
	  some: function some(callbackfn /* , thisArg */){
	    return $some(this, callbackfn, arguments[1]);
	  }
	});

/***/ },
/* 179 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(8)
	  , $every  = __webpack_require__(173)(4);
	
	$export($export.P + $export.F * !__webpack_require__(169)([].every, true), 'Array', {
	  // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])
	  every: function every(callbackfn /* , thisArg */){
	    return $every(this, callbackfn, arguments[1]);
	  }
	});

/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(8)
	  , $reduce = __webpack_require__(181);
	
	$export($export.P + $export.F * !__webpack_require__(169)([].reduce, true), 'Array', {
	  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
	  reduce: function reduce(callbackfn /* , initialValue */){
	    return $reduce(this, callbackfn, arguments.length, arguments[1], false);
	  }
	});

/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

	var aFunction = __webpack_require__(21)
	  , toObject  = __webpack_require__(58)
	  , IObject   = __webpack_require__(33)
	  , toLength  = __webpack_require__(37);
	
	module.exports = function(that, callbackfn, aLen, memo, isRight){
	  aFunction(callbackfn);
	  var O      = toObject(that)
	    , self   = IObject(O)
	    , length = toLength(O.length)
	    , index  = isRight ? length - 1 : 0
	    , i      = isRight ? -1 : 1;
	  if(aLen < 2)for(;;){
	    if(index in self){
	      memo = self[index];
	      index += i;
	      break;
	    }
	    index += i;
	    if(isRight ? index < 0 : length <= index){
	      throw TypeError('Reduce of empty array with no initial value');
	    }
	  }
	  for(;isRight ? index >= 0 : length > index; index += i)if(index in self){
	    memo = callbackfn(memo, self[index], index, O);
	  }
	  return memo;
	};

/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(8)
	  , $reduce = __webpack_require__(181);
	
	$export($export.P + $export.F * !__webpack_require__(169)([].reduceRight, true), 'Array', {
	  // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])
	  reduceRight: function reduceRight(callbackfn /* , initialValue */){
	    return $reduce(this, callbackfn, arguments.length, arguments[1], true);
	  }
	});

/***/ },
/* 183 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export       = __webpack_require__(8)
	  , $indexOf      = __webpack_require__(36)(false)
	  , $native       = [].indexOf
	  , NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;
	
	$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(169)($native)), 'Array', {
	  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
	  indexOf: function indexOf(searchElement /*, fromIndex = 0 */){
	    return NEGATIVE_ZERO
	      // convert -0 to +0
	      ? $native.apply(this, arguments) || 0
	      : $indexOf(this, searchElement, arguments[1]);
	  }
	});

/***/ },
/* 184 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export       = __webpack_require__(8)
	  , toIObject     = __webpack_require__(32)
	  , toInteger     = __webpack_require__(38)
	  , toLength      = __webpack_require__(37)
	  , $native       = [].lastIndexOf
	  , NEGATIVE_ZERO = !!$native && 1 / [1].lastIndexOf(1, -0) < 0;
	
	$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(169)($native)), 'Array', {
	  // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])
	  lastIndexOf: function lastIndexOf(searchElement /*, fromIndex = @[*-1] */){
	    // convert -0 to +0
	    if(NEGATIVE_ZERO)return $native.apply(this, arguments) || 0;
	    var O      = toIObject(this)
	      , length = toLength(O.length)
	      , index  = length - 1;
	    if(arguments.length > 1)index = Math.min(index, toInteger(arguments[1]));
	    if(index < 0)index = length + index;
	    for(;index >= 0; index--)if(index in O)if(O[index] === searchElement)return index || 0;
	    return -1;
	  }
	});

/***/ },
/* 185 */
/***/ function(module, exports, __webpack_require__) {

	// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
	var $export = __webpack_require__(8);
	
	$export($export.P, 'Array', {copyWithin: __webpack_require__(186)});
	
	__webpack_require__(187)('copyWithin');

/***/ },
/* 186 */
/***/ function(module, exports, __webpack_require__) {

	// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
	'use strict';
	var toObject = __webpack_require__(58)
	  , toIndex  = __webpack_require__(39)
	  , toLength = __webpack_require__(37);
	
	module.exports = [].copyWithin || function copyWithin(target/*= 0*/, start/*= 0, end = @length*/){
	  var O     = toObject(this)
	    , len   = toLength(O.length)
	    , to    = toIndex(target, len)
	    , from  = toIndex(start, len)
	    , end   = arguments.length > 2 ? arguments[2] : undefined
	    , count = Math.min((end === undefined ? len : toIndex(end, len)) - from, len - to)
	    , inc   = 1;
	  if(from < to && to < from + count){
	    inc  = -1;
	    from += count - 1;
	    to   += count - 1;
	  }
	  while(count-- > 0){
	    if(from in O)O[to] = O[from];
	    else delete O[to];
	    to   += inc;
	    from += inc;
	  } return O;
	};

/***/ },
/* 187 */
/***/ function(module, exports, __webpack_require__) {

	// 22.1.3.31 Array.prototype[@@unscopables]
	var UNSCOPABLES = __webpack_require__(25)('unscopables')
	  , ArrayProto  = Array.prototype;
	if(ArrayProto[UNSCOPABLES] == undefined)__webpack_require__(10)(ArrayProto, UNSCOPABLES, {});
	module.exports = function(key){
	  ArrayProto[UNSCOPABLES][key] = true;
	};

/***/ },
/* 188 */
/***/ function(module, exports, __webpack_require__) {

	// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
	var $export = __webpack_require__(8);
	
	$export($export.P, 'Array', {fill: __webpack_require__(189)});
	
	__webpack_require__(187)('fill');

/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
	'use strict';
	var toObject = __webpack_require__(58)
	  , toIndex  = __webpack_require__(39)
	  , toLength = __webpack_require__(37);
	module.exports = function fill(value /*, start = 0, end = @length */){
	  var O      = toObject(this)
	    , length = toLength(O.length)
	    , aLen   = arguments.length
	    , index  = toIndex(aLen > 1 ? arguments[1] : undefined, length)
	    , end    = aLen > 2 ? arguments[2] : undefined
	    , endPos = end === undefined ? length : toIndex(end, length);
	  while(endPos > index)O[index++] = value;
	  return O;
	};

/***/ },
/* 190 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)
	var $export = __webpack_require__(8)
	  , $find   = __webpack_require__(173)(5)
	  , KEY     = 'find'
	  , forced  = true;
	// Shouldn't skip holes
	if(KEY in [])Array(1)[KEY](function(){ forced = false; });
	$export($export.P + $export.F * forced, 'Array', {
	  find: function find(callbackfn/*, that = undefined */){
	    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});
	__webpack_require__(187)(KEY);

/***/ },
/* 191 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)
	var $export = __webpack_require__(8)
	  , $find   = __webpack_require__(173)(6)
	  , KEY     = 'findIndex'
	  , forced  = true;
	// Shouldn't skip holes
	if(KEY in [])Array(1)[KEY](function(){ forced = false; });
	$export($export.P + $export.F * forced, 'Array', {
	  findIndex: function findIndex(callbackfn/*, that = undefined */){
	    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});
	__webpack_require__(187)(KEY);

/***/ },
/* 192 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(193)('Array');

/***/ },
/* 193 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var global      = __webpack_require__(4)
	  , dP          = __webpack_require__(11)
	  , DESCRIPTORS = __webpack_require__(6)
	  , SPECIES     = __webpack_require__(25)('species');
	
	module.exports = function(KEY){
	  var C = global[KEY];
	  if(DESCRIPTORS && C && !C[SPECIES])dP.f(C, SPECIES, {
	    configurable: true,
	    get: function(){ return this; }
	  });
	};

/***/ },
/* 194 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var addToUnscopables = __webpack_require__(187)
	  , step             = __webpack_require__(195)
	  , Iterators        = __webpack_require__(130)
	  , toIObject        = __webpack_require__(32);
	
	// 22.1.3.4 Array.prototype.entries()
	// 22.1.3.13 Array.prototype.keys()
	// 22.1.3.29 Array.prototype.values()
	// 22.1.3.30 Array.prototype[@@iterator]()
	module.exports = __webpack_require__(129)(Array, 'Array', function(iterated, kind){
	  this._t = toIObject(iterated); // target
	  this._i = 0;                   // next index
	  this._k = kind;                // kind
	// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
	}, function(){
	  var O     = this._t
	    , kind  = this._k
	    , index = this._i++;
	  if(!O || index >= O.length){
	    this._t = undefined;
	    return step(1);
	  }
	  if(kind == 'keys'  )return step(0, index);
	  if(kind == 'values')return step(0, O[index]);
	  return step(0, [index, O[index]]);
	}, 'values');
	
	// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
	Iterators.Arguments = Iterators.Array;
	
	addToUnscopables('keys');
	addToUnscopables('values');
	addToUnscopables('entries');

/***/ },
/* 195 */
/***/ function(module, exports) {

	module.exports = function(done, value){
	  return {value: value, done: !!done};
	};

/***/ },
/* 196 */
/***/ function(module, exports, __webpack_require__) {

	var global            = __webpack_require__(4)
	  , inheritIfRequired = __webpack_require__(88)
	  , dP                = __webpack_require__(11).f
	  , gOPN              = __webpack_require__(50).f
	  , isRegExp          = __webpack_require__(135)
	  , $flags            = __webpack_require__(197)
	  , $RegExp           = global.RegExp
	  , Base              = $RegExp
	  , proto             = $RegExp.prototype
	  , re1               = /a/g
	  , re2               = /a/g
	  // "new" creates a new object, old webkit buggy here
	  , CORRECT_NEW       = new $RegExp(re1) !== re1;
	
	if(__webpack_require__(6) && (!CORRECT_NEW || __webpack_require__(7)(function(){
	  re2[__webpack_require__(25)('match')] = false;
	  // RegExp constructor can alter flags and IsRegExp works correct with @@match
	  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
	}))){
	  $RegExp = function RegExp(p, f){
	    var tiRE = this instanceof $RegExp
	      , piRE = isRegExp(p)
	      , fiU  = f === undefined;
	    return !tiRE && piRE && p.constructor === $RegExp && fiU ? p
	      : inheritIfRequired(CORRECT_NEW
	        ? new Base(piRE && !fiU ? p.source : p, f)
	        : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f)
	      , tiRE ? this : proto, $RegExp);
	  };
	  var proxy = function(key){
	    key in $RegExp || dP($RegExp, key, {
	      configurable: true,
	      get: function(){ return Base[key]; },
	      set: function(it){ Base[key] = it; }
	    });
	  };
	  for(var keys = gOPN(Base), i = 0; keys.length > i; )proxy(keys[i++]);
	  proto.constructor = $RegExp;
	  $RegExp.prototype = proto;
	  __webpack_require__(18)(global, 'RegExp', $RegExp);
	}
	
	__webpack_require__(193)('RegExp');

/***/ },
/* 197 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 21.2.5.3 get RegExp.prototype.flags
	var anObject = __webpack_require__(12);
	module.exports = function(){
	  var that   = anObject(this)
	    , result = '';
	  if(that.global)     result += 'g';
	  if(that.ignoreCase) result += 'i';
	  if(that.multiline)  result += 'm';
	  if(that.unicode)    result += 'u';
	  if(that.sticky)     result += 'y';
	  return result;
	};

/***/ },
/* 198 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	__webpack_require__(199);
	var anObject    = __webpack_require__(12)
	  , $flags      = __webpack_require__(197)
	  , DESCRIPTORS = __webpack_require__(6)
	  , TO_STRING   = 'toString'
	  , $toString   = /./[TO_STRING];
	
	var define = function(fn){
	  __webpack_require__(18)(RegExp.prototype, TO_STRING, fn, true);
	};
	
	// 21.2.5.14 RegExp.prototype.toString()
	if(__webpack_require__(7)(function(){ return $toString.call({source: 'a', flags: 'b'}) != '/a/b'; })){
	  define(function toString(){
	    var R = anObject(this);
	    return '/'.concat(R.source, '/',
	      'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined);
	  });
	// FF44- RegExp#toString has a wrong name
	} else if($toString.name != TO_STRING){
	  define(function toString(){
	    return $toString.call(this);
	  });
	}

/***/ },
/* 199 */
/***/ function(module, exports, __webpack_require__) {

	// 21.2.5.3 get RegExp.prototype.flags()
	if(__webpack_require__(6) && /./g.flags != 'g')__webpack_require__(11).f(RegExp.prototype, 'flags', {
	  configurable: true,
	  get: __webpack_require__(197)
	});

/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

	// @@match logic
	__webpack_require__(201)('match', 1, function(defined, MATCH, $match){
	  // 21.1.3.11 String.prototype.match(regexp)
	  return [function match(regexp){
	    'use strict';
	    var O  = defined(this)
	      , fn = regexp == undefined ? undefined : regexp[MATCH];
	    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
	  }, $match];
	});

/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var hide     = __webpack_require__(10)
	  , redefine = __webpack_require__(18)
	  , fails    = __webpack_require__(7)
	  , defined  = __webpack_require__(35)
	  , wks      = __webpack_require__(25);
	
	module.exports = function(KEY, length, exec){
	  var SYMBOL   = wks(KEY)
	    , fns      = exec(defined, SYMBOL, ''[KEY])
	    , strfn    = fns[0]
	    , rxfn     = fns[1];
	  if(fails(function(){
	    var O = {};
	    O[SYMBOL] = function(){ return 7; };
	    return ''[KEY](O) != 7;
	  })){
	    redefine(String.prototype, KEY, strfn);
	    hide(RegExp.prototype, SYMBOL, length == 2
	      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
	      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
	      ? function(string, arg){ return rxfn.call(string, this, arg); }
	      // 21.2.5.6 RegExp.prototype[@@match](string)
	      // 21.2.5.9 RegExp.prototype[@@search](string)
	      : function(string){ return rxfn.call(string, this); }
	    );
	  }
	};

/***/ },
/* 202 */
/***/ function(module, exports, __webpack_require__) {

	// @@replace logic
	__webpack_require__(201)('replace', 2, function(defined, REPLACE, $replace){
	  // 21.1.3.14 String.prototype.replace(searchValue, replaceValue)
	  return [function replace(searchValue, replaceValue){
	    'use strict';
	    var O  = defined(this)
	      , fn = searchValue == undefined ? undefined : searchValue[REPLACE];
	    return fn !== undefined
	      ? fn.call(searchValue, O, replaceValue)
	      : $replace.call(String(O), searchValue, replaceValue);
	  }, $replace];
	});

/***/ },
/* 203 */
/***/ function(module, exports, __webpack_require__) {

	// @@search logic
	__webpack_require__(201)('search', 1, function(defined, SEARCH, $search){
	  // 21.1.3.15 String.prototype.search(regexp)
	  return [function search(regexp){
	    'use strict';
	    var O  = defined(this)
	      , fn = regexp == undefined ? undefined : regexp[SEARCH];
	    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
	  }, $search];
	});

/***/ },
/* 204 */
/***/ function(module, exports, __webpack_require__) {

	// @@split logic
	__webpack_require__(201)('split', 2, function(defined, SPLIT, $split){
	  'use strict';
	  var isRegExp   = __webpack_require__(135)
	    , _split     = $split
	    , $push      = [].push
	    , $SPLIT     = 'split'
	    , LENGTH     = 'length'
	    , LAST_INDEX = 'lastIndex';
	  if(
	    'abbc'[$SPLIT](/(b)*/)[1] == 'c' ||
	    'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 ||
	    'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 ||
	    '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 ||
	    '.'[$SPLIT](/()()/)[LENGTH] > 1 ||
	    ''[$SPLIT](/.?/)[LENGTH]
	  ){
	    var NPCG = /()??/.exec('')[1] === undefined; // nonparticipating capturing group
	    // based on es5-shim implementation, need to rework it
	    $split = function(separator, limit){
	      var string = String(this);
	      if(separator === undefined && limit === 0)return [];
	      // If `separator` is not a regex, use native split
	      if(!isRegExp(separator))return _split.call(string, separator, limit);
	      var output = [];
	      var flags = (separator.ignoreCase ? 'i' : '') +
	                  (separator.multiline ? 'm' : '') +
	                  (separator.unicode ? 'u' : '') +
	                  (separator.sticky ? 'y' : '');
	      var lastLastIndex = 0;
	      var splitLimit = limit === undefined ? 4294967295 : limit >>> 0;
	      // Make `global` and avoid `lastIndex` issues by working with a copy
	      var separatorCopy = new RegExp(separator.source, flags + 'g');
	      var separator2, match, lastIndex, lastLength, i;
	      // Doesn't need flags gy, but they don't hurt
	      if(!NPCG)separator2 = new RegExp('^' + separatorCopy.source + '$(?!\\s)', flags);
	      while(match = separatorCopy.exec(string)){
	        // `separatorCopy.lastIndex` is not reliable cross-browser
	        lastIndex = match.index + match[0][LENGTH];
	        if(lastIndex > lastLastIndex){
	          output.push(string.slice(lastLastIndex, match.index));
	          // Fix browsers whose `exec` methods don't consistently return `undefined` for NPCG
	          if(!NPCG && match[LENGTH] > 1)match[0].replace(separator2, function(){
	            for(i = 1; i < arguments[LENGTH] - 2; i++)if(arguments[i] === undefined)match[i] = undefined;
	          });
	          if(match[LENGTH] > 1 && match.index < string[LENGTH])$push.apply(output, match.slice(1));
	          lastLength = match[0][LENGTH];
	          lastLastIndex = lastIndex;
	          if(output[LENGTH] >= splitLimit)break;
	        }
	        if(separatorCopy[LAST_INDEX] === match.index)separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
	      }
	      if(lastLastIndex === string[LENGTH]){
	        if(lastLength || !separatorCopy.test(''))output.push('');
	      } else output.push(string.slice(lastLastIndex));
	      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
	    };
	  // Chakra, V8
	  } else if('0'[$SPLIT](undefined, 0)[LENGTH]){
	    $split = function(separator, limit){
	      return separator === undefined && limit === 0 ? [] : _split.call(this, separator, limit);
	    };
	  }
	  // 21.1.3.17 String.prototype.split(separator, limit)
	  return [function split(separator, limit){
	    var O  = defined(this)
	      , fn = separator == undefined ? undefined : separator[SPLIT];
	    return fn !== undefined ? fn.call(separator, O, limit) : $split.call(String(O), separator, limit);
	  }, $split];
	});

/***/ },
/* 205 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var LIBRARY            = __webpack_require__(28)
	  , global             = __webpack_require__(4)
	  , ctx                = __webpack_require__(20)
	  , classof            = __webpack_require__(75)
	  , $export            = __webpack_require__(8)
	  , isObject           = __webpack_require__(13)
	  , anObject           = __webpack_require__(12)
	  , aFunction          = __webpack_require__(21)
	  , anInstance         = __webpack_require__(90)
	  , forOf              = __webpack_require__(206)
	  , setProto           = __webpack_require__(73).set
	  , speciesConstructor = __webpack_require__(207)
	  , task               = __webpack_require__(208).set
	  , microtask          = __webpack_require__(209)()
	  , PROMISE            = 'Promise'
	  , TypeError          = global.TypeError
	  , process            = global.process
	  , $Promise           = global[PROMISE]
	  , process            = global.process
	  , isNode             = classof(process) == 'process'
	  , empty              = function(){ /* empty */ }
	  , Internal, GenericPromiseCapability, Wrapper;
	
	var USE_NATIVE = !!function(){
	  try {
	    // correct subclassing with @@species support
	    var promise     = $Promise.resolve(1)
	      , FakePromise = (promise.constructor = {})[__webpack_require__(25)('species')] = function(exec){ exec(empty, empty); };
	    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
	    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;
	  } catch(e){ /* empty */ }
	}();
	
	// helpers
	var sameConstructor = function(a, b){
	  // with library wrapper special case
	  return a === b || a === $Promise && b === Wrapper;
	};
	var isThenable = function(it){
	  var then;
	  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
	};
	var newPromiseCapability = function(C){
	  return sameConstructor($Promise, C)
	    ? new PromiseCapability(C)
	    : new GenericPromiseCapability(C);
	};
	var PromiseCapability = GenericPromiseCapability = function(C){
	  var resolve, reject;
	  this.promise = new C(function($$resolve, $$reject){
	    if(resolve !== undefined || reject !== undefined)throw TypeError('Bad Promise constructor');
	    resolve = $$resolve;
	    reject  = $$reject;
	  });
	  this.resolve = aFunction(resolve);
	  this.reject  = aFunction(reject);
	};
	var perform = function(exec){
	  try {
	    exec();
	  } catch(e){
	    return {error: e};
	  }
	};
	var notify = function(promise, isReject){
	  if(promise._n)return;
	  promise._n = true;
	  var chain = promise._c;
	  microtask(function(){
	    var value = promise._v
	      , ok    = promise._s == 1
	      , i     = 0;
	    var run = function(reaction){
	      var handler = ok ? reaction.ok : reaction.fail
	        , resolve = reaction.resolve
	        , reject  = reaction.reject
	        , domain  = reaction.domain
	        , result, then;
	      try {
	        if(handler){
	          if(!ok){
	            if(promise._h == 2)onHandleUnhandled(promise);
	            promise._h = 1;
	          }
	          if(handler === true)result = value;
	          else {
	            if(domain)domain.enter();
	            result = handler(value);
	            if(domain)domain.exit();
	          }
	          if(result === reaction.promise){
	            reject(TypeError('Promise-chain cycle'));
	          } else if(then = isThenable(result)){
	            then.call(result, resolve, reject);
	          } else resolve(result);
	        } else reject(value);
	      } catch(e){
	        reject(e);
	      }
	    };
	    while(chain.length > i)run(chain[i++]); // variable length - can't use forEach
	    promise._c = [];
	    promise._n = false;
	    if(isReject && !promise._h)onUnhandled(promise);
	  });
	};
	var onUnhandled = function(promise){
	  task.call(global, function(){
	    var value = promise._v
	      , abrupt, handler, console;
	    if(isUnhandled(promise)){
	      abrupt = perform(function(){
	        if(isNode){
	          process.emit('unhandledRejection', value, promise);
	        } else if(handler = global.onunhandledrejection){
	          handler({promise: promise, reason: value});
	        } else if((console = global.console) && console.error){
	          console.error('Unhandled promise rejection', value);
	        }
	      });
	      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
	      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
	    } promise._a = undefined;
	    if(abrupt)throw abrupt.error;
	  });
	};
	var isUnhandled = function(promise){
	  if(promise._h == 1)return false;
	  var chain = promise._a || promise._c
	    , i     = 0
	    , reaction;
	  while(chain.length > i){
	    reaction = chain[i++];
	    if(reaction.fail || !isUnhandled(reaction.promise))return false;
	  } return true;
	};
	var onHandleUnhandled = function(promise){
	  task.call(global, function(){
	    var handler;
	    if(isNode){
	      process.emit('rejectionHandled', promise);
	    } else if(handler = global.onrejectionhandled){
	      handler({promise: promise, reason: promise._v});
	    }
	  });
	};
	var $reject = function(value){
	  var promise = this;
	  if(promise._d)return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  promise._v = value;
	  promise._s = 2;
	  if(!promise._a)promise._a = promise._c.slice();
	  notify(promise, true);
	};
	var $resolve = function(value){
	  var promise = this
	    , then;
	  if(promise._d)return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  try {
	    if(promise === value)throw TypeError("Promise can't be resolved itself");
	    if(then = isThenable(value)){
	      microtask(function(){
	        var wrapper = {_w: promise, _d: false}; // wrap
	        try {
	          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
	        } catch(e){
	          $reject.call(wrapper, e);
	        }
	      });
	    } else {
	      promise._v = value;
	      promise._s = 1;
	      notify(promise, false);
	    }
	  } catch(e){
	    $reject.call({_w: promise, _d: false}, e); // wrap
	  }
	};
	
	// constructor polyfill
	if(!USE_NATIVE){
	  // 25.4.3.1 Promise(executor)
	  $Promise = function Promise(executor){
	    anInstance(this, $Promise, PROMISE, '_h');
	    aFunction(executor);
	    Internal.call(this);
	    try {
	      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
	    } catch(err){
	      $reject.call(this, err);
	    }
	  };
	  Internal = function Promise(executor){
	    this._c = [];             // <- awaiting reactions
	    this._a = undefined;      // <- checked in isUnhandled reactions
	    this._s = 0;              // <- state
	    this._d = false;          // <- done
	    this._v = undefined;      // <- value
	    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
	    this._n = false;          // <- notify
	  };
	  Internal.prototype = __webpack_require__(210)($Promise.prototype, {
	    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
	    then: function then(onFulfilled, onRejected){
	      var reaction    = newPromiseCapability(speciesConstructor(this, $Promise));
	      reaction.ok     = typeof onFulfilled == 'function' ? onFulfilled : true;
	      reaction.fail   = typeof onRejected == 'function' && onRejected;
	      reaction.domain = isNode ? process.domain : undefined;
	      this._c.push(reaction);
	      if(this._a)this._a.push(reaction);
	      if(this._s)notify(this, false);
	      return reaction.promise;
	    },
	    // 25.4.5.1 Promise.prototype.catch(onRejected)
	    'catch': function(onRejected){
	      return this.then(undefined, onRejected);
	    }
	  });
	  PromiseCapability = function(){
	    var promise  = new Internal;
	    this.promise = promise;
	    this.resolve = ctx($resolve, promise, 1);
	    this.reject  = ctx($reject, promise, 1);
	  };
	}
	
	$export($export.G + $export.W + $export.F * !USE_NATIVE, {Promise: $Promise});
	__webpack_require__(24)($Promise, PROMISE);
	__webpack_require__(193)(PROMISE);
	Wrapper = __webpack_require__(9)[PROMISE];
	
	// statics
	$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
	  // 25.4.4.5 Promise.reject(r)
	  reject: function reject(r){
	    var capability = newPromiseCapability(this)
	      , $$reject   = capability.reject;
	    $$reject(r);
	    return capability.promise;
	  }
	});
	$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
	  // 25.4.4.6 Promise.resolve(x)
	  resolve: function resolve(x){
	    // instanceof instead of internal slot check because we should fix it without replacement native Promise core
	    if(x instanceof $Promise && sameConstructor(x.constructor, this))return x;
	    var capability = newPromiseCapability(this)
	      , $$resolve  = capability.resolve;
	    $$resolve(x);
	    return capability.promise;
	  }
	});
	$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(166)(function(iter){
	  $Promise.all(iter)['catch'](empty);
	})), PROMISE, {
	  // 25.4.4.1 Promise.all(iterable)
	  all: function all(iterable){
	    var C          = this
	      , capability = newPromiseCapability(C)
	      , resolve    = capability.resolve
	      , reject     = capability.reject;
	    var abrupt = perform(function(){
	      var values    = []
	        , index     = 0
	        , remaining = 1;
	      forOf(iterable, false, function(promise){
	        var $index        = index++
	          , alreadyCalled = false;
	        values.push(undefined);
	        remaining++;
	        C.resolve(promise).then(function(value){
	          if(alreadyCalled)return;
	          alreadyCalled  = true;
	          values[$index] = value;
	          --remaining || resolve(values);
	        }, reject);
	      });
	      --remaining || resolve(values);
	    });
	    if(abrupt)reject(abrupt.error);
	    return capability.promise;
	  },
	  // 25.4.4.4 Promise.race(iterable)
	  race: function race(iterable){
	    var C          = this
	      , capability = newPromiseCapability(C)
	      , reject     = capability.reject;
	    var abrupt = perform(function(){
	      forOf(iterable, false, function(promise){
	        C.resolve(promise).then(capability.resolve, reject);
	      });
	    });
	    if(abrupt)reject(abrupt.error);
	    return capability.promise;
	  }
	});

/***/ },
/* 206 */
/***/ function(module, exports, __webpack_require__) {

	var ctx         = __webpack_require__(20)
	  , call        = __webpack_require__(162)
	  , isArrayIter = __webpack_require__(163)
	  , anObject    = __webpack_require__(12)
	  , toLength    = __webpack_require__(37)
	  , getIterFn   = __webpack_require__(165)
	  , BREAK       = {}
	  , RETURN      = {};
	var exports = module.exports = function(iterable, entries, fn, that, ITERATOR){
	  var iterFn = ITERATOR ? function(){ return iterable; } : getIterFn(iterable)
	    , f      = ctx(fn, that, entries ? 2 : 1)
	    , index  = 0
	    , length, step, iterator, result;
	  if(typeof iterFn != 'function')throw TypeError(iterable + ' is not iterable!');
	  // fast case for arrays with default iterator
	  if(isArrayIter(iterFn))for(length = toLength(iterable.length); length > index; index++){
	    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
	    if(result === BREAK || result === RETURN)return result;
	  } else for(iterator = iterFn.call(iterable); !(step = iterator.next()).done; ){
	    result = call(iterator, f, step.value, entries);
	    if(result === BREAK || result === RETURN)return result;
	  }
	};
	exports.BREAK  = BREAK;
	exports.RETURN = RETURN;

/***/ },
/* 207 */
/***/ function(module, exports, __webpack_require__) {

	// 7.3.20 SpeciesConstructor(O, defaultConstructor)
	var anObject  = __webpack_require__(12)
	  , aFunction = __webpack_require__(21)
	  , SPECIES   = __webpack_require__(25)('species');
	module.exports = function(O, D){
	  var C = anObject(O).constructor, S;
	  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
	};

/***/ },
/* 208 */
/***/ function(module, exports, __webpack_require__) {

	var ctx                = __webpack_require__(20)
	  , invoke             = __webpack_require__(78)
	  , html               = __webpack_require__(48)
	  , cel                = __webpack_require__(15)
	  , global             = __webpack_require__(4)
	  , process            = global.process
	  , setTask            = global.setImmediate
	  , clearTask          = global.clearImmediate
	  , MessageChannel     = global.MessageChannel
	  , counter            = 0
	  , queue              = {}
	  , ONREADYSTATECHANGE = 'onreadystatechange'
	  , defer, channel, port;
	var run = function(){
	  var id = +this;
	  if(queue.hasOwnProperty(id)){
	    var fn = queue[id];
	    delete queue[id];
	    fn();
	  }
	};
	var listener = function(event){
	  run.call(event.data);
	};
	// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
	if(!setTask || !clearTask){
	  setTask = function setImmediate(fn){
	    var args = [], i = 1;
	    while(arguments.length > i)args.push(arguments[i++]);
	    queue[++counter] = function(){
	      invoke(typeof fn == 'function' ? fn : Function(fn), args);
	    };
	    defer(counter);
	    return counter;
	  };
	  clearTask = function clearImmediate(id){
	    delete queue[id];
	  };
	  // Node.js 0.8-
	  if(__webpack_require__(34)(process) == 'process'){
	    defer = function(id){
	      process.nextTick(ctx(run, id, 1));
	    };
	  // Browsers with MessageChannel, includes WebWorkers
	  } else if(MessageChannel){
	    channel = new MessageChannel;
	    port    = channel.port2;
	    channel.port1.onmessage = listener;
	    defer = ctx(port.postMessage, port, 1);
	  // Browsers with postMessage, skip WebWorkers
	  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
	  } else if(global.addEventListener && typeof postMessage == 'function' && !global.importScripts){
	    defer = function(id){
	      global.postMessage(id + '', '*');
	    };
	    global.addEventListener('message', listener, false);
	  // IE8-
	  } else if(ONREADYSTATECHANGE in cel('script')){
	    defer = function(id){
	      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function(){
	        html.removeChild(this);
	        run.call(id);
	      };
	    };
	  // Rest old browsers
	  } else {
	    defer = function(id){
	      setTimeout(ctx(run, id, 1), 0);
	    };
	  }
	}
	module.exports = {
	  set:   setTask,
	  clear: clearTask
	};

/***/ },
/* 209 */
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(4)
	  , macrotask = __webpack_require__(208).set
	  , Observer  = global.MutationObserver || global.WebKitMutationObserver
	  , process   = global.process
	  , Promise   = global.Promise
	  , isNode    = __webpack_require__(34)(process) == 'process';
	
	module.exports = function(){
	  var head, last, notify;
	
	  var flush = function(){
	    var parent, fn;
	    if(isNode && (parent = process.domain))parent.exit();
	    while(head){
	      fn   = head.fn;
	      head = head.next;
	      try {
	        fn();
	      } catch(e){
	        if(head)notify();
	        else last = undefined;
	        throw e;
	      }
	    } last = undefined;
	    if(parent)parent.enter();
	  };
	
	  // Node.js
	  if(isNode){
	    notify = function(){
	      process.nextTick(flush);
	    };
	  // browsers with MutationObserver
	  } else if(Observer){
	    var toggle = true
	      , node   = document.createTextNode('');
	    new Observer(flush).observe(node, {characterData: true}); // eslint-disable-line no-new
	    notify = function(){
	      node.data = toggle = !toggle;
	    };
	  // environments with maybe non-completely correct, but existent Promise
	  } else if(Promise && Promise.resolve){
	    var promise = Promise.resolve();
	    notify = function(){
	      promise.then(flush);
	    };
	  // for other environments - macrotask based on:
	  // - setImmediate
	  // - MessageChannel
	  // - window.postMessag
	  // - onreadystatechange
	  // - setTimeout
	  } else {
	    notify = function(){
	      // strange IE + webpack dev server bug - use .call(global)
	      macrotask.call(global, flush);
	    };
	  }
	
	  return function(fn){
	    var task = {fn: fn, next: undefined};
	    if(last)last.next = task;
	    if(!head){
	      head = task;
	      notify();
	    } last = task;
	  };
	};

/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__) {

	var redefine = __webpack_require__(18);
	module.exports = function(target, src, safe){
	  for(var key in src)redefine(target, key, src[key], safe);
	  return target;
	};

/***/ },
/* 211 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var strong = __webpack_require__(212);
	
	// 23.1 Map Objects
	module.exports = __webpack_require__(213)('Map', function(get){
	  return function Map(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
	}, {
	  // 23.1.3.6 Map.prototype.get(key)
	  get: function get(key){
	    var entry = strong.getEntry(this, key);
	    return entry && entry.v;
	  },
	  // 23.1.3.9 Map.prototype.set(key, value)
	  set: function set(key, value){
	    return strong.def(this, key === 0 ? 0 : key, value);
	  }
	}, strong, true);

/***/ },
/* 212 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var dP          = __webpack_require__(11).f
	  , create      = __webpack_require__(46)
	  , hide        = __webpack_require__(10)
	  , redefineAll = __webpack_require__(210)
	  , ctx         = __webpack_require__(20)
	  , anInstance  = __webpack_require__(90)
	  , defined     = __webpack_require__(35)
	  , forOf       = __webpack_require__(206)
	  , $iterDefine = __webpack_require__(129)
	  , step        = __webpack_require__(195)
	  , setSpecies  = __webpack_require__(193)
	  , DESCRIPTORS = __webpack_require__(6)
	  , fastKey     = __webpack_require__(22).fastKey
	  , SIZE        = DESCRIPTORS ? '_s' : 'size';
	
	var getEntry = function(that, key){
	  // fast case
	  var index = fastKey(key), entry;
	  if(index !== 'F')return that._i[index];
	  // frozen object case
	  for(entry = that._f; entry; entry = entry.n){
	    if(entry.k == key)return entry;
	  }
	};
	
	module.exports = {
	  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
	    var C = wrapper(function(that, iterable){
	      anInstance(that, C, NAME, '_i');
	      that._i = create(null); // index
	      that._f = undefined;    // first entry
	      that._l = undefined;    // last entry
	      that[SIZE] = 0;         // size
	      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
	    });
	    redefineAll(C.prototype, {
	      // 23.1.3.1 Map.prototype.clear()
	      // 23.2.3.2 Set.prototype.clear()
	      clear: function clear(){
	        for(var that = this, data = that._i, entry = that._f; entry; entry = entry.n){
	          entry.r = true;
	          if(entry.p)entry.p = entry.p.n = undefined;
	          delete data[entry.i];
	        }
	        that._f = that._l = undefined;
	        that[SIZE] = 0;
	      },
	      // 23.1.3.3 Map.prototype.delete(key)
	      // 23.2.3.4 Set.prototype.delete(value)
	      'delete': function(key){
	        var that  = this
	          , entry = getEntry(that, key);
	        if(entry){
	          var next = entry.n
	            , prev = entry.p;
	          delete that._i[entry.i];
	          entry.r = true;
	          if(prev)prev.n = next;
	          if(next)next.p = prev;
	          if(that._f == entry)that._f = next;
	          if(that._l == entry)that._l = prev;
	          that[SIZE]--;
	        } return !!entry;
	      },
	      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
	      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
	      forEach: function forEach(callbackfn /*, that = undefined */){
	        anInstance(this, C, 'forEach');
	        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3)
	          , entry;
	        while(entry = entry ? entry.n : this._f){
	          f(entry.v, entry.k, this);
	          // revert to the last existing entry
	          while(entry && entry.r)entry = entry.p;
	        }
	      },
	      // 23.1.3.7 Map.prototype.has(key)
	      // 23.2.3.7 Set.prototype.has(value)
	      has: function has(key){
	        return !!getEntry(this, key);
	      }
	    });
	    if(DESCRIPTORS)dP(C.prototype, 'size', {
	      get: function(){
	        return defined(this[SIZE]);
	      }
	    });
	    return C;
	  },
	  def: function(that, key, value){
	    var entry = getEntry(that, key)
	      , prev, index;
	    // change existing entry
	    if(entry){
	      entry.v = value;
	    // create new entry
	    } else {
	      that._l = entry = {
	        i: index = fastKey(key, true), // <- index
	        k: key,                        // <- key
	        v: value,                      // <- value
	        p: prev = that._l,             // <- previous entry
	        n: undefined,                  // <- next entry
	        r: false                       // <- removed
	      };
	      if(!that._f)that._f = entry;
	      if(prev)prev.n = entry;
	      that[SIZE]++;
	      // add to index
	      if(index !== 'F')that._i[index] = entry;
	    } return that;
	  },
	  getEntry: getEntry,
	  setStrong: function(C, NAME, IS_MAP){
	    // add .keys, .values, .entries, [@@iterator]
	    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
	    $iterDefine(C, NAME, function(iterated, kind){
	      this._t = iterated;  // target
	      this._k = kind;      // kind
	      this._l = undefined; // previous
	    }, function(){
	      var that  = this
	        , kind  = that._k
	        , entry = that._l;
	      // revert to the last existing entry
	      while(entry && entry.r)entry = entry.p;
	      // get next entry
	      if(!that._t || !(that._l = entry = entry ? entry.n : that._t._f)){
	        // or finish the iteration
	        that._t = undefined;
	        return step(1);
	      }
	      // return step by kind
	      if(kind == 'keys'  )return step(0, entry.k);
	      if(kind == 'values')return step(0, entry.v);
	      return step(0, [entry.k, entry.v]);
	    }, IS_MAP ? 'entries' : 'values' , !IS_MAP, true);
	
	    // add [@@species], 23.1.2.2, 23.2.2.2
	    setSpecies(NAME);
	  }
	};

/***/ },
/* 213 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var global            = __webpack_require__(4)
	  , $export           = __webpack_require__(8)
	  , redefine          = __webpack_require__(18)
	  , redefineAll       = __webpack_require__(210)
	  , meta              = __webpack_require__(22)
	  , forOf             = __webpack_require__(206)
	  , anInstance        = __webpack_require__(90)
	  , isObject          = __webpack_require__(13)
	  , fails             = __webpack_require__(7)
	  , $iterDetect       = __webpack_require__(166)
	  , setToStringTag    = __webpack_require__(24)
	  , inheritIfRequired = __webpack_require__(88);
	
	module.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK){
	  var Base  = global[NAME]
	    , C     = Base
	    , ADDER = IS_MAP ? 'set' : 'add'
	    , proto = C && C.prototype
	    , O     = {};
	  var fixMethod = function(KEY){
	    var fn = proto[KEY];
	    redefine(proto, KEY,
	      KEY == 'delete' ? function(a){
	        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
	      } : KEY == 'has' ? function has(a){
	        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
	      } : KEY == 'get' ? function get(a){
	        return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
	      } : KEY == 'add' ? function add(a){ fn.call(this, a === 0 ? 0 : a); return this; }
	        : function set(a, b){ fn.call(this, a === 0 ? 0 : a, b); return this; }
	    );
	  };
	  if(typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function(){
	    new C().entries().next();
	  }))){
	    // create collection constructor
	    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
	    redefineAll(C.prototype, methods);
	    meta.NEED = true;
	  } else {
	    var instance             = new C
	      // early implementations not supports chaining
	      , HASNT_CHAINING       = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance
	      // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false
	      , THROWS_ON_PRIMITIVES = fails(function(){ instance.has(1); })
	      // most early implementations doesn't supports iterables, most modern - not close it correctly
	      , ACCEPT_ITERABLES     = $iterDetect(function(iter){ new C(iter); }) // eslint-disable-line no-new
	      // for early implementations -0 and +0 not the same
	      , BUGGY_ZERO = !IS_WEAK && fails(function(){
	        // V8 ~ Chromium 42- fails only with 5+ elements
	        var $instance = new C()
	          , index     = 5;
	        while(index--)$instance[ADDER](index, index);
	        return !$instance.has(-0);
	      });
	    if(!ACCEPT_ITERABLES){ 
	      C = wrapper(function(target, iterable){
	        anInstance(target, C, NAME);
	        var that = inheritIfRequired(new Base, target, C);
	        if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
	        return that;
	      });
	      C.prototype = proto;
	      proto.constructor = C;
	    }
	    if(THROWS_ON_PRIMITIVES || BUGGY_ZERO){
	      fixMethod('delete');
	      fixMethod('has');
	      IS_MAP && fixMethod('get');
	    }
	    if(BUGGY_ZERO || HASNT_CHAINING)fixMethod(ADDER);
	    // weak collections should not contains .clear method
	    if(IS_WEAK && proto.clear)delete proto.clear;
	  }
	
	  setToStringTag(C, NAME);
	
	  O[NAME] = C;
	  $export($export.G + $export.W + $export.F * (C != Base), O);
	
	  if(!IS_WEAK)common.setStrong(C, NAME, IS_MAP);
	
	  return C;
	};

/***/ },
/* 214 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var strong = __webpack_require__(212);
	
	// 23.2 Set Objects
	module.exports = __webpack_require__(213)('Set', function(get){
	  return function Set(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
	}, {
	  // 23.2.3.1 Set.prototype.add(value)
	  add: function add(value){
	    return strong.def(this, value = value === 0 ? 0 : value, value);
	  }
	}, strong);

/***/ },
/* 215 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var each         = __webpack_require__(173)(0)
	  , redefine     = __webpack_require__(18)
	  , meta         = __webpack_require__(22)
	  , assign       = __webpack_require__(69)
	  , weak         = __webpack_require__(216)
	  , isObject     = __webpack_require__(13)
	  , has          = __webpack_require__(5)
	  , getWeak      = meta.getWeak
	  , isExtensible = Object.isExtensible
	  , uncaughtFrozenStore = weak.ufstore
	  , tmp          = {}
	  , InternalMap;
	
	var wrapper = function(get){
	  return function WeakMap(){
	    return get(this, arguments.length > 0 ? arguments[0] : undefined);
	  };
	};
	
	var methods = {
	  // 23.3.3.3 WeakMap.prototype.get(key)
	  get: function get(key){
	    if(isObject(key)){
	      var data = getWeak(key);
	      if(data === true)return uncaughtFrozenStore(this).get(key);
	      return data ? data[this._i] : undefined;
	    }
	  },
	  // 23.3.3.5 WeakMap.prototype.set(key, value)
	  set: function set(key, value){
	    return weak.def(this, key, value);
	  }
	};
	
	// 23.3 WeakMap Objects
	var $WeakMap = module.exports = __webpack_require__(213)('WeakMap', wrapper, methods, weak, true, true);
	
	// IE11 WeakMap frozen keys fix
	if(new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7){
	  InternalMap = weak.getConstructor(wrapper);
	  assign(InternalMap.prototype, methods);
	  meta.NEED = true;
	  each(['delete', 'has', 'get', 'set'], function(key){
	    var proto  = $WeakMap.prototype
	      , method = proto[key];
	    redefine(proto, key, function(a, b){
	      // store frozen objects on internal weakmap shim
	      if(isObject(a) && !isExtensible(a)){
	        if(!this._f)this._f = new InternalMap;
	        var result = this._f[key](a, b);
	        return key == 'set' ? this : result;
	      // store all the rest on native weakmap
	      } return method.call(this, a, b);
	    });
	  });
	}

/***/ },
/* 216 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var redefineAll       = __webpack_require__(210)
	  , getWeak           = __webpack_require__(22).getWeak
	  , anObject          = __webpack_require__(12)
	  , isObject          = __webpack_require__(13)
	  , anInstance        = __webpack_require__(90)
	  , forOf             = __webpack_require__(206)
	  , createArrayMethod = __webpack_require__(173)
	  , $has              = __webpack_require__(5)
	  , arrayFind         = createArrayMethod(5)
	  , arrayFindIndex    = createArrayMethod(6)
	  , id                = 0;
	
	// fallback for uncaught frozen keys
	var uncaughtFrozenStore = function(that){
	  return that._l || (that._l = new UncaughtFrozenStore);
	};
	var UncaughtFrozenStore = function(){
	  this.a = [];
	};
	var findUncaughtFrozen = function(store, key){
	  return arrayFind(store.a, function(it){
	    return it[0] === key;
	  });
	};
	UncaughtFrozenStore.prototype = {
	  get: function(key){
	    var entry = findUncaughtFrozen(this, key);
	    if(entry)return entry[1];
	  },
	  has: function(key){
	    return !!findUncaughtFrozen(this, key);
	  },
	  set: function(key, value){
	    var entry = findUncaughtFrozen(this, key);
	    if(entry)entry[1] = value;
	    else this.a.push([key, value]);
	  },
	  'delete': function(key){
	    var index = arrayFindIndex(this.a, function(it){
	      return it[0] === key;
	    });
	    if(~index)this.a.splice(index, 1);
	    return !!~index;
	  }
	};
	
	module.exports = {
	  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
	    var C = wrapper(function(that, iterable){
	      anInstance(that, C, NAME, '_i');
	      that._i = id++;      // collection id
	      that._l = undefined; // leak store for uncaught frozen objects
	      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
	    });
	    redefineAll(C.prototype, {
	      // 23.3.3.2 WeakMap.prototype.delete(key)
	      // 23.4.3.3 WeakSet.prototype.delete(value)
	      'delete': function(key){
	        if(!isObject(key))return false;
	        var data = getWeak(key);
	        if(data === true)return uncaughtFrozenStore(this)['delete'](key);
	        return data && $has(data, this._i) && delete data[this._i];
	      },
	      // 23.3.3.4 WeakMap.prototype.has(key)
	      // 23.4.3.4 WeakSet.prototype.has(value)
	      has: function has(key){
	        if(!isObject(key))return false;
	        var data = getWeak(key);
	        if(data === true)return uncaughtFrozenStore(this).has(key);
	        return data && $has(data, this._i);
	      }
	    });
	    return C;
	  },
	  def: function(that, key, value){
	    var data = getWeak(anObject(key), true);
	    if(data === true)uncaughtFrozenStore(that).set(key, value);
	    else data[that._i] = value;
	    return that;
	  },
	  ufstore: uncaughtFrozenStore
	};

/***/ },
/* 217 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var weak = __webpack_require__(216);
	
	// 23.4 WeakSet Objects
	__webpack_require__(213)('WeakSet', function(get){
	  return function WeakSet(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
	}, {
	  // 23.4.3.1 WeakSet.prototype.add(value)
	  add: function add(value){
	    return weak.def(this, value, true);
	  }
	}, weak, false, true);

/***/ },
/* 218 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export      = __webpack_require__(8)
	  , $typed       = __webpack_require__(219)
	  , buffer       = __webpack_require__(220)
	  , anObject     = __webpack_require__(12)
	  , toIndex      = __webpack_require__(39)
	  , toLength     = __webpack_require__(37)
	  , isObject     = __webpack_require__(13)
	  , TYPED_ARRAY  = __webpack_require__(25)('typed_array')
	  , ArrayBuffer  = __webpack_require__(4).ArrayBuffer
	  , speciesConstructor = __webpack_require__(207)
	  , $ArrayBuffer = buffer.ArrayBuffer
	  , $DataView    = buffer.DataView
	  , $isView      = $typed.ABV && ArrayBuffer.isView
	  , $slice       = $ArrayBuffer.prototype.slice
	  , VIEW         = $typed.VIEW
	  , ARRAY_BUFFER = 'ArrayBuffer';
	
	$export($export.G + $export.W + $export.F * (ArrayBuffer !== $ArrayBuffer), {ArrayBuffer: $ArrayBuffer});
	
	$export($export.S + $export.F * !$typed.CONSTR, ARRAY_BUFFER, {
	  // 24.1.3.1 ArrayBuffer.isView(arg)
	  isView: function isView(it){
	    return $isView && $isView(it) || isObject(it) && VIEW in it;
	  }
	});
	
	$export($export.P + $export.U + $export.F * __webpack_require__(7)(function(){
	  return !new $ArrayBuffer(2).slice(1, undefined).byteLength;
	}), ARRAY_BUFFER, {
	  // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)
	  slice: function slice(start, end){
	    if($slice !== undefined && end === undefined)return $slice.call(anObject(this), start); // FF fix
	    var len    = anObject(this).byteLength
	      , first  = toIndex(start, len)
	      , final  = toIndex(end === undefined ? len : end, len)
	      , result = new (speciesConstructor(this, $ArrayBuffer))(toLength(final - first))
	      , viewS  = new $DataView(this)
	      , viewT  = new $DataView(result)
	      , index  = 0;
	    while(first < final){
	      viewT.setUint8(index++, viewS.getUint8(first++));
	    } return result;
	  }
	});
	
	__webpack_require__(193)(ARRAY_BUFFER);

/***/ },
/* 219 */
/***/ function(module, exports, __webpack_require__) {

	var global = __webpack_require__(4)
	  , hide   = __webpack_require__(10)
	  , uid    = __webpack_require__(19)
	  , TYPED  = uid('typed_array')
	  , VIEW   = uid('view')
	  , ABV    = !!(global.ArrayBuffer && global.DataView)
	  , CONSTR = ABV
	  , i = 0, l = 9, Typed;
	
	var TypedArrayConstructors = (
	  'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'
	).split(',');
	
	while(i < l){
	  if(Typed = global[TypedArrayConstructors[i++]]){
	    hide(Typed.prototype, TYPED, true);
	    hide(Typed.prototype, VIEW, true);
	  } else CONSTR = false;
	}
	
	module.exports = {
	  ABV:    ABV,
	  CONSTR: CONSTR,
	  TYPED:  TYPED,
	  VIEW:   VIEW
	};

/***/ },
/* 220 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var global         = __webpack_require__(4)
	  , DESCRIPTORS    = __webpack_require__(6)
	  , LIBRARY        = __webpack_require__(28)
	  , $typed         = __webpack_require__(219)
	  , hide           = __webpack_require__(10)
	  , redefineAll    = __webpack_require__(210)
	  , fails          = __webpack_require__(7)
	  , anInstance     = __webpack_require__(90)
	  , toInteger      = __webpack_require__(38)
	  , toLength       = __webpack_require__(37)
	  , gOPN           = __webpack_require__(50).f
	  , dP             = __webpack_require__(11).f
	  , arrayFill      = __webpack_require__(189)
	  , setToStringTag = __webpack_require__(24)
	  , ARRAY_BUFFER   = 'ArrayBuffer'
	  , DATA_VIEW      = 'DataView'
	  , PROTOTYPE      = 'prototype'
	  , WRONG_LENGTH   = 'Wrong length!'
	  , WRONG_INDEX    = 'Wrong index!'
	  , $ArrayBuffer   = global[ARRAY_BUFFER]
	  , $DataView      = global[DATA_VIEW]
	  , Math           = global.Math
	  , parseInt       = global.parseInt
	  , RangeError     = global.RangeError
	  , Infinity       = global.Infinity
	  , BaseBuffer     = $ArrayBuffer
	  , abs            = Math.abs
	  , pow            = Math.pow
	  , min            = Math.min
	  , floor          = Math.floor
	  , log            = Math.log
	  , LN2            = Math.LN2
	  , BUFFER         = 'buffer'
	  , BYTE_LENGTH    = 'byteLength'
	  , BYTE_OFFSET    = 'byteOffset'
	  , $BUFFER        = DESCRIPTORS ? '_b' : BUFFER
	  , $LENGTH        = DESCRIPTORS ? '_l' : BYTE_LENGTH
	  , $OFFSET        = DESCRIPTORS ? '_o' : BYTE_OFFSET;
	
	// IEEE754 conversions based on https://github.com/feross/ieee754
	var packIEEE754 = function(value, mLen, nBytes){
	  var buffer = Array(nBytes)
	    , eLen   = nBytes * 8 - mLen - 1
	    , eMax   = (1 << eLen) - 1
	    , eBias  = eMax >> 1
	    , rt     = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0
	    , i      = 0
	    , s      = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0
	    , e, m, c;
	  value = abs(value)
	  if(value != value || value === Infinity){
	    m = value != value ? 1 : 0;
	    e = eMax;
	  } else {
	    e = floor(log(value) / LN2);
	    if(value * (c = pow(2, -e)) < 1){
	      e--;
	      c *= 2;
	    }
	    if(e + eBias >= 1){
	      value += rt / c;
	    } else {
	      value += rt * pow(2, 1 - eBias);
	    }
	    if(value * c >= 2){
	      e++;
	      c /= 2;
	    }
	    if(e + eBias >= eMax){
	      m = 0;
	      e = eMax;
	    } else if(e + eBias >= 1){
	      m = (value * c - 1) * pow(2, mLen);
	      e = e + eBias;
	    } else {
	      m = value * pow(2, eBias - 1) * pow(2, mLen);
	      e = 0;
	    }
	  }
	  for(; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);
	  e = e << mLen | m;
	  eLen += mLen;
	  for(; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);
	  buffer[--i] |= s * 128;
	  return buffer;
	};
	var unpackIEEE754 = function(buffer, mLen, nBytes){
	  var eLen  = nBytes * 8 - mLen - 1
	    , eMax  = (1 << eLen) - 1
	    , eBias = eMax >> 1
	    , nBits = eLen - 7
	    , i     = nBytes - 1
	    , s     = buffer[i--]
	    , e     = s & 127
	    , m;
	  s >>= 7;
	  for(; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);
	  m = e & (1 << -nBits) - 1;
	  e >>= -nBits;
	  nBits += mLen;
	  for(; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);
	  if(e === 0){
	    e = 1 - eBias;
	  } else if(e === eMax){
	    return m ? NaN : s ? -Infinity : Infinity;
	  } else {
	    m = m + pow(2, mLen);
	    e = e - eBias;
	  } return (s ? -1 : 1) * m * pow(2, e - mLen);
	};
	
	var unpackI32 = function(bytes){
	  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
	};
	var packI8 = function(it){
	  return [it & 0xff];
	};
	var packI16 = function(it){
	  return [it & 0xff, it >> 8 & 0xff];
	};
	var packI32 = function(it){
	  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
	};
	var packF64 = function(it){
	  return packIEEE754(it, 52, 8);
	};
	var packF32 = function(it){
	  return packIEEE754(it, 23, 4);
	};
	
	var addGetter = function(C, key, internal){
	  dP(C[PROTOTYPE], key, {get: function(){ return this[internal]; }});
	};
	
	var get = function(view, bytes, index, isLittleEndian){
	  var numIndex = +index
	    , intIndex = toInteger(numIndex);
	  if(numIndex != intIndex || intIndex < 0 || intIndex + bytes > view[$LENGTH])throw RangeError(WRONG_INDEX);
	  var store = view[$BUFFER]._b
	    , start = intIndex + view[$OFFSET]
	    , pack  = store.slice(start, start + bytes);
	  return isLittleEndian ? pack : pack.reverse();
	};
	var set = function(view, bytes, index, conversion, value, isLittleEndian){
	  var numIndex = +index
	    , intIndex = toInteger(numIndex);
	  if(numIndex != intIndex || intIndex < 0 || intIndex + bytes > view[$LENGTH])throw RangeError(WRONG_INDEX);
	  var store = view[$BUFFER]._b
	    , start = intIndex + view[$OFFSET]
	    , pack  = conversion(+value);
	  for(var i = 0; i < bytes; i++)store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
	};
	
	var validateArrayBufferArguments = function(that, length){
	  anInstance(that, $ArrayBuffer, ARRAY_BUFFER);
	  var numberLength = +length
	    , byteLength   = toLength(numberLength);
	  if(numberLength != byteLength)throw RangeError(WRONG_LENGTH);
	  return byteLength;
	};
	
	if(!$typed.ABV){
	  $ArrayBuffer = function ArrayBuffer(length){
	    var byteLength = validateArrayBufferArguments(this, length);
	    this._b       = arrayFill.call(Array(byteLength), 0);
	    this[$LENGTH] = byteLength;
	  };
	
	  $DataView = function DataView(buffer, byteOffset, byteLength){
	    anInstance(this, $DataView, DATA_VIEW);
	    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
	    var bufferLength = buffer[$LENGTH]
	      , offset       = toInteger(byteOffset);
	    if(offset < 0 || offset > bufferLength)throw RangeError('Wrong offset!');
	    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
	    if(offset + byteLength > bufferLength)throw RangeError(WRONG_LENGTH);
	    this[$BUFFER] = buffer;
	    this[$OFFSET] = offset;
	    this[$LENGTH] = byteLength;
	  };
	
	  if(DESCRIPTORS){
	    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
	    addGetter($DataView, BUFFER, '_b');
	    addGetter($DataView, BYTE_LENGTH, '_l');
	    addGetter($DataView, BYTE_OFFSET, '_o');
	  }
	
	  redefineAll($DataView[PROTOTYPE], {
	    getInt8: function getInt8(byteOffset){
	      return get(this, 1, byteOffset)[0] << 24 >> 24;
	    },
	    getUint8: function getUint8(byteOffset){
	      return get(this, 1, byteOffset)[0];
	    },
	    getInt16: function getInt16(byteOffset /*, littleEndian */){
	      var bytes = get(this, 2, byteOffset, arguments[1]);
	      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
	    },
	    getUint16: function getUint16(byteOffset /*, littleEndian */){
	      var bytes = get(this, 2, byteOffset, arguments[1]);
	      return bytes[1] << 8 | bytes[0];
	    },
	    getInt32: function getInt32(byteOffset /*, littleEndian */){
	      return unpackI32(get(this, 4, byteOffset, arguments[1]));
	    },
	    getUint32: function getUint32(byteOffset /*, littleEndian */){
	      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
	    },
	    getFloat32: function getFloat32(byteOffset /*, littleEndian */){
	      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
	    },
	    getFloat64: function getFloat64(byteOffset /*, littleEndian */){
	      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
	    },
	    setInt8: function setInt8(byteOffset, value){
	      set(this, 1, byteOffset, packI8, value);
	    },
	    setUint8: function setUint8(byteOffset, value){
	      set(this, 1, byteOffset, packI8, value);
	    },
	    setInt16: function setInt16(byteOffset, value /*, littleEndian */){
	      set(this, 2, byteOffset, packI16, value, arguments[2]);
	    },
	    setUint16: function setUint16(byteOffset, value /*, littleEndian */){
	      set(this, 2, byteOffset, packI16, value, arguments[2]);
	    },
	    setInt32: function setInt32(byteOffset, value /*, littleEndian */){
	      set(this, 4, byteOffset, packI32, value, arguments[2]);
	    },
	    setUint32: function setUint32(byteOffset, value /*, littleEndian */){
	      set(this, 4, byteOffset, packI32, value, arguments[2]);
	    },
	    setFloat32: function setFloat32(byteOffset, value /*, littleEndian */){
	      set(this, 4, byteOffset, packF32, value, arguments[2]);
	    },
	    setFloat64: function setFloat64(byteOffset, value /*, littleEndian */){
	      set(this, 8, byteOffset, packF64, value, arguments[2]);
	    }
	  });
	} else {
	  if(!fails(function(){
	    new $ArrayBuffer;     // eslint-disable-line no-new
	  }) || !fails(function(){
	    new $ArrayBuffer(.5); // eslint-disable-line no-new
	  })){
	    $ArrayBuffer = function ArrayBuffer(length){
	      return new BaseBuffer(validateArrayBufferArguments(this, length));
	    };
	    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];
	    for(var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j; ){
	      if(!((key = keys[j++]) in $ArrayBuffer))hide($ArrayBuffer, key, BaseBuffer[key]);
	    };
	    if(!LIBRARY)ArrayBufferProto.constructor = $ArrayBuffer;
	  }
	  // iOS Safari 7.x bug
	  var view = new $DataView(new $ArrayBuffer(2))
	    , $setInt8 = $DataView[PROTOTYPE].setInt8;
	  view.setInt8(0, 2147483648);
	  view.setInt8(1, 2147483649);
	  if(view.getInt8(0) || !view.getInt8(1))redefineAll($DataView[PROTOTYPE], {
	    setInt8: function setInt8(byteOffset, value){
	      $setInt8.call(this, byteOffset, value << 24 >> 24);
	    },
	    setUint8: function setUint8(byteOffset, value){
	      $setInt8.call(this, byteOffset, value << 24 >> 24);
	    }
	  }, true);
	}
	setToStringTag($ArrayBuffer, ARRAY_BUFFER);
	setToStringTag($DataView, DATA_VIEW);
	hide($DataView[PROTOTYPE], $typed.VIEW, true);
	exports[ARRAY_BUFFER] = $ArrayBuffer;
	exports[DATA_VIEW] = $DataView;

/***/ },
/* 221 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(8);
	$export($export.G + $export.W + $export.F * !__webpack_require__(219).ABV, {
	  DataView: __webpack_require__(220).DataView
	});

/***/ },
/* 222 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(223)('Int8', 1, function(init){
	  return function Int8Array(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ },
/* 223 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	if(__webpack_require__(6)){
	  var LIBRARY             = __webpack_require__(28)
	    , global              = __webpack_require__(4)
	    , fails               = __webpack_require__(7)
	    , $export             = __webpack_require__(8)
	    , $typed              = __webpack_require__(219)
	    , $buffer             = __webpack_require__(220)
	    , ctx                 = __webpack_require__(20)
	    , anInstance          = __webpack_require__(90)
	    , propertyDesc        = __webpack_require__(17)
	    , hide                = __webpack_require__(10)
	    , redefineAll         = __webpack_require__(210)
	    , isInteger           = __webpack_require__(97)
	    , toInteger           = __webpack_require__(38)
	    , toLength            = __webpack_require__(37)
	    , toIndex             = __webpack_require__(39)
	    , toPrimitive         = __webpack_require__(16)
	    , has                 = __webpack_require__(5)
	    , same                = __webpack_require__(71)
	    , classof             = __webpack_require__(75)
	    , isObject            = __webpack_require__(13)
	    , toObject            = __webpack_require__(58)
	    , isArrayIter         = __webpack_require__(163)
	    , create              = __webpack_require__(46)
	    , getPrototypeOf      = __webpack_require__(59)
	    , gOPN                = __webpack_require__(50).f
	    , isIterable          = __webpack_require__(224)
	    , getIterFn           = __webpack_require__(165)
	    , uid                 = __webpack_require__(19)
	    , wks                 = __webpack_require__(25)
	    , createArrayMethod   = __webpack_require__(173)
	    , createArrayIncludes = __webpack_require__(36)
	    , speciesConstructor  = __webpack_require__(207)
	    , ArrayIterators      = __webpack_require__(194)
	    , Iterators           = __webpack_require__(130)
	    , $iterDetect         = __webpack_require__(166)
	    , setSpecies          = __webpack_require__(193)
	    , arrayFill           = __webpack_require__(189)
	    , arrayCopyWithin     = __webpack_require__(186)
	    , $DP                 = __webpack_require__(11)
	    , $GOPD               = __webpack_require__(51)
	    , dP                  = $DP.f
	    , gOPD                = $GOPD.f
	    , RangeError          = global.RangeError
	    , TypeError           = global.TypeError
	    , Uint8Array          = global.Uint8Array
	    , ARRAY_BUFFER        = 'ArrayBuffer'
	    , SHARED_BUFFER       = 'Shared' + ARRAY_BUFFER
	    , BYTES_PER_ELEMENT   = 'BYTES_PER_ELEMENT'
	    , PROTOTYPE           = 'prototype'
	    , ArrayProto          = Array[PROTOTYPE]
	    , $ArrayBuffer        = $buffer.ArrayBuffer
	    , $DataView           = $buffer.DataView
	    , arrayForEach        = createArrayMethod(0)
	    , arrayFilter         = createArrayMethod(2)
	    , arraySome           = createArrayMethod(3)
	    , arrayEvery          = createArrayMethod(4)
	    , arrayFind           = createArrayMethod(5)
	    , arrayFindIndex      = createArrayMethod(6)
	    , arrayIncludes       = createArrayIncludes(true)
	    , arrayIndexOf        = createArrayIncludes(false)
	    , arrayValues         = ArrayIterators.values
	    , arrayKeys           = ArrayIterators.keys
	    , arrayEntries        = ArrayIterators.entries
	    , arrayLastIndexOf    = ArrayProto.lastIndexOf
	    , arrayReduce         = ArrayProto.reduce
	    , arrayReduceRight    = ArrayProto.reduceRight
	    , arrayJoin           = ArrayProto.join
	    , arraySort           = ArrayProto.sort
	    , arraySlice          = ArrayProto.slice
	    , arrayToString       = ArrayProto.toString
	    , arrayToLocaleString = ArrayProto.toLocaleString
	    , ITERATOR            = wks('iterator')
	    , TAG                 = wks('toStringTag')
	    , TYPED_CONSTRUCTOR   = uid('typed_constructor')
	    , DEF_CONSTRUCTOR     = uid('def_constructor')
	    , ALL_CONSTRUCTORS    = $typed.CONSTR
	    , TYPED_ARRAY         = $typed.TYPED
	    , VIEW                = $typed.VIEW
	    , WRONG_LENGTH        = 'Wrong length!';
	
	  var $map = createArrayMethod(1, function(O, length){
	    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
	  });
	
	  var LITTLE_ENDIAN = fails(function(){
	    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
	  });
	
	  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function(){
	    new Uint8Array(1).set({});
	  });
	
	  var strictToLength = function(it, SAME){
	    if(it === undefined)throw TypeError(WRONG_LENGTH);
	    var number = +it
	      , length = toLength(it);
	    if(SAME && !same(number, length))throw RangeError(WRONG_LENGTH);
	    return length;
	  };
	
	  var toOffset = function(it, BYTES){
	    var offset = toInteger(it);
	    if(offset < 0 || offset % BYTES)throw RangeError('Wrong offset!');
	    return offset;
	  };
	
	  var validate = function(it){
	    if(isObject(it) && TYPED_ARRAY in it)return it;
	    throw TypeError(it + ' is not a typed array!');
	  };
	
	  var allocate = function(C, length){
	    if(!(isObject(C) && TYPED_CONSTRUCTOR in C)){
	      throw TypeError('It is not a typed array constructor!');
	    } return new C(length);
	  };
	
	  var speciesFromList = function(O, list){
	    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
	  };
	
	  var fromList = function(C, list){
	    var index  = 0
	      , length = list.length
	      , result = allocate(C, length);
	    while(length > index)result[index] = list[index++];
	    return result;
	  };
	
	  var addGetter = function(it, key, internal){
	    dP(it, key, {get: function(){ return this._d[internal]; }});
	  };
	
	  var $from = function from(source /*, mapfn, thisArg */){
	    var O       = toObject(source)
	      , aLen    = arguments.length
	      , mapfn   = aLen > 1 ? arguments[1] : undefined
	      , mapping = mapfn !== undefined
	      , iterFn  = getIterFn(O)
	      , i, length, values, result, step, iterator;
	    if(iterFn != undefined && !isArrayIter(iterFn)){
	      for(iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++){
	        values.push(step.value);
	      } O = values;
	    }
	    if(mapping && aLen > 2)mapfn = ctx(mapfn, arguments[2], 2);
	    for(i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++){
	      result[i] = mapping ? mapfn(O[i], i) : O[i];
	    }
	    return result;
	  };
	
	  var $of = function of(/*...items*/){
	    var index  = 0
	      , length = arguments.length
	      , result = allocate(this, length);
	    while(length > index)result[index] = arguments[index++];
	    return result;
	  };
	
	  // iOS Safari 6.x fails here
	  var TO_LOCALE_BUG = !!Uint8Array && fails(function(){ arrayToLocaleString.call(new Uint8Array(1)); });
	
	  var $toLocaleString = function toLocaleString(){
	    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
	  };
	
	  var proto = {
	    copyWithin: function copyWithin(target, start /*, end */){
	      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
	    },
	    every: function every(callbackfn /*, thisArg */){
	      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    fill: function fill(value /*, start, end */){ // eslint-disable-line no-unused-vars
	      return arrayFill.apply(validate(this), arguments);
	    },
	    filter: function filter(callbackfn /*, thisArg */){
	      return speciesFromList(this, arrayFilter(validate(this), callbackfn,
	        arguments.length > 1 ? arguments[1] : undefined));
	    },
	    find: function find(predicate /*, thisArg */){
	      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    findIndex: function findIndex(predicate /*, thisArg */){
	      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    forEach: function forEach(callbackfn /*, thisArg */){
	      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    indexOf: function indexOf(searchElement /*, fromIndex */){
	      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    includes: function includes(searchElement /*, fromIndex */){
	      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    join: function join(separator){ // eslint-disable-line no-unused-vars
	      return arrayJoin.apply(validate(this), arguments);
	    },
	    lastIndexOf: function lastIndexOf(searchElement /*, fromIndex */){ // eslint-disable-line no-unused-vars
	      return arrayLastIndexOf.apply(validate(this), arguments);
	    },
	    map: function map(mapfn /*, thisArg */){
	      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    reduce: function reduce(callbackfn /*, initialValue */){ // eslint-disable-line no-unused-vars
	      return arrayReduce.apply(validate(this), arguments);
	    },
	    reduceRight: function reduceRight(callbackfn /*, initialValue */){ // eslint-disable-line no-unused-vars
	      return arrayReduceRight.apply(validate(this), arguments);
	    },
	    reverse: function reverse(){
	      var that   = this
	        , length = validate(that).length
	        , middle = Math.floor(length / 2)
	        , index  = 0
	        , value;
	      while(index < middle){
	        value         = that[index];
	        that[index++] = that[--length];
	        that[length]  = value;
	      } return that;
	    },
	    some: function some(callbackfn /*, thisArg */){
	      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    sort: function sort(comparefn){
	      return arraySort.call(validate(this), comparefn);
	    },
	    subarray: function subarray(begin, end){
	      var O      = validate(this)
	        , length = O.length
	        , $begin = toIndex(begin, length);
	      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(
	        O.buffer,
	        O.byteOffset + $begin * O.BYTES_PER_ELEMENT,
	        toLength((end === undefined ? length : toIndex(end, length)) - $begin)
	      );
	    }
	  };
	
	  var $slice = function slice(start, end){
	    return speciesFromList(this, arraySlice.call(validate(this), start, end));
	  };
	
	  var $set = function set(arrayLike /*, offset */){
	    validate(this);
	    var offset = toOffset(arguments[1], 1)
	      , length = this.length
	      , src    = toObject(arrayLike)
	      , len    = toLength(src.length)
	      , index  = 0;
	    if(len + offset > length)throw RangeError(WRONG_LENGTH);
	    while(index < len)this[offset + index] = src[index++];
	  };
	
	  var $iterators = {
	    entries: function entries(){
	      return arrayEntries.call(validate(this));
	    },
	    keys: function keys(){
	      return arrayKeys.call(validate(this));
	    },
	    values: function values(){
	      return arrayValues.call(validate(this));
	    }
	  };
	
	  var isTAIndex = function(target, key){
	    return isObject(target)
	      && target[TYPED_ARRAY]
	      && typeof key != 'symbol'
	      && key in target
	      && String(+key) == String(key);
	  };
	  var $getDesc = function getOwnPropertyDescriptor(target, key){
	    return isTAIndex(target, key = toPrimitive(key, true))
	      ? propertyDesc(2, target[key])
	      : gOPD(target, key);
	  };
	  var $setDesc = function defineProperty(target, key, desc){
	    if(isTAIndex(target, key = toPrimitive(key, true))
	      && isObject(desc)
	      && has(desc, 'value')
	      && !has(desc, 'get')
	      && !has(desc, 'set')
	      // TODO: add validation descriptor w/o calling accessors
	      && !desc.configurable
	      && (!has(desc, 'writable') || desc.writable)
	      && (!has(desc, 'enumerable') || desc.enumerable)
	    ){
	      target[key] = desc.value;
	      return target;
	    } else return dP(target, key, desc);
	  };
	
	  if(!ALL_CONSTRUCTORS){
	    $GOPD.f = $getDesc;
	    $DP.f   = $setDesc;
	  }
	
	  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
	    getOwnPropertyDescriptor: $getDesc,
	    defineProperty:           $setDesc
	  });
	
	  if(fails(function(){ arrayToString.call({}); })){
	    arrayToString = arrayToLocaleString = function toString(){
	      return arrayJoin.call(this);
	    }
	  }
	
	  var $TypedArrayPrototype$ = redefineAll({}, proto);
	  redefineAll($TypedArrayPrototype$, $iterators);
	  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
	  redefineAll($TypedArrayPrototype$, {
	    slice:          $slice,
	    set:            $set,
	    constructor:    function(){ /* noop */ },
	    toString:       arrayToString,
	    toLocaleString: $toLocaleString
	  });
	  addGetter($TypedArrayPrototype$, 'buffer', 'b');
	  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
	  addGetter($TypedArrayPrototype$, 'byteLength', 'l');
	  addGetter($TypedArrayPrototype$, 'length', 'e');
	  dP($TypedArrayPrototype$, TAG, {
	    get: function(){ return this[TYPED_ARRAY]; }
	  });
	
	  module.exports = function(KEY, BYTES, wrapper, CLAMPED){
	    CLAMPED = !!CLAMPED;
	    var NAME       = KEY + (CLAMPED ? 'Clamped' : '') + 'Array'
	      , ISNT_UINT8 = NAME != 'Uint8Array'
	      , GETTER     = 'get' + KEY
	      , SETTER     = 'set' + KEY
	      , TypedArray = global[NAME]
	      , Base       = TypedArray || {}
	      , TAC        = TypedArray && getPrototypeOf(TypedArray)
	      , FORCED     = !TypedArray || !$typed.ABV
	      , O          = {}
	      , TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];
	    var getter = function(that, index){
	      var data = that._d;
	      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
	    };
	    var setter = function(that, index, value){
	      var data = that._d;
	      if(CLAMPED)value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
	      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
	    };
	    var addElement = function(that, index){
	      dP(that, index, {
	        get: function(){
	          return getter(this, index);
	        },
	        set: function(value){
	          return setter(this, index, value);
	        },
	        enumerable: true
	      });
	    };
	    if(FORCED){
	      TypedArray = wrapper(function(that, data, $offset, $length){
	        anInstance(that, TypedArray, NAME, '_d');
	        var index  = 0
	          , offset = 0
	          , buffer, byteLength, length, klass;
	        if(!isObject(data)){
	          length     = strictToLength(data, true)
	          byteLength = length * BYTES;
	          buffer     = new $ArrayBuffer(byteLength);
	        } else if(data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER){
	          buffer = data;
	          offset = toOffset($offset, BYTES);
	          var $len = data.byteLength;
	          if($length === undefined){
	            if($len % BYTES)throw RangeError(WRONG_LENGTH);
	            byteLength = $len - offset;
	            if(byteLength < 0)throw RangeError(WRONG_LENGTH);
	          } else {
	            byteLength = toLength($length) * BYTES;
	            if(byteLength + offset > $len)throw RangeError(WRONG_LENGTH);
	          }
	          length = byteLength / BYTES;
	        } else if(TYPED_ARRAY in data){
	          return fromList(TypedArray, data);
	        } else {
	          return $from.call(TypedArray, data);
	        }
	        hide(that, '_d', {
	          b: buffer,
	          o: offset,
	          l: byteLength,
	          e: length,
	          v: new $DataView(buffer)
	        });
	        while(index < length)addElement(that, index++);
	      });
	      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
	      hide(TypedArrayPrototype, 'constructor', TypedArray);
	    } else if(!$iterDetect(function(iter){
	      // V8 works with iterators, but fails in many other cases
	      // https://code.google.com/p/v8/issues/detail?id=4552
	      new TypedArray(null); // eslint-disable-line no-new
	      new TypedArray(iter); // eslint-disable-line no-new
	    }, true)){
	      TypedArray = wrapper(function(that, data, $offset, $length){
	        anInstance(that, TypedArray, NAME);
	        var klass;
	        // `ws` module bug, temporarily remove validation length for Uint8Array
	        // https://github.com/websockets/ws/pull/645
	        if(!isObject(data))return new Base(strictToLength(data, ISNT_UINT8));
	        if(data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER){
	          return $length !== undefined
	            ? new Base(data, toOffset($offset, BYTES), $length)
	            : $offset !== undefined
	              ? new Base(data, toOffset($offset, BYTES))
	              : new Base(data);
	        }
	        if(TYPED_ARRAY in data)return fromList(TypedArray, data);
	        return $from.call(TypedArray, data);
	      });
	      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function(key){
	        if(!(key in TypedArray))hide(TypedArray, key, Base[key]);
	      });
	      TypedArray[PROTOTYPE] = TypedArrayPrototype;
	      if(!LIBRARY)TypedArrayPrototype.constructor = TypedArray;
	    }
	    var $nativeIterator   = TypedArrayPrototype[ITERATOR]
	      , CORRECT_ITER_NAME = !!$nativeIterator && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined)
	      , $iterator         = $iterators.values;
	    hide(TypedArray, TYPED_CONSTRUCTOR, true);
	    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
	    hide(TypedArrayPrototype, VIEW, true);
	    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);
	
	    if(CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)){
	      dP(TypedArrayPrototype, TAG, {
	        get: function(){ return NAME; }
	      });
	    }
	
	    O[NAME] = TypedArray;
	
	    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);
	
	    $export($export.S, NAME, {
	      BYTES_PER_ELEMENT: BYTES,
	      from: $from,
	      of: $of
	    });
	
	    if(!(BYTES_PER_ELEMENT in TypedArrayPrototype))hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);
	
	    $export($export.P, NAME, proto);
	
	    setSpecies(NAME);
	
	    $export($export.P + $export.F * FORCED_SET, NAME, {set: $set});
	
	    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);
	
	    $export($export.P + $export.F * (TypedArrayPrototype.toString != arrayToString), NAME, {toString: arrayToString});
	
	    $export($export.P + $export.F * fails(function(){
	      new TypedArray(1).slice();
	    }), NAME, {slice: $slice});
	
	    $export($export.P + $export.F * (fails(function(){
	      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString()
	    }) || !fails(function(){
	      TypedArrayPrototype.toLocaleString.call([1, 2]);
	    })), NAME, {toLocaleString: $toLocaleString});
	
	    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
	    if(!LIBRARY && !CORRECT_ITER_NAME)hide(TypedArrayPrototype, ITERATOR, $iterator);
	  };
	} else module.exports = function(){ /* empty */ };

/***/ },
/* 224 */
/***/ function(module, exports, __webpack_require__) {

	var classof   = __webpack_require__(75)
	  , ITERATOR  = __webpack_require__(25)('iterator')
	  , Iterators = __webpack_require__(130);
	module.exports = __webpack_require__(9).isIterable = function(it){
	  var O = Object(it);
	  return O[ITERATOR] !== undefined
	    || '@@iterator' in O
	    || Iterators.hasOwnProperty(classof(O));
	};

/***/ },
/* 225 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(223)('Uint8', 1, function(init){
	  return function Uint8Array(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ },
/* 226 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(223)('Uint8', 1, function(init){
	  return function Uint8ClampedArray(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	}, true);

/***/ },
/* 227 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(223)('Int16', 2, function(init){
	  return function Int16Array(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ },
/* 228 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(223)('Uint16', 2, function(init){
	  return function Uint16Array(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ },
/* 229 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(223)('Int32', 4, function(init){
	  return function Int32Array(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ },
/* 230 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(223)('Uint32', 4, function(init){
	  return function Uint32Array(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ },
/* 231 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(223)('Float32', 4, function(init){
	  return function Float32Array(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ },
/* 232 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(223)('Float64', 8, function(init){
	  return function Float64Array(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ },
/* 233 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
	var $export   = __webpack_require__(8)
	  , aFunction = __webpack_require__(21)
	  , anObject  = __webpack_require__(12)
	  , _apply    = Function.apply;
	
	$export($export.S, 'Reflect', {
	  apply: function apply(target, thisArgument, argumentsList){
	    return _apply.call(aFunction(target), thisArgument, anObject(argumentsList));
	  }
	});

/***/ },
/* 234 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
	var $export   = __webpack_require__(8)
	  , create    = __webpack_require__(46)
	  , aFunction = __webpack_require__(21)
	  , anObject  = __webpack_require__(12)
	  , isObject  = __webpack_require__(13)
	  , bind      = __webpack_require__(77);
	
	// MS Edge supports only 2 arguments
	// FF Nightly sets third argument as `new.target`, but does not create `this` from it
	$export($export.S + $export.F * __webpack_require__(7)(function(){
	  function F(){}
	  return !(Reflect.construct(function(){}, [], F) instanceof F);
	}), 'Reflect', {
	  construct: function construct(Target, args /*, newTarget*/){
	    aFunction(Target);
	    anObject(args);
	    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
	    if(Target == newTarget){
	      // w/o altered newTarget, optimization for 0-4 arguments
	      switch(args.length){
	        case 0: return new Target;
	        case 1: return new Target(args[0]);
	        case 2: return new Target(args[0], args[1]);
	        case 3: return new Target(args[0], args[1], args[2]);
	        case 4: return new Target(args[0], args[1], args[2], args[3]);
	      }
	      // w/o altered newTarget, lot of arguments case
	      var $args = [null];
	      $args.push.apply($args, args);
	      return new (bind.apply(Target, $args));
	    }
	    // with altered newTarget, not support built-in constructors
	    var proto    = newTarget.prototype
	      , instance = create(isObject(proto) ? proto : Object.prototype)
	      , result   = Function.apply.call(Target, instance, args);
	    return isObject(result) ? result : instance;
	  }
	});

/***/ },
/* 235 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
	var dP          = __webpack_require__(11)
	  , $export     = __webpack_require__(8)
	  , anObject    = __webpack_require__(12)
	  , toPrimitive = __webpack_require__(16);
	
	// MS Edge has broken Reflect.defineProperty - throwing instead of returning false
	$export($export.S + $export.F * __webpack_require__(7)(function(){
	  Reflect.defineProperty(dP.f({}, 1, {value: 1}), 1, {value: 2});
	}), 'Reflect', {
	  defineProperty: function defineProperty(target, propertyKey, attributes){
	    anObject(target);
	    propertyKey = toPrimitive(propertyKey, true);
	    anObject(attributes);
	    try {
	      dP.f(target, propertyKey, attributes);
	      return true;
	    } catch(e){
	      return false;
	    }
	  }
	});

/***/ },
/* 236 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.4 Reflect.deleteProperty(target, propertyKey)
	var $export  = __webpack_require__(8)
	  , gOPD     = __webpack_require__(51).f
	  , anObject = __webpack_require__(12);
	
	$export($export.S, 'Reflect', {
	  deleteProperty: function deleteProperty(target, propertyKey){
	    var desc = gOPD(anObject(target), propertyKey);
	    return desc && !desc.configurable ? false : delete target[propertyKey];
	  }
	});

/***/ },
/* 237 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 26.1.5 Reflect.enumerate(target)
	var $export  = __webpack_require__(8)
	  , anObject = __webpack_require__(12);
	var Enumerate = function(iterated){
	  this._t = anObject(iterated); // target
	  this._i = 0;                  // next index
	  var keys = this._k = []       // keys
	    , key;
	  for(key in iterated)keys.push(key);
	};
	__webpack_require__(131)(Enumerate, 'Object', function(){
	  var that = this
	    , keys = that._k
	    , key;
	  do {
	    if(that._i >= keys.length)return {value: undefined, done: true};
	  } while(!((key = keys[that._i++]) in that._t));
	  return {value: key, done: false};
	});
	
	$export($export.S, 'Reflect', {
	  enumerate: function enumerate(target){
	    return new Enumerate(target);
	  }
	});

/***/ },
/* 238 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.6 Reflect.get(target, propertyKey [, receiver])
	var gOPD           = __webpack_require__(51)
	  , getPrototypeOf = __webpack_require__(59)
	  , has            = __webpack_require__(5)
	  , $export        = __webpack_require__(8)
	  , isObject       = __webpack_require__(13)
	  , anObject       = __webpack_require__(12);
	
	function get(target, propertyKey/*, receiver*/){
	  var receiver = arguments.length < 3 ? target : arguments[2]
	    , desc, proto;
	  if(anObject(target) === receiver)return target[propertyKey];
	  if(desc = gOPD.f(target, propertyKey))return has(desc, 'value')
	    ? desc.value
	    : desc.get !== undefined
	      ? desc.get.call(receiver)
	      : undefined;
	  if(isObject(proto = getPrototypeOf(target)))return get(proto, propertyKey, receiver);
	}
	
	$export($export.S, 'Reflect', {get: get});

/***/ },
/* 239 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
	var gOPD     = __webpack_require__(51)
	  , $export  = __webpack_require__(8)
	  , anObject = __webpack_require__(12);
	
	$export($export.S, 'Reflect', {
	  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey){
	    return gOPD.f(anObject(target), propertyKey);
	  }
	});

/***/ },
/* 240 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.8 Reflect.getPrototypeOf(target)
	var $export  = __webpack_require__(8)
	  , getProto = __webpack_require__(59)
	  , anObject = __webpack_require__(12);
	
	$export($export.S, 'Reflect', {
	  getPrototypeOf: function getPrototypeOf(target){
	    return getProto(anObject(target));
	  }
	});

/***/ },
/* 241 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.9 Reflect.has(target, propertyKey)
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Reflect', {
	  has: function has(target, propertyKey){
	    return propertyKey in target;
	  }
	});

/***/ },
/* 242 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.10 Reflect.isExtensible(target)
	var $export       = __webpack_require__(8)
	  , anObject      = __webpack_require__(12)
	  , $isExtensible = Object.isExtensible;
	
	$export($export.S, 'Reflect', {
	  isExtensible: function isExtensible(target){
	    anObject(target);
	    return $isExtensible ? $isExtensible(target) : true;
	  }
	});

/***/ },
/* 243 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.11 Reflect.ownKeys(target)
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Reflect', {ownKeys: __webpack_require__(244)});

/***/ },
/* 244 */
/***/ function(module, exports, __webpack_require__) {

	// all object keys, includes non-enumerable and symbols
	var gOPN     = __webpack_require__(50)
	  , gOPS     = __webpack_require__(43)
	  , anObject = __webpack_require__(12)
	  , Reflect  = __webpack_require__(4).Reflect;
	module.exports = Reflect && Reflect.ownKeys || function ownKeys(it){
	  var keys       = gOPN.f(anObject(it))
	    , getSymbols = gOPS.f;
	  return getSymbols ? keys.concat(getSymbols(it)) : keys;
	};

/***/ },
/* 245 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.12 Reflect.preventExtensions(target)
	var $export            = __webpack_require__(8)
	  , anObject           = __webpack_require__(12)
	  , $preventExtensions = Object.preventExtensions;
	
	$export($export.S, 'Reflect', {
	  preventExtensions: function preventExtensions(target){
	    anObject(target);
	    try {
	      if($preventExtensions)$preventExtensions(target);
	      return true;
	    } catch(e){
	      return false;
	    }
	  }
	});

/***/ },
/* 246 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
	var dP             = __webpack_require__(11)
	  , gOPD           = __webpack_require__(51)
	  , getPrototypeOf = __webpack_require__(59)
	  , has            = __webpack_require__(5)
	  , $export        = __webpack_require__(8)
	  , createDesc     = __webpack_require__(17)
	  , anObject       = __webpack_require__(12)
	  , isObject       = __webpack_require__(13);
	
	function set(target, propertyKey, V/*, receiver*/){
	  var receiver = arguments.length < 4 ? target : arguments[3]
	    , ownDesc  = gOPD.f(anObject(target), propertyKey)
	    , existingDescriptor, proto;
	  if(!ownDesc){
	    if(isObject(proto = getPrototypeOf(target))){
	      return set(proto, propertyKey, V, receiver);
	    }
	    ownDesc = createDesc(0);
	  }
	  if(has(ownDesc, 'value')){
	    if(ownDesc.writable === false || !isObject(receiver))return false;
	    existingDescriptor = gOPD.f(receiver, propertyKey) || createDesc(0);
	    existingDescriptor.value = V;
	    dP.f(receiver, propertyKey, existingDescriptor);
	    return true;
	  }
	  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
	}
	
	$export($export.S, 'Reflect', {set: set});

/***/ },
/* 247 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.14 Reflect.setPrototypeOf(target, proto)
	var $export  = __webpack_require__(8)
	  , setProto = __webpack_require__(73);
	
	if(setProto)$export($export.S, 'Reflect', {
	  setPrototypeOf: function setPrototypeOf(target, proto){
	    setProto.check(target, proto);
	    try {
	      setProto.set(target, proto);
	      return true;
	    } catch(e){
	      return false;
	    }
	  }
	});

/***/ },
/* 248 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/tc39/Array.prototype.includes
	var $export   = __webpack_require__(8)
	  , $includes = __webpack_require__(36)(true);
	
	$export($export.P, 'Array', {
	  includes: function includes(el /*, fromIndex = 0 */){
	    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});
	
	__webpack_require__(187)('includes');

/***/ },
/* 249 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/mathiasbynens/String.prototype.at
	var $export = __webpack_require__(8)
	  , $at     = __webpack_require__(128)(true);
	
	$export($export.P, 'String', {
	  at: function at(pos){
	    return $at(this, pos);
	  }
	});

/***/ },
/* 250 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/tc39/proposal-string-pad-start-end
	var $export = __webpack_require__(8)
	  , $pad    = __webpack_require__(251);
	
	$export($export.P, 'String', {
	  padStart: function padStart(maxLength /*, fillString = ' ' */){
	    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);
	  }
	});

/***/ },
/* 251 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/tc39/proposal-string-pad-start-end
	var toLength = __webpack_require__(37)
	  , repeat   = __webpack_require__(92)
	  , defined  = __webpack_require__(35);
	
	module.exports = function(that, maxLength, fillString, left){
	  var S            = String(defined(that))
	    , stringLength = S.length
	    , fillStr      = fillString === undefined ? ' ' : String(fillString)
	    , intMaxLength = toLength(maxLength);
	  if(intMaxLength <= stringLength || fillStr == '')return S;
	  var fillLen = intMaxLength - stringLength
	    , stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
	  if(stringFiller.length > fillLen)stringFiller = stringFiller.slice(0, fillLen);
	  return left ? stringFiller + S : S + stringFiller;
	};


/***/ },
/* 252 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/tc39/proposal-string-pad-start-end
	var $export = __webpack_require__(8)
	  , $pad    = __webpack_require__(251);
	
	$export($export.P, 'String', {
	  padEnd: function padEnd(maxLength /*, fillString = ' ' */){
	    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);
	  }
	});

/***/ },
/* 253 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
	__webpack_require__(83)('trimLeft', function($trim){
	  return function trimLeft(){
	    return $trim(this, 1);
	  };
	}, 'trimStart');

/***/ },
/* 254 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
	__webpack_require__(83)('trimRight', function($trim){
	  return function trimRight(){
	    return $trim(this, 2);
	  };
	}, 'trimEnd');

/***/ },
/* 255 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://tc39.github.io/String.prototype.matchAll/
	var $export     = __webpack_require__(8)
	  , defined     = __webpack_require__(35)
	  , toLength    = __webpack_require__(37)
	  , isRegExp    = __webpack_require__(135)
	  , getFlags    = __webpack_require__(197)
	  , RegExpProto = RegExp.prototype;
	
	var $RegExpStringIterator = function(regexp, string){
	  this._r = regexp;
	  this._s = string;
	};
	
	__webpack_require__(131)($RegExpStringIterator, 'RegExp String', function next(){
	  var match = this._r.exec(this._s);
	  return {value: match, done: match === null};
	});
	
	$export($export.P, 'String', {
	  matchAll: function matchAll(regexp){
	    defined(this);
	    if(!isRegExp(regexp))throw TypeError(regexp + ' is not a regexp!');
	    var S     = String(this)
	      , flags = 'flags' in RegExpProto ? String(regexp.flags) : getFlags.call(regexp)
	      , rx    = new RegExp(regexp.source, ~flags.indexOf('g') ? flags : 'g' + flags);
	    rx.lastIndex = toLength(regexp.lastIndex);
	    return new $RegExpStringIterator(rx, S);
	  }
	});

/***/ },
/* 256 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(27)('asyncIterator');

/***/ },
/* 257 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(27)('observable');

/***/ },
/* 258 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/tc39/proposal-object-getownpropertydescriptors
	var $export        = __webpack_require__(8)
	  , ownKeys        = __webpack_require__(244)
	  , toIObject      = __webpack_require__(32)
	  , gOPD           = __webpack_require__(51)
	  , createProperty = __webpack_require__(164);
	
	$export($export.S, 'Object', {
	  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object){
	    var O       = toIObject(object)
	      , getDesc = gOPD.f
	      , keys    = ownKeys(O)
	      , result  = {}
	      , i       = 0
	      , key, D;
	    while(keys.length > i)createProperty(result, key = keys[i++], getDesc(O, key));
	    return result;
	  }
	});

/***/ },
/* 259 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/tc39/proposal-object-values-entries
	var $export = __webpack_require__(8)
	  , $values = __webpack_require__(260)(false);
	
	$export($export.S, 'Object', {
	  values: function values(it){
	    return $values(it);
	  }
	});

/***/ },
/* 260 */
/***/ function(module, exports, __webpack_require__) {

	var getKeys   = __webpack_require__(30)
	  , toIObject = __webpack_require__(32)
	  , isEnum    = __webpack_require__(44).f;
	module.exports = function(isEntries){
	  return function(it){
	    var O      = toIObject(it)
	      , keys   = getKeys(O)
	      , length = keys.length
	      , i      = 0
	      , result = []
	      , key;
	    while(length > i)if(isEnum.call(O, key = keys[i++])){
	      result.push(isEntries ? [key, O[key]] : O[key]);
	    } return result;
	  };
	};

/***/ },
/* 261 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/tc39/proposal-object-values-entries
	var $export  = __webpack_require__(8)
	  , $entries = __webpack_require__(260)(true);
	
	$export($export.S, 'Object', {
	  entries: function entries(it){
	    return $entries(it);
	  }
	});

/***/ },
/* 262 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export         = __webpack_require__(8)
	  , toObject        = __webpack_require__(58)
	  , aFunction       = __webpack_require__(21)
	  , $defineProperty = __webpack_require__(11);
	
	// B.2.2.2 Object.prototype.__defineGetter__(P, getter)
	__webpack_require__(6) && $export($export.P + __webpack_require__(263), 'Object', {
	  __defineGetter__: function __defineGetter__(P, getter){
	    $defineProperty.f(toObject(this), P, {get: aFunction(getter), enumerable: true, configurable: true});
	  }
	});

/***/ },
/* 263 */
/***/ function(module, exports, __webpack_require__) {

	// Forced replacement prototype accessors methods
	module.exports = __webpack_require__(28)|| !__webpack_require__(7)(function(){
	  var K = Math.random();
	  // In FF throws only define methods
	  __defineSetter__.call(null, K, function(){ /* empty */});
	  delete __webpack_require__(4)[K];
	});

/***/ },
/* 264 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export         = __webpack_require__(8)
	  , toObject        = __webpack_require__(58)
	  , aFunction       = __webpack_require__(21)
	  , $defineProperty = __webpack_require__(11);
	
	// B.2.2.3 Object.prototype.__defineSetter__(P, setter)
	__webpack_require__(6) && $export($export.P + __webpack_require__(263), 'Object', {
	  __defineSetter__: function __defineSetter__(P, setter){
	    $defineProperty.f(toObject(this), P, {set: aFunction(setter), enumerable: true, configurable: true});
	  }
	});

/***/ },
/* 265 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export                  = __webpack_require__(8)
	  , toObject                 = __webpack_require__(58)
	  , toPrimitive              = __webpack_require__(16)
	  , getPrototypeOf           = __webpack_require__(59)
	  , getOwnPropertyDescriptor = __webpack_require__(51).f;
	
	// B.2.2.4 Object.prototype.__lookupGetter__(P)
	__webpack_require__(6) && $export($export.P + __webpack_require__(263), 'Object', {
	  __lookupGetter__: function __lookupGetter__(P){
	    var O = toObject(this)
	      , K = toPrimitive(P, true)
	      , D;
	    do {
	      if(D = getOwnPropertyDescriptor(O, K))return D.get;
	    } while(O = getPrototypeOf(O));
	  }
	});

/***/ },
/* 266 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export                  = __webpack_require__(8)
	  , toObject                 = __webpack_require__(58)
	  , toPrimitive              = __webpack_require__(16)
	  , getPrototypeOf           = __webpack_require__(59)
	  , getOwnPropertyDescriptor = __webpack_require__(51).f;
	
	// B.2.2.5 Object.prototype.__lookupSetter__(P)
	__webpack_require__(6) && $export($export.P + __webpack_require__(263), 'Object', {
	  __lookupSetter__: function __lookupSetter__(P){
	    var O = toObject(this)
	      , K = toPrimitive(P, true)
	      , D;
	    do {
	      if(D = getOwnPropertyDescriptor(O, K))return D.set;
	    } while(O = getPrototypeOf(O));
	  }
	});

/***/ },
/* 267 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var $export  = __webpack_require__(8);
	
	$export($export.P + $export.R, 'Map', {toJSON: __webpack_require__(268)('Map')});

/***/ },
/* 268 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var classof = __webpack_require__(75)
	  , from    = __webpack_require__(269);
	module.exports = function(NAME){
	  return function toJSON(){
	    if(classof(this) != NAME)throw TypeError(NAME + "#toJSON isn't generic");
	    return from(this);
	  };
	};

/***/ },
/* 269 */
/***/ function(module, exports, __webpack_require__) {

	var forOf = __webpack_require__(206);
	
	module.exports = function(iter, ITERATOR){
	  var result = [];
	  forOf(iter, false, result.push, result, ITERATOR);
	  return result;
	};


/***/ },
/* 270 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var $export  = __webpack_require__(8);
	
	$export($export.P + $export.R, 'Set', {toJSON: __webpack_require__(268)('Set')});

/***/ },
/* 271 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/ljharb/proposal-global
	var $export = __webpack_require__(8);
	
	$export($export.S, 'System', {global: __webpack_require__(4)});

/***/ },
/* 272 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/ljharb/proposal-is-error
	var $export = __webpack_require__(8)
	  , cof     = __webpack_require__(34);
	
	$export($export.S, 'Error', {
	  isError: function isError(it){
	    return cof(it) === 'Error';
	  }
	});

/***/ },
/* 273 */
/***/ function(module, exports, __webpack_require__) {

	// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Math', {
	  iaddh: function iaddh(x0, x1, y0, y1){
	    var $x0 = x0 >>> 0
	      , $x1 = x1 >>> 0
	      , $y0 = y0 >>> 0;
	    return $x1 + (y1 >>> 0) + (($x0 & $y0 | ($x0 | $y0) & ~($x0 + $y0 >>> 0)) >>> 31) | 0;
	  }
	});

/***/ },
/* 274 */
/***/ function(module, exports, __webpack_require__) {

	// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Math', {
	  isubh: function isubh(x0, x1, y0, y1){
	    var $x0 = x0 >>> 0
	      , $x1 = x1 >>> 0
	      , $y0 = y0 >>> 0;
	    return $x1 - (y1 >>> 0) - ((~$x0 & $y0 | ~($x0 ^ $y0) & $x0 - $y0 >>> 0) >>> 31) | 0;
	  }
	});

/***/ },
/* 275 */
/***/ function(module, exports, __webpack_require__) {

	// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Math', {
	  imulh: function imulh(u, v){
	    var UINT16 = 0xffff
	      , $u = +u
	      , $v = +v
	      , u0 = $u & UINT16
	      , v0 = $v & UINT16
	      , u1 = $u >> 16
	      , v1 = $v >> 16
	      , t  = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
	    return u1 * v1 + (t >> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >> 16);
	  }
	});

/***/ },
/* 276 */
/***/ function(module, exports, __webpack_require__) {

	// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Math', {
	  umulh: function umulh(u, v){
	    var UINT16 = 0xffff
	      , $u = +u
	      , $v = +v
	      , u0 = $u & UINT16
	      , v0 = $v & UINT16
	      , u1 = $u >>> 16
	      , v1 = $v >>> 16
	      , t  = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
	    return u1 * v1 + (t >>> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >>> 16);
	  }
	});

/***/ },
/* 277 */
/***/ function(module, exports, __webpack_require__) {

	var metadata                  = __webpack_require__(278)
	  , anObject                  = __webpack_require__(12)
	  , toMetaKey                 = metadata.key
	  , ordinaryDefineOwnMetadata = metadata.set;
	
	metadata.exp({defineMetadata: function defineMetadata(metadataKey, metadataValue, target, targetKey){
	  ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject(target), toMetaKey(targetKey));
	}});

/***/ },
/* 278 */
/***/ function(module, exports, __webpack_require__) {

	var Map     = __webpack_require__(211)
	  , $export = __webpack_require__(8)
	  , shared  = __webpack_require__(23)('metadata')
	  , store   = shared.store || (shared.store = new (__webpack_require__(215)));
	
	var getOrCreateMetadataMap = function(target, targetKey, create){
	  var targetMetadata = store.get(target);
	  if(!targetMetadata){
	    if(!create)return undefined;
	    store.set(target, targetMetadata = new Map);
	  }
	  var keyMetadata = targetMetadata.get(targetKey);
	  if(!keyMetadata){
	    if(!create)return undefined;
	    targetMetadata.set(targetKey, keyMetadata = new Map);
	  } return keyMetadata;
	};
	var ordinaryHasOwnMetadata = function(MetadataKey, O, P){
	  var metadataMap = getOrCreateMetadataMap(O, P, false);
	  return metadataMap === undefined ? false : metadataMap.has(MetadataKey);
	};
	var ordinaryGetOwnMetadata = function(MetadataKey, O, P){
	  var metadataMap = getOrCreateMetadataMap(O, P, false);
	  return metadataMap === undefined ? undefined : metadataMap.get(MetadataKey);
	};
	var ordinaryDefineOwnMetadata = function(MetadataKey, MetadataValue, O, P){
	  getOrCreateMetadataMap(O, P, true).set(MetadataKey, MetadataValue);
	};
	var ordinaryOwnMetadataKeys = function(target, targetKey){
	  var metadataMap = getOrCreateMetadataMap(target, targetKey, false)
	    , keys        = [];
	  if(metadataMap)metadataMap.forEach(function(_, key){ keys.push(key); });
	  return keys;
	};
	var toMetaKey = function(it){
	  return it === undefined || typeof it == 'symbol' ? it : String(it);
	};
	var exp = function(O){
	  $export($export.S, 'Reflect', O);
	};
	
	module.exports = {
	  store: store,
	  map: getOrCreateMetadataMap,
	  has: ordinaryHasOwnMetadata,
	  get: ordinaryGetOwnMetadata,
	  set: ordinaryDefineOwnMetadata,
	  keys: ordinaryOwnMetadataKeys,
	  key: toMetaKey,
	  exp: exp
	};

/***/ },
/* 279 */
/***/ function(module, exports, __webpack_require__) {

	var metadata               = __webpack_require__(278)
	  , anObject               = __webpack_require__(12)
	  , toMetaKey              = metadata.key
	  , getOrCreateMetadataMap = metadata.map
	  , store                  = metadata.store;
	
	metadata.exp({deleteMetadata: function deleteMetadata(metadataKey, target /*, targetKey */){
	  var targetKey   = arguments.length < 3 ? undefined : toMetaKey(arguments[2])
	    , metadataMap = getOrCreateMetadataMap(anObject(target), targetKey, false);
	  if(metadataMap === undefined || !metadataMap['delete'](metadataKey))return false;
	  if(metadataMap.size)return true;
	  var targetMetadata = store.get(target);
	  targetMetadata['delete'](targetKey);
	  return !!targetMetadata.size || store['delete'](target);
	}});

/***/ },
/* 280 */
/***/ function(module, exports, __webpack_require__) {

	var metadata               = __webpack_require__(278)
	  , anObject               = __webpack_require__(12)
	  , getPrototypeOf         = __webpack_require__(59)
	  , ordinaryHasOwnMetadata = metadata.has
	  , ordinaryGetOwnMetadata = metadata.get
	  , toMetaKey              = metadata.key;
	
	var ordinaryGetMetadata = function(MetadataKey, O, P){
	  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
	  if(hasOwn)return ordinaryGetOwnMetadata(MetadataKey, O, P);
	  var parent = getPrototypeOf(O);
	  return parent !== null ? ordinaryGetMetadata(MetadataKey, parent, P) : undefined;
	};
	
	metadata.exp({getMetadata: function getMetadata(metadataKey, target /*, targetKey */){
	  return ordinaryGetMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
	}});

/***/ },
/* 281 */
/***/ function(module, exports, __webpack_require__) {

	var Set                     = __webpack_require__(214)
	  , from                    = __webpack_require__(269)
	  , metadata                = __webpack_require__(278)
	  , anObject                = __webpack_require__(12)
	  , getPrototypeOf          = __webpack_require__(59)
	  , ordinaryOwnMetadataKeys = metadata.keys
	  , toMetaKey               = metadata.key;
	
	var ordinaryMetadataKeys = function(O, P){
	  var oKeys  = ordinaryOwnMetadataKeys(O, P)
	    , parent = getPrototypeOf(O);
	  if(parent === null)return oKeys;
	  var pKeys  = ordinaryMetadataKeys(parent, P);
	  return pKeys.length ? oKeys.length ? from(new Set(oKeys.concat(pKeys))) : pKeys : oKeys;
	};
	
	metadata.exp({getMetadataKeys: function getMetadataKeys(target /*, targetKey */){
	  return ordinaryMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
	}});

/***/ },
/* 282 */
/***/ function(module, exports, __webpack_require__) {

	var metadata               = __webpack_require__(278)
	  , anObject               = __webpack_require__(12)
	  , ordinaryGetOwnMetadata = metadata.get
	  , toMetaKey              = metadata.key;
	
	metadata.exp({getOwnMetadata: function getOwnMetadata(metadataKey, target /*, targetKey */){
	  return ordinaryGetOwnMetadata(metadataKey, anObject(target)
	    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
	}});

/***/ },
/* 283 */
/***/ function(module, exports, __webpack_require__) {

	var metadata                = __webpack_require__(278)
	  , anObject                = __webpack_require__(12)
	  , ordinaryOwnMetadataKeys = metadata.keys
	  , toMetaKey               = metadata.key;
	
	metadata.exp({getOwnMetadataKeys: function getOwnMetadataKeys(target /*, targetKey */){
	  return ordinaryOwnMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
	}});

/***/ },
/* 284 */
/***/ function(module, exports, __webpack_require__) {

	var metadata               = __webpack_require__(278)
	  , anObject               = __webpack_require__(12)
	  , getPrototypeOf         = __webpack_require__(59)
	  , ordinaryHasOwnMetadata = metadata.has
	  , toMetaKey              = metadata.key;
	
	var ordinaryHasMetadata = function(MetadataKey, O, P){
	  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
	  if(hasOwn)return true;
	  var parent = getPrototypeOf(O);
	  return parent !== null ? ordinaryHasMetadata(MetadataKey, parent, P) : false;
	};
	
	metadata.exp({hasMetadata: function hasMetadata(metadataKey, target /*, targetKey */){
	  return ordinaryHasMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
	}});

/***/ },
/* 285 */
/***/ function(module, exports, __webpack_require__) {

	var metadata               = __webpack_require__(278)
	  , anObject               = __webpack_require__(12)
	  , ordinaryHasOwnMetadata = metadata.has
	  , toMetaKey              = metadata.key;
	
	metadata.exp({hasOwnMetadata: function hasOwnMetadata(metadataKey, target /*, targetKey */){
	  return ordinaryHasOwnMetadata(metadataKey, anObject(target)
	    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
	}});

/***/ },
/* 286 */
/***/ function(module, exports, __webpack_require__) {

	var metadata                  = __webpack_require__(278)
	  , anObject                  = __webpack_require__(12)
	  , aFunction                 = __webpack_require__(21)
	  , toMetaKey                 = metadata.key
	  , ordinaryDefineOwnMetadata = metadata.set;
	
	metadata.exp({metadata: function metadata(metadataKey, metadataValue){
	  return function decorator(target, targetKey){
	    ordinaryDefineOwnMetadata(
	      metadataKey, metadataValue,
	      (targetKey !== undefined ? anObject : aFunction)(target),
	      toMetaKey(targetKey)
	    );
	  };
	}});

/***/ },
/* 287 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-09/sept-25.md#510-globalasap-for-enqueuing-a-microtask
	var $export   = __webpack_require__(8)
	  , microtask = __webpack_require__(209)()
	  , process   = __webpack_require__(4).process
	  , isNode    = __webpack_require__(34)(process) == 'process';
	
	$export($export.G, {
	  asap: function asap(fn){
	    var domain = isNode && process.domain;
	    microtask(domain ? domain.bind(fn) : fn);
	  }
	});

/***/ },
/* 288 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/zenparsing/es-observable
	var $export     = __webpack_require__(8)
	  , global      = __webpack_require__(4)
	  , core        = __webpack_require__(9)
	  , microtask   = __webpack_require__(209)()
	  , OBSERVABLE  = __webpack_require__(25)('observable')
	  , aFunction   = __webpack_require__(21)
	  , anObject    = __webpack_require__(12)
	  , anInstance  = __webpack_require__(90)
	  , redefineAll = __webpack_require__(210)
	  , hide        = __webpack_require__(10)
	  , forOf       = __webpack_require__(206)
	  , RETURN      = forOf.RETURN;
	
	var getMethod = function(fn){
	  return fn == null ? undefined : aFunction(fn);
	};
	
	var cleanupSubscription = function(subscription){
	  var cleanup = subscription._c;
	  if(cleanup){
	    subscription._c = undefined;
	    cleanup();
	  }
	};
	
	var subscriptionClosed = function(subscription){
	  return subscription._o === undefined;
	};
	
	var closeSubscription = function(subscription){
	  if(!subscriptionClosed(subscription)){
	    subscription._o = undefined;
	    cleanupSubscription(subscription);
	  }
	};
	
	var Subscription = function(observer, subscriber){
	  anObject(observer);
	  this._c = undefined;
	  this._o = observer;
	  observer = new SubscriptionObserver(this);
	  try {
	    var cleanup      = subscriber(observer)
	      , subscription = cleanup;
	    if(cleanup != null){
	      if(typeof cleanup.unsubscribe === 'function')cleanup = function(){ subscription.unsubscribe(); };
	      else aFunction(cleanup);
	      this._c = cleanup;
	    }
	  } catch(e){
	    observer.error(e);
	    return;
	  } if(subscriptionClosed(this))cleanupSubscription(this);
	};
	
	Subscription.prototype = redefineAll({}, {
	  unsubscribe: function unsubscribe(){ closeSubscription(this); }
	});
	
	var SubscriptionObserver = function(subscription){
	  this._s = subscription;
	};
	
	SubscriptionObserver.prototype = redefineAll({}, {
	  next: function next(value){
	    var subscription = this._s;
	    if(!subscriptionClosed(subscription)){
	      var observer = subscription._o;
	      try {
	        var m = getMethod(observer.next);
	        if(m)return m.call(observer, value);
	      } catch(e){
	        try {
	          closeSubscription(subscription);
	        } finally {
	          throw e;
	        }
	      }
	    }
	  },
	  error: function error(value){
	    var subscription = this._s;
	    if(subscriptionClosed(subscription))throw value;
	    var observer = subscription._o;
	    subscription._o = undefined;
	    try {
	      var m = getMethod(observer.error);
	      if(!m)throw value;
	      value = m.call(observer, value);
	    } catch(e){
	      try {
	        cleanupSubscription(subscription);
	      } finally {
	        throw e;
	      }
	    } cleanupSubscription(subscription);
	    return value;
	  },
	  complete: function complete(value){
	    var subscription = this._s;
	    if(!subscriptionClosed(subscription)){
	      var observer = subscription._o;
	      subscription._o = undefined;
	      try {
	        var m = getMethod(observer.complete);
	        value = m ? m.call(observer, value) : undefined;
	      } catch(e){
	        try {
	          cleanupSubscription(subscription);
	        } finally {
	          throw e;
	        }
	      } cleanupSubscription(subscription);
	      return value;
	    }
	  }
	});
	
	var $Observable = function Observable(subscriber){
	  anInstance(this, $Observable, 'Observable', '_f')._f = aFunction(subscriber);
	};
	
	redefineAll($Observable.prototype, {
	  subscribe: function subscribe(observer){
	    return new Subscription(observer, this._f);
	  },
	  forEach: function forEach(fn){
	    var that = this;
	    return new (core.Promise || global.Promise)(function(resolve, reject){
	      aFunction(fn);
	      var subscription = that.subscribe({
	        next : function(value){
	          try {
	            return fn(value);
	          } catch(e){
	            reject(e);
	            subscription.unsubscribe();
	          }
	        },
	        error: reject,
	        complete: resolve
	      });
	    });
	  }
	});
	
	redefineAll($Observable, {
	  from: function from(x){
	    var C = typeof this === 'function' ? this : $Observable;
	    var method = getMethod(anObject(x)[OBSERVABLE]);
	    if(method){
	      var observable = anObject(method.call(x));
	      return observable.constructor === C ? observable : new C(function(observer){
	        return observable.subscribe(observer);
	      });
	    }
	    return new C(function(observer){
	      var done = false;
	      microtask(function(){
	        if(!done){
	          try {
	            if(forOf(x, false, function(it){
	              observer.next(it);
	              if(done)return RETURN;
	            }) === RETURN)return;
	          } catch(e){
	            if(done)throw e;
	            observer.error(e);
	            return;
	          } observer.complete();
	        }
	      });
	      return function(){ done = true; };
	    });
	  },
	  of: function of(){
	    for(var i = 0, l = arguments.length, items = Array(l); i < l;)items[i] = arguments[i++];
	    return new (typeof this === 'function' ? this : $Observable)(function(observer){
	      var done = false;
	      microtask(function(){
	        if(!done){
	          for(var i = 0; i < items.length; ++i){
	            observer.next(items[i]);
	            if(done)return;
	          } observer.complete();
	        }
	      });
	      return function(){ done = true; };
	    });
	  }
	});
	
	hide($Observable.prototype, OBSERVABLE, function(){ return this; });
	
	$export($export.G, {Observable: $Observable});
	
	__webpack_require__(193)('Observable');

/***/ },
/* 289 */
/***/ function(module, exports, __webpack_require__) {

	// ie9- setTimeout & setInterval additional parameters fix
	var global     = __webpack_require__(4)
	  , $export    = __webpack_require__(8)
	  , invoke     = __webpack_require__(78)
	  , partial    = __webpack_require__(290)
	  , navigator  = global.navigator
	  , MSIE       = !!navigator && /MSIE .\./.test(navigator.userAgent); // <- dirty ie9- check
	var wrap = function(set){
	  return MSIE ? function(fn, time /*, ...args */){
	    return set(invoke(
	      partial,
	      [].slice.call(arguments, 2),
	      typeof fn == 'function' ? fn : Function(fn)
	    ), time);
	  } : set;
	};
	$export($export.G + $export.B + $export.F * MSIE, {
	  setTimeout:  wrap(global.setTimeout),
	  setInterval: wrap(global.setInterval)
	});

/***/ },
/* 290 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var path      = __webpack_require__(291)
	  , invoke    = __webpack_require__(78)
	  , aFunction = __webpack_require__(21);
	module.exports = function(/* ...pargs */){
	  var fn     = aFunction(this)
	    , length = arguments.length
	    , pargs  = Array(length)
	    , i      = 0
	    , _      = path._
	    , holder = false;
	  while(length > i)if((pargs[i] = arguments[i++]) === _)holder = true;
	  return function(/* ...args */){
	    var that = this
	      , aLen = arguments.length
	      , j = 0, k = 0, args;
	    if(!holder && !aLen)return invoke(fn, pargs, that);
	    args = pargs.slice();
	    if(holder)for(;length > j; j++)if(args[j] === _)args[j] = arguments[k++];
	    while(aLen > k)args.push(arguments[k++]);
	    return invoke(fn, args, that);
	  };
	};

/***/ },
/* 291 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(4);

/***/ },
/* 292 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(8)
	  , $task   = __webpack_require__(208);
	$export($export.G + $export.B, {
	  setImmediate:   $task.set,
	  clearImmediate: $task.clear
	});

/***/ },
/* 293 */
/***/ function(module, exports, __webpack_require__) {

	var $iterators    = __webpack_require__(194)
	  , redefine      = __webpack_require__(18)
	  , global        = __webpack_require__(4)
	  , hide          = __webpack_require__(10)
	  , Iterators     = __webpack_require__(130)
	  , wks           = __webpack_require__(25)
	  , ITERATOR      = wks('iterator')
	  , TO_STRING_TAG = wks('toStringTag')
	  , ArrayValues   = Iterators.Array;
	
	for(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){
	  var NAME       = collections[i]
	    , Collection = global[NAME]
	    , proto      = Collection && Collection.prototype
	    , key;
	  if(proto){
	    if(!proto[ITERATOR])hide(proto, ITERATOR, ArrayValues);
	    if(!proto[TO_STRING_TAG])hide(proto, TO_STRING_TAG, NAME);
	    Iterators[NAME] = ArrayValues;
	    for(key in $iterators)if(!proto[key])redefine(proto, key, $iterators[key], true);
	  }
	}

/***/ },
/* 294 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {/**
	 * Copyright (c) 2014, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
	 * additional grant of patent rights can be found in the PATENTS file in
	 * the same directory.
	 */
	
	!(function(global) {
	  "use strict";
	
	  var hasOwn = Object.prototype.hasOwnProperty;
	  var undefined; // More compressible than void 0.
	  var $Symbol = typeof Symbol === "function" ? Symbol : {};
	  var iteratorSymbol = $Symbol.iterator || "@@iterator";
	  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
	
	  var inModule = typeof module === "object";
	  var runtime = global.regeneratorRuntime;
	  if (runtime) {
	    if (inModule) {
	      // If regeneratorRuntime is defined globally and we're in a module,
	      // make the exports object identical to regeneratorRuntime.
	      module.exports = runtime;
	    }
	    // Don't bother evaluating the rest of this file if the runtime was
	    // already defined globally.
	    return;
	  }
	
	  // Define the runtime globally (as expected by generated code) as either
	  // module.exports (if we're in a module) or a new, empty object.
	  runtime = global.regeneratorRuntime = inModule ? module.exports : {};
	
	  function wrap(innerFn, outerFn, self, tryLocsList) {
	    // If outerFn provided, then outerFn.prototype instanceof Generator.
	    var generator = Object.create((outerFn || Generator).prototype);
	    var context = new Context(tryLocsList || []);
	
	    // The ._invoke method unifies the implementations of the .next,
	    // .throw, and .return methods.
	    generator._invoke = makeInvokeMethod(innerFn, self, context);
	
	    return generator;
	  }
	  runtime.wrap = wrap;
	
	  // Try/catch helper to minimize deoptimizations. Returns a completion
	  // record like context.tryEntries[i].completion. This interface could
	  // have been (and was previously) designed to take a closure to be
	  // invoked without arguments, but in all the cases we care about we
	  // already have an existing method we want to call, so there's no need
	  // to create a new function object. We can even get away with assuming
	  // the method takes exactly one argument, since that happens to be true
	  // in every case, so we don't have to touch the arguments object. The
	  // only additional allocation required is the completion record, which
	  // has a stable shape and so hopefully should be cheap to allocate.
	  function tryCatch(fn, obj, arg) {
	    try {
	      return { type: "normal", arg: fn.call(obj, arg) };
	    } catch (err) {
	      return { type: "throw", arg: err };
	    }
	  }
	
	  var GenStateSuspendedStart = "suspendedStart";
	  var GenStateSuspendedYield = "suspendedYield";
	  var GenStateExecuting = "executing";
	  var GenStateCompleted = "completed";
	
	  // Returning this object from the innerFn has the same effect as
	  // breaking out of the dispatch switch statement.
	  var ContinueSentinel = {};
	
	  // Dummy constructor functions that we use as the .constructor and
	  // .constructor.prototype properties for functions that return Generator
	  // objects. For full spec compliance, you may wish to configure your
	  // minifier not to mangle the names of these two functions.
	  function Generator() {}
	  function GeneratorFunction() {}
	  function GeneratorFunctionPrototype() {}
	
	  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype;
	  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
	  GeneratorFunctionPrototype.constructor = GeneratorFunction;
	  GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction";
	
	  // Helper for defining the .next, .throw, and .return methods of the
	  // Iterator interface in terms of a single ._invoke method.
	  function defineIteratorMethods(prototype) {
	    ["next", "throw", "return"].forEach(function(method) {
	      prototype[method] = function(arg) {
	        return this._invoke(method, arg);
	      };
	    });
	  }
	
	  runtime.isGeneratorFunction = function(genFun) {
	    var ctor = typeof genFun === "function" && genFun.constructor;
	    return ctor
	      ? ctor === GeneratorFunction ||
	        // For the native GeneratorFunction constructor, the best we can
	        // do is to check its .name property.
	        (ctor.displayName || ctor.name) === "GeneratorFunction"
	      : false;
	  };
	
	  runtime.mark = function(genFun) {
	    if (Object.setPrototypeOf) {
	      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
	    } else {
	      genFun.__proto__ = GeneratorFunctionPrototype;
	      if (!(toStringTagSymbol in genFun)) {
	        genFun[toStringTagSymbol] = "GeneratorFunction";
	      }
	    }
	    genFun.prototype = Object.create(Gp);
	    return genFun;
	  };
	
	  // Within the body of any async function, `await x` is transformed to
	  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
	  // `value instanceof AwaitArgument` to determine if the yielded value is
	  // meant to be awaited. Some may consider the name of this method too
	  // cutesy, but they are curmudgeons.
	  runtime.awrap = function(arg) {
	    return new AwaitArgument(arg);
	  };
	
	  function AwaitArgument(arg) {
	    this.arg = arg;
	  }
	
	  function AsyncIterator(generator) {
	    function invoke(method, arg, resolve, reject) {
	      var record = tryCatch(generator[method], generator, arg);
	      if (record.type === "throw") {
	        reject(record.arg);
	      } else {
	        var result = record.arg;
	        var value = result.value;
	        if (value instanceof AwaitArgument) {
	          return Promise.resolve(value.arg).then(function(value) {
	            invoke("next", value, resolve, reject);
	          }, function(err) {
	            invoke("throw", err, resolve, reject);
	          });
	        }
	
	        return Promise.resolve(value).then(function(unwrapped) {
	          // When a yielded Promise is resolved, its final value becomes
	          // the .value of the Promise<{value,done}> result for the
	          // current iteration. If the Promise is rejected, however, the
	          // result for this iteration will be rejected with the same
	          // reason. Note that rejections of yielded Promises are not
	          // thrown back into the generator function, as is the case
	          // when an awaited Promise is rejected. This difference in
	          // behavior between yield and await is important, because it
	          // allows the consumer to decide what to do with the yielded
	          // rejection (swallow it and continue, manually .throw it back
	          // into the generator, abandon iteration, whatever). With
	          // await, by contrast, there is no opportunity to examine the
	          // rejection reason outside the generator function, so the
	          // only option is to throw it from the await expression, and
	          // let the generator function handle the exception.
	          result.value = unwrapped;
	          resolve(result);
	        }, reject);
	      }
	    }
	
	    if (typeof process === "object" && process.domain) {
	      invoke = process.domain.bind(invoke);
	    }
	
	    var previousPromise;
	
	    function enqueue(method, arg) {
	      function callInvokeWithMethodAndArg() {
	        return new Promise(function(resolve, reject) {
	          invoke(method, arg, resolve, reject);
	        });
	      }
	
	      return previousPromise =
	        // If enqueue has been called before, then we want to wait until
	        // all previous Promises have been resolved before calling invoke,
	        // so that results are always delivered in the correct order. If
	        // enqueue has not been called before, then it is important to
	        // call invoke immediately, without waiting on a callback to fire,
	        // so that the async generator function has the opportunity to do
	        // any necessary setup in a predictable way. This predictability
	        // is why the Promise constructor synchronously invokes its
	        // executor callback, and why async functions synchronously
	        // execute code before the first await. Since we implement simple
	        // async functions in terms of async generators, it is especially
	        // important to get this right, even though it requires care.
	        previousPromise ? previousPromise.then(
	          callInvokeWithMethodAndArg,
	          // Avoid propagating failures to Promises returned by later
	          // invocations of the iterator.
	          callInvokeWithMethodAndArg
	        ) : callInvokeWithMethodAndArg();
	    }
	
	    // Define the unified helper method that is used to implement .next,
	    // .throw, and .return (see defineIteratorMethods).
	    this._invoke = enqueue;
	  }
	
	  defineIteratorMethods(AsyncIterator.prototype);
	
	  // Note that simple async functions are implemented on top of
	  // AsyncIterator objects; they just return a Promise for the value of
	  // the final result produced by the iterator.
	  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
	    var iter = new AsyncIterator(
	      wrap(innerFn, outerFn, self, tryLocsList)
	    );
	
	    return runtime.isGeneratorFunction(outerFn)
	      ? iter // If outerFn is a generator, return the full iterator.
	      : iter.next().then(function(result) {
	          return result.done ? result.value : iter.next();
	        });
	  };
	
	  function makeInvokeMethod(innerFn, self, context) {
	    var state = GenStateSuspendedStart;
	
	    return function invoke(method, arg) {
	      if (state === GenStateExecuting) {
	        throw new Error("Generator is already running");
	      }
	
	      if (state === GenStateCompleted) {
	        if (method === "throw") {
	          throw arg;
	        }
	
	        // Be forgiving, per 25.3.3.3.3 of the spec:
	        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
	        return doneResult();
	      }
	
	      while (true) {
	        var delegate = context.delegate;
	        if (delegate) {
	          if (method === "return" ||
	              (method === "throw" && delegate.iterator[method] === undefined)) {
	            // A return or throw (when the delegate iterator has no throw
	            // method) always terminates the yield* loop.
	            context.delegate = null;
	
	            // If the delegate iterator has a return method, give it a
	            // chance to clean up.
	            var returnMethod = delegate.iterator["return"];
	            if (returnMethod) {
	              var record = tryCatch(returnMethod, delegate.iterator, arg);
	              if (record.type === "throw") {
	                // If the return method threw an exception, let that
	                // exception prevail over the original return or throw.
	                method = "throw";
	                arg = record.arg;
	                continue;
	              }
	            }
	
	            if (method === "return") {
	              // Continue with the outer return, now that the delegate
	              // iterator has been terminated.
	              continue;
	            }
	          }
	
	          var record = tryCatch(
	            delegate.iterator[method],
	            delegate.iterator,
	            arg
	          );
	
	          if (record.type === "throw") {
	            context.delegate = null;
	
	            // Like returning generator.throw(uncaught), but without the
	            // overhead of an extra function call.
	            method = "throw";
	            arg = record.arg;
	            continue;
	          }
	
	          // Delegate generator ran and handled its own exceptions so
	          // regardless of what the method was, we continue as if it is
	          // "next" with an undefined arg.
	          method = "next";
	          arg = undefined;
	
	          var info = record.arg;
	          if (info.done) {
	            context[delegate.resultName] = info.value;
	            context.next = delegate.nextLoc;
	          } else {
	            state = GenStateSuspendedYield;
	            return info;
	          }
	
	          context.delegate = null;
	        }
	
	        if (method === "next") {
	          // Setting context._sent for legacy support of Babel's
	          // function.sent implementation.
	          context.sent = context._sent = arg;
	
	        } else if (method === "throw") {
	          if (state === GenStateSuspendedStart) {
	            state = GenStateCompleted;
	            throw arg;
	          }
	
	          if (context.dispatchException(arg)) {
	            // If the dispatched exception was caught by a catch block,
	            // then let that catch block handle the exception normally.
	            method = "next";
	            arg = undefined;
	          }
	
	        } else if (method === "return") {
	          context.abrupt("return", arg);
	        }
	
	        state = GenStateExecuting;
	
	        var record = tryCatch(innerFn, self, context);
	        if (record.type === "normal") {
	          // If an exception is thrown from innerFn, we leave state ===
	          // GenStateExecuting and loop back for another invocation.
	          state = context.done
	            ? GenStateCompleted
	            : GenStateSuspendedYield;
	
	          var info = {
	            value: record.arg,
	            done: context.done
	          };
	
	          if (record.arg === ContinueSentinel) {
	            if (context.delegate && method === "next") {
	              // Deliberately forget the last sent value so that we don't
	              // accidentally pass it on to the delegate.
	              arg = undefined;
	            }
	          } else {
	            return info;
	          }
	
	        } else if (record.type === "throw") {
	          state = GenStateCompleted;
	          // Dispatch the exception by looping back around to the
	          // context.dispatchException(arg) call above.
	          method = "throw";
	          arg = record.arg;
	        }
	      }
	    };
	  }
	
	  // Define Generator.prototype.{next,throw,return} in terms of the
	  // unified ._invoke helper method.
	  defineIteratorMethods(Gp);
	
	  Gp[iteratorSymbol] = function() {
	    return this;
	  };
	
	  Gp[toStringTagSymbol] = "Generator";
	
	  Gp.toString = function() {
	    return "[object Generator]";
	  };
	
	  function pushTryEntry(locs) {
	    var entry = { tryLoc: locs[0] };
	
	    if (1 in locs) {
	      entry.catchLoc = locs[1];
	    }
	
	    if (2 in locs) {
	      entry.finallyLoc = locs[2];
	      entry.afterLoc = locs[3];
	    }
	
	    this.tryEntries.push(entry);
	  }
	
	  function resetTryEntry(entry) {
	    var record = entry.completion || {};
	    record.type = "normal";
	    delete record.arg;
	    entry.completion = record;
	  }
	
	  function Context(tryLocsList) {
	    // The root entry object (effectively a try statement without a catch
	    // or a finally block) gives us a place to store values thrown from
	    // locations where there is no enclosing try statement.
	    this.tryEntries = [{ tryLoc: "root" }];
	    tryLocsList.forEach(pushTryEntry, this);
	    this.reset(true);
	  }
	
	  runtime.keys = function(object) {
	    var keys = [];
	    for (var key in object) {
	      keys.push(key);
	    }
	    keys.reverse();
	
	    // Rather than returning an object with a next method, we keep
	    // things simple and return the next function itself.
	    return function next() {
	      while (keys.length) {
	        var key = keys.pop();
	        if (key in object) {
	          next.value = key;
	          next.done = false;
	          return next;
	        }
	      }
	
	      // To avoid creating an additional object, we just hang the .value
	      // and .done properties off the next function object itself. This
	      // also ensures that the minifier will not anonymize the function.
	      next.done = true;
	      return next;
	    };
	  };
	
	  function values(iterable) {
	    if (iterable) {
	      var iteratorMethod = iterable[iteratorSymbol];
	      if (iteratorMethod) {
	        return iteratorMethod.call(iterable);
	      }
	
	      if (typeof iterable.next === "function") {
	        return iterable;
	      }
	
	      if (!isNaN(iterable.length)) {
	        var i = -1, next = function next() {
	          while (++i < iterable.length) {
	            if (hasOwn.call(iterable, i)) {
	              next.value = iterable[i];
	              next.done = false;
	              return next;
	            }
	          }
	
	          next.value = undefined;
	          next.done = true;
	
	          return next;
	        };
	
	        return next.next = next;
	      }
	    }
	
	    // Return an iterator with no values.
	    return { next: doneResult };
	  }
	  runtime.values = values;
	
	  function doneResult() {
	    return { value: undefined, done: true };
	  }
	
	  Context.prototype = {
	    constructor: Context,
	
	    reset: function(skipTempReset) {
	      this.prev = 0;
	      this.next = 0;
	      // Resetting context._sent for legacy support of Babel's
	      // function.sent implementation.
	      this.sent = this._sent = undefined;
	      this.done = false;
	      this.delegate = null;
	
	      this.tryEntries.forEach(resetTryEntry);
	
	      if (!skipTempReset) {
	        for (var name in this) {
	          // Not sure about the optimal order of these conditions:
	          if (name.charAt(0) === "t" &&
	              hasOwn.call(this, name) &&
	              !isNaN(+name.slice(1))) {
	            this[name] = undefined;
	          }
	        }
	      }
	    },
	
	    stop: function() {
	      this.done = true;
	
	      var rootEntry = this.tryEntries[0];
	      var rootRecord = rootEntry.completion;
	      if (rootRecord.type === "throw") {
	        throw rootRecord.arg;
	      }
	
	      return this.rval;
	    },
	
	    dispatchException: function(exception) {
	      if (this.done) {
	        throw exception;
	      }
	
	      var context = this;
	      function handle(loc, caught) {
	        record.type = "throw";
	        record.arg = exception;
	        context.next = loc;
	        return !!caught;
	      }
	
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        var record = entry.completion;
	
	        if (entry.tryLoc === "root") {
	          // Exception thrown outside of any try block that could handle
	          // it, so set the completion value of the entire function to
	          // throw the exception.
	          return handle("end");
	        }
	
	        if (entry.tryLoc <= this.prev) {
	          var hasCatch = hasOwn.call(entry, "catchLoc");
	          var hasFinally = hasOwn.call(entry, "finallyLoc");
	
	          if (hasCatch && hasFinally) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            } else if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }
	
	          } else if (hasCatch) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            }
	
	          } else if (hasFinally) {
	            if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }
	
	          } else {
	            throw new Error("try statement without catch or finally");
	          }
	        }
	      }
	    },
	
	    abrupt: function(type, arg) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc <= this.prev &&
	            hasOwn.call(entry, "finallyLoc") &&
	            this.prev < entry.finallyLoc) {
	          var finallyEntry = entry;
	          break;
	        }
	      }
	
	      if (finallyEntry &&
	          (type === "break" ||
	           type === "continue") &&
	          finallyEntry.tryLoc <= arg &&
	          arg <= finallyEntry.finallyLoc) {
	        // Ignore the finally entry if control is not jumping to a
	        // location outside the try/catch block.
	        finallyEntry = null;
	      }
	
	      var record = finallyEntry ? finallyEntry.completion : {};
	      record.type = type;
	      record.arg = arg;
	
	      if (finallyEntry) {
	        this.next = finallyEntry.finallyLoc;
	      } else {
	        this.complete(record);
	      }
	
	      return ContinueSentinel;
	    },
	
	    complete: function(record, afterLoc) {
	      if (record.type === "throw") {
	        throw record.arg;
	      }
	
	      if (record.type === "break" ||
	          record.type === "continue") {
	        this.next = record.arg;
	      } else if (record.type === "return") {
	        this.rval = record.arg;
	        this.next = "end";
	      } else if (record.type === "normal" && afterLoc) {
	        this.next = afterLoc;
	      }
	    },
	
	    finish: function(finallyLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.finallyLoc === finallyLoc) {
	          this.complete(entry.completion, entry.afterLoc);
	          resetTryEntry(entry);
	          return ContinueSentinel;
	        }
	      }
	    },
	
	    "catch": function(tryLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc === tryLoc) {
	          var record = entry.completion;
	          if (record.type === "throw") {
	            var thrown = record.arg;
	            resetTryEntry(entry);
	          }
	          return thrown;
	        }
	      }
	
	      // The context.catch method must only be called with a location
	      // argument that corresponds to a known catch block.
	      throw new Error("illegal catch attempt");
	    },
	
	    delegateYield: function(iterable, resultName, nextLoc) {
	      this.delegate = {
	        iterator: values(iterable),
	        resultName: resultName,
	        nextLoc: nextLoc
	      };
	
	      return ContinueSentinel;
	    }
	  };
	})(
	  // Among the various tricks for obtaining a reference to the global
	  // object, this seems to be the most reliable technique that does not
	  // use indirect eval (which violates Content Security Policy).
	  typeof global === "object" ? global :
	  typeof window === "object" ? window :
	  typeof self === "object" ? self : this
	);
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(295)))

/***/ },
/* 295 */
/***/ function(module, exports) {

	// shim for using process in browser
	
	var process = module.exports = {};
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = setTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    clearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        setTimeout(drainQueue, 0);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 296 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(297);
	module.exports = __webpack_require__(9).RegExp.escape;

/***/ },
/* 297 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/benjamingr/RexExp.escape
	var $export = __webpack_require__(8)
	  , $re     = __webpack_require__(298)(/[\\^$*+?.()|[\]{}]/g, '\\$&');
	
	$export($export.S, 'RegExp', {escape: function escape(it){ return $re(it); }});


/***/ },
/* 298 */
/***/ function(module, exports) {

	module.exports = function(regExp, replace){
	  var replacer = replace === Object(replace) ? function(part){
	    return replace[part];
	  } : replace;
	  return function(it){
	    return String(it).replace(regExp, replacer);
	  };
	};

/***/ },
/* 299 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.setLogLevel = exports.FailoverSubscriberEventTypes = exports.RTCSubscriberEventTypes = exports.SubscriberEventTypes = exports.FailoverPublisherEventTypes = exports.RTCPublisherEventTypes = exports.PublisherEventTypes = exports.PublisherView = exports.RTCPublisher = exports.RTMPPublisher = exports.Red5ProPublisher = exports.PlaybackView = exports.RTMPSubscriber = exports.R5LiveSubscriber = exports.VideoJSSubscriber = exports.HLSSubscriber = exports.RTCSubscriber = exports.Red5ProSubscriber = exports.getLogger = exports.LogLevels = undefined;
	
	var _log = __webpack_require__(300);
	
	Object.defineProperty(exports, 'LogLevels', {
	  enumerable: true,
	  get: function get() {
	    return _log.LEVELS;
	  }
	});
	Object.defineProperty(exports, 'getLogger', {
	  enumerable: true,
	  get: function get() {
	    return _log.getLogger;
	  }
	});
	
	var _publisherEvent = __webpack_require__(303);
	
	Object.defineProperty(exports, 'PublisherEventTypes', {
	  enumerable: true,
	  get: function get() {
	    return _publisherEvent.common;
	  }
	});
	Object.defineProperty(exports, 'RTCPublisherEventTypes', {
	  enumerable: true,
	  get: function get() {
	    return _publisherEvent.rtc;
	  }
	});
	Object.defineProperty(exports, 'FailoverPublisherEventTypes', {
	  enumerable: true,
	  get: function get() {
	    return _publisherEvent.failover;
	  }
	});
	
	var _subscriberEvent = __webpack_require__(304);
	
	Object.defineProperty(exports, 'SubscriberEventTypes', {
	  enumerable: true,
	  get: function get() {
	    return _subscriberEvent.common;
	  }
	});
	Object.defineProperty(exports, 'RTCSubscriberEventTypes', {
	  enumerable: true,
	  get: function get() {
	    return _subscriberEvent.rtc;
	  }
	});
	Object.defineProperty(exports, 'FailoverSubscriberEventTypes', {
	  enumerable: true,
	  get: function get() {
	    return _subscriberEvent.failover;
	  }
	});
	
	var _index = __webpack_require__(305);
	
	var subscriberLib = _interopRequireWildcard(_index);
	
	var _index2 = __webpack_require__(327);
	
	var publisherLib = _interopRequireWildcard(_index2);
	
	var _playback = __webpack_require__(334);
	
	var _playback2 = _interopRequireDefault(_playback);
	
	var _publish = __webpack_require__(335);
	
	var _publish2 = _interopRequireDefault(_publish);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	/**
	 * Subscription related references.
	*/
	var Red5ProSubscriber = exports.Red5ProSubscriber = subscriberLib.Red5ProSubscriber;
	var RTCSubscriber = exports.RTCSubscriber = subscriberLib.RTCSubscriber;
	var HLSSubscriber = exports.HLSSubscriber = subscriberLib.HLSSubscriber;
	var VideoJSSubscriber = exports.VideoJSSubscriber = subscriberLib.VideoJSSubscriber;
	var R5LiveSubscriber = exports.R5LiveSubscriber = subscriberLib.R5LiveSubscriber;
	var RTMPSubscriber = exports.RTMPSubscriber = subscriberLib.RTMPSubscriber;
	exports.PlaybackView = _playback2.default;
	
	/**
	 * Broadcast related references.
	 */
	
	var Red5ProPublisher = exports.Red5ProPublisher = publisherLib.Red5ProPublisher;
	var RTMPPublisher = exports.RTMPPublisher = publisherLib.RTMPPublisher;
	var RTCPublisher = exports.RTCPublisher = publisherLib.RTCPublisher;
	exports.PublisherView = _publish2.default;
	
	/**
	 * Events
	 */
	
	(0, _log.establishLogger)('' + ("debug") || _log.LEVELS.DEBUG); // eslint-disable-line no-undef
	(0, _log.getLogger)().debug('Red5 Pro SDK Version ' + ("0.5.3")); // eslint-disable-line no-undef
	
	var setLogLevel = exports.setLogLevel = function setLogLevel(level) {
	  if (_log.LEVELS.hasOwnProperty(level.toUpperCase())) {
	    (0, _log.establishLogger)(level);
	  }
	};

/***/ },
/* 300 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.fatal = exports.error = exports.warn = exports.debug = exports.info = exports.trace = exports.getLogger = exports.establishLogger = exports.LEVELS = undefined;
	
	var _browserBunyan = __webpack_require__(301);
	
	var _bunyanWriter = __webpack_require__(302);
	
	var logger = void 0;
	var formatMessage = function formatMessage(dispatcher) {
	  return function (message) {
	    return '(' + dispatcher + ') ' + message;
	  };
	};
	var decorate = function decorate(level) {
	  return function (source, message) {
	    logger[level](formatMessage(source)(message));
	  };
	};
	var LEVELS = exports.LEVELS = {
	  TRACE: 'trace',
	  INFO: 'info',
	  DEBUG: 'debug',
	  WARN: 'warn',
	  ERROR: 'error',
	  FATAL: 'fatal'
	};
	
	var establishLogger = exports.establishLogger = function establishLogger(level) {
	  var streamList = arguments.length <= 1 || arguments[1] === undefined ? undefined : arguments[1];
	
	  var streams = [];
	  streams.push({
	    level: level,
	    stream: new _bunyanWriter.RawStream(),
	    type: 'raw'
	  });
	  if (streamList) {
	    var list = streamList.map(function (item) {
	      item.level = level;
	    });
	    streams = streams.concat(list);
	  }
	  logger = (0, _browserBunyan.createLogger)({
	    level: level,
	    name: 'red5pro-sdk',
	    streams: streams
	  });
	};
	
	var getLogger = exports.getLogger = function getLogger() {
	  return logger;
	};
	
	var trace = exports.trace = decorate(LEVELS.TRACE);
	var info = exports.info = decorate(LEVELS.INFO);
	var debug = exports.debug = decorate(LEVELS.DEBUG);
	var warn = exports.warn = decorate(LEVELS.WARN);
	var error = exports.error = decorate(LEVELS.ERROR);
	var fatal = exports.fatal = decorate(LEVELS.FATAL);

/***/ },
/* 301 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * !This is a stripped down version of Bunyan targeted specifically for the browser
	 *
	 * -------------------------------------------------------------------------------
	 *
	 * Copyright (c) 2014 Trent Mick. All rights reserved.
	 * Copyright (c) 2014 Joyent Inc. All rights reserved.
	 *
	 * The bunyan logging library for node.js.
	 *
	 * -*- mode: js -*-
	 * vim: expandtab:ts=4:sw=4
	 */
	
	'use strict';
	
	var VERSION = '0.2.3';
	
	// Bunyan log format version. This becomes the 'v' field on all log records.
	// `0` is until I release a version '1.0.0' of node-bunyan. Thereafter,
	// starting with `1`, this will be incremented if there is any backward
	// incompatible change to the log record format. Details will be in
	// 'CHANGES.md' (the change log).
	var LOG_VERSION = 0;
	
	//---- Internal support stuff
	
	/**
	 * A shallow copy of an object. Bunyan logging attempts to never cause
	 * exceptions, so this function attempts to handle non-objects gracefully.
	 */
	function objCopy(obj) {
	    if (typeof obj === 'undefined' || obj === null) {  // null or undefined
	        return obj;
	    } else if (Array.isArray(obj)) {
	        return obj.slice();
	    } else if (typeof (obj) === 'object') {
	        var copy = {};
	        Object.keys(obj).forEach(function (k) {
	            copy[k] = obj[k];
	        });
	        return copy;
	    } else {
	        return obj;
	    }
	}
	
	var format = function(f) {
	
	    if(f === null) {
	        return 'null';
	    }
	
	    if(typeof f !== 'string') {
	        return f.toString();
	    }
	    var formatRegExp = /%[sdj%]/g;
	
	    var i = 1;
	    var args = arguments;
	    var len = args.length;
	    var str = String(f).replace(formatRegExp, function(x) {
	        if (x === '%%') {
	            return '%';
	        }
	        if (i >= len) {
	            return x;
	        }
	        switch (x) {
	            case '%s': return String(args[i++]);
	            case '%d': return Number(args[i++]);
	            case '%j':
	                try {
	                    return JSON.stringify(args[i++]);
	                } catch (_) {
	                    return '[Circular]';
	                }
	                break;
	            default:
	                return x;
	        }
	    });
	    for (var x = args[i]; i < len; x = args[++i]) {
	        str += ' ' + x;
	    }
	    return str;
	};
	
	/**
	 * Gather some caller info 3 stack levels up.
	 * See <http://code.google.com/p/v8/wiki/JavaScriptStackTraceApi>.
	 */
	function getCaller3Info() {
	    var obj = {};
	    var saveLimit = Error.stackTraceLimit;
	    var savePrepare = Error.prepareStackTrace;
	    Error.stackTraceLimit = 3;
	    //Error.captureStackTrace(this, getCaller3Info);
	
	    Error.prepareStackTrace = function (_, stack) {
	        var caller = stack[2];
	        obj.file = caller.getFileName();
	        obj.line = caller.getLineNumber();
	        var func = caller.getFunctionName();
	        if (func) {
	            obj.func = func;
	        }
	    };
	    Error.stackTraceLimit = saveLimit;
	    Error.prepareStackTrace = savePrepare;
	    return obj;
	}
	
	
	function _indent(s, indent) {
	    if (!indent) {
	        indent = '    ';
	    }
	    var lines = s.split(/\r?\n/g);
	    return indent + lines.join('\n' + indent);
	}
	
	
	/**
	 * Warn about an bunyan processing error.
	 *
	 * @param msg {String} Message with which to warn.
	 * @param dedupKey {String} Optional. A short string key for this warning to
	 *      have its warning only printed once.
	 */
	function _warn(msg, dedupKey) {
	    if (dedupKey) {
	        if (_warned[dedupKey]) {
	            return;
	        }
	        _warned[dedupKey] = true;
	    }
	    console.error(msg + '\n');
	}
	function _haveWarned(dedupKey) {
	    return _warned[dedupKey];
	}
	var _warned = {};
	
	
	function ConsoleRawStream() {
	}
	ConsoleRawStream.prototype.write = function (rec) {
	    if (rec.level < INFO) {
	        console.log(rec);
	    } else if (rec.level < WARN) {
	        console.info(rec);
	    } else if (rec.level < ERROR) {
	        console.warn(rec);
	    } else {
	        console.error(rec);
	    }
	
	    if(rec.err && rec.err.stack) {
	        console.error(rec.err.stack);
	    }
	};
	
	function ConsoleFormattedStream() {}
	ConsoleFormattedStream.prototype.write = function (rec) {
	
	    var levelCss, defaultCss = 'color: DimGray', msgCss = 'color: SteelBlue';
	
	    if (rec.level < (false)) {
	        levelCss = 'color: DeepPink';
	    } else if (rec.level < INFO) {
	        levelCss = 'color: GoldenRod';
	    } else if (rec.level < WARN) {
	        levelCss = 'color: DarkTurquoise';
	    } else if (rec.level < ERROR) {
	        levelCss = 'color: Purple';
	    } else if (rec.level < FATAL) {
	        levelCss = 'color: Crimson';
	    } else {
	        levelCss = 'color: Black';
	    }
	
	    var loggerName = rec.childName ? rec.name + '/' + rec.childName : rec.name;
	
	    //get level name and pad start with spacs
	    var levelName = nameFromLevel[rec.level].toUpperCase();
	    levelName = Array(6 - levelName.length).join(' ') + levelName;
	
	    function padZeros(number, len) {
	        return Array((len + 1) - (number + '').length).join('0') + number;
	    }
	
	    console.log('[%s:%s:%s:%s] %c%s%c: %s: %c%s',
	        padZeros(rec.time.getHours(), 2), padZeros(rec.time.getMinutes(), 2),
	        padZeros(rec.time.getSeconds(), 2), padZeros(rec.time.getMilliseconds(), 4),
	        levelCss, levelName,
	        defaultCss, loggerName,
	        msgCss, rec.msg);
	    if(rec.err && rec.err.stack) {
	        console.log('%c%s,', levelCss, rec.err.stack);
	    }
	};
	
	//---- Levels
	
	var TRACE = 10;
	var DEBUG = 20;
	var INFO = 30;
	var WARN = 40;
	var ERROR = 50;
	var FATAL = 60;
	
	var levelFromName = {
	    'trace': TRACE,
	    'debug': DEBUG,
	    'info': INFO,
	    'warn': WARN,
	    'error': ERROR,
	    'fatal': FATAL
	};
	var nameFromLevel = {};
	Object.keys(levelFromName).forEach(function (name) {
	    nameFromLevel[levelFromName[name]] = name;
	});
	
	
	/**
	 * Resolve a level number, name (upper or lowercase) to a level number value.
	 *
	 * @api public
	 */
	function resolveLevel(nameOrNum) {
	    var level = (typeof (nameOrNum) === 'string' ? levelFromName[nameOrNum.toLowerCase()] : nameOrNum);
	    return level;
	}
	
	
	//---- Logger class
	
	/**
	 * Create a Logger instance.
	 *
	 * @param options {Object} See documentation for full details. At minimum
	 *    this must include a 'name' string key. Configuration keys:
	 *      - `streams`: specify the logger output streams. This is an array of
	 *        objects with these fields:
	 *          - `type`: The stream type. See README.md for full details.
	 *            Often this is implied by the other fields. Examples are
	 *            'file', 'stream' and "raw".
	 *          - `level`: Defaults to 'info'.
	 *          - `path` or `stream`: The specify the file path or writeable
	 *            stream to which log records are written. E.g.
	 *            `stream: process.stdout`.
	 *          - `closeOnExit` (boolean): Optional. Default is true for a
	 *            'file' stream when `path` is given, false otherwise.
	 *        See README.md for full details.
	 *      - `level`: set the level for a single output stream (cannot be used
	 *        with `streams`)
	 *      - `stream`: the output stream for a logger with just one, e.g.
	 *        `process.stdout` (cannot be used with `streams`)
	 *      - `serializers`: object mapping log record field names to
	 *        serializing functions. See README.md for details.
	 *      - `src`: Boolean (default false). Set true to enable 'src' automatic
	 *        field with log call source info.
	 *    All other keys are log record fields.
	 *
	 * An alternative *internal* call signature is used for creating a child:
	 *    new Logger(<parent logger>, <child options>[, <child opts are simple>]);
	 *
	 * @param _childSimple (Boolean) An assertion that the given `_childOptions`
	 *    (a) only add fields (no config) and (b) no serialization handling is
	 *    required for them. IOW, this is a fast path for frequent child
	 *    creation.
	 */
	function Logger(options, _childOptions, _childSimple) {
	    if (!(this instanceof Logger)) {
	        return new Logger(options, _childOptions);
	    }
	
	    // Input arg validation.
	    var parent;
	    if (_childOptions !== undefined) {
	        parent = options;
	        options = _childOptions;
	        if (!(parent instanceof Logger)) {
	            throw new TypeError(
	                'invalid Logger creation: do not pass a second arg');
	        }
	    }
	    if (!options) {
	        throw new TypeError('options (object) is required');
	    }
	    if (!parent) {
	        if (!options.name) {
	            throw new TypeError('options.name (string) is required');
	        }
	    } else {
	        if (options.name) {
	            throw new TypeError(
	                'invalid options.name: child cannot set logger name');
	        }
	    }
	    if (options.stream && options.streams) {
	        throw new TypeError('cannot mix "streams" and "stream" options');
	    }
	    if (options.streams && !Array.isArray(options.streams)) {
	        throw new TypeError('invalid options.streams: must be an array');
	    }
	    if (options.serializers && (typeof (options.serializers) !== 'object' || Array.isArray(options.serializers))) {
	        throw new TypeError('invalid options.serializers: must be an object');
	    }
	
	    var fields, name, i;
	
	    // Fast path for simple child creation.
	    if (parent && _childSimple) {
	        // `_isSimpleChild` is a signal to stream close handling that this child
	        // owns none of its streams.
	        this._isSimpleChild = true;
	
	        this._level = parent._level;
	        this.streams = parent.streams;
	        this.serializers = parent.serializers;
	        this.src = parent.src;
	        fields = this.fields = {};
	        var parentFieldNames = Object.keys(parent.fields);
	        for (i = 0; i < parentFieldNames.length; i++) {
	            name = parentFieldNames[i];
	            fields[name] = parent.fields[name];
	        }
	        var names = Object.keys(options);
	        for (i = 0; i < names.length; i++) {
	            name = names[i];
	            fields[name] = options[name];
	        }
	        return;
	    }
	
	    // Null values.
	    var self = this;
	    if (parent) {
	        this._level = parent._level;
	        this.streams = [];
	        for (i = 0; i < parent.streams.length; i++) {
	            var s = objCopy(parent.streams[i]);
	            s.closeOnExit = false; // Don't own parent stream.
	            this.streams.push(s);
	        }
	        this.serializers = objCopy(parent.serializers);
	        this.src = parent.src;
	        this.fields = objCopy(parent.fields);
	        if (options.level) {
	            this.level(options.level);
	        }
	    } else {
	        this._level = Number.POSITIVE_INFINITY;
	        this.streams = [];
	        this.serializers = null;
	        this.src = false;
	        this.fields = {};
	    }
	
	    // Handle *config* options (i.e. options that are not just plain data
	    // for log records).
	    if (options.stream) {
	        self.addStream({
	            type: 'stream',
	            stream: options.stream,
	            closeOnExit: false,
	            level: options.level
	        });
	    } else if (options.streams) {
	        options.streams.forEach(function (s) {
	            self.addStream(s, options.level);
	        });
	    } else if (parent && options.level) {
	        this.level(options.level);
	    } else if (!parent) {
	
	        /*
	         * In the browser we'll be emitting to console.log by default.
	         * Any console.log worth its salt these days can nicely render
	         * and introspect objects (e.g. the Firefox and Chrome console)
	         * so let's emit the raw log record. Are there browsers for which
	         * that breaks things?
	         */
	        self.addStream({
	            type: 'raw',
	            stream: new ConsoleRawStream(),
	            closeOnExit: false,
	            level: options.level
	        });
	
	    }
	    if (options.serializers) {
	        self.addSerializers(options.serializers);
	    }
	    if (options.src) {
	        this.src = true;
	    }
	
	    // Fields.
	    // These are the default fields for log records (minus the attributes
	    // removed in this constructor). To allow storing raw log records
	    // (unrendered), `this.fields` must never be mutated. Create a copy for
	    // any changes.
	    fields = objCopy(options);
	    delete fields.stream;
	    delete fields.level;
	    delete fields.streams;
	    delete fields.serializers;
	    delete fields.src;
	    if (this.serializers) {
	        this._applySerializers(fields);
	    }
	    Object.keys(fields).forEach(function (k) {
	        self.fields[k] = fields[k];
	    });
	}
	
	/**
	 * Add a stream
	 *
	 * @param stream {Object}. Object with these fields:
	 *    - `type`: The stream type. See README.md for full details.
	 *      Often this is implied by the other fields. Examples are
	 *      'file', 'stream' and "raw".
	 *    - `path` or `stream`: The specify the file path or writeable
	 *      stream to which log records are written. E.g.
	 *      `stream: process.stdout`.
	 *    - `level`: Optional. Falls back to `defaultLevel`.
	 *    - `closeOnExit` (boolean): Optional. Default is true for a
	 *      'file' stream when `path` is given, false otherwise.
	 *    See README.md for full details.
	 * @param defaultLevel {Number|String} Optional. A level to use if
	 *      `stream.level` is not set. If neither is given, this defaults to INFO.
	 */
	Logger.prototype.addStream = function addStream(s, defaultLevel) {
	    var self = this;
	    if (defaultLevel === null || defaultLevel === undefined) {
	        defaultLevel = INFO;
	    }
	
	    s = objCopy(s);
	
	    // Implicit 'type' from other args.
	    if (!s.type && s.stream) {
	        s.type = 'raw';
	    }
	    s.raw = (s.type === 'raw');  // PERF: Allow for faster check in `_emit`.
	
	    if (s.level) {
	        s.level = resolveLevel(s.level);
	    } else {
	        s.level = resolveLevel(defaultLevel);
	    }
	    if (s.level < self._level) {
	        self._level = s.level;
	    }
	
	    switch (s.type) {
	        case 'stream':
	            if (!s.closeOnExit) {
	                s.closeOnExit = false;
	            }
	            break;
	        case 'raw':
	            if (!s.closeOnExit) {
	                s.closeOnExit = false;
	            }
	            break;
	        default:
	            throw new TypeError('unknown stream type "' + s.type + '"');
	    }
	
	    self.streams.push(s);
	    delete self.haveNonRawStreams;  // reset
	};
	
	
	/**
	 * Add serializers
	 *
	 * @param serializers {Object} Optional. Object mapping log record field names
	 *    to serializing functions. See README.md for details.
	 */
	Logger.prototype.addSerializers = function addSerializers(serializers) {
	    var self = this;
	
	    if (!self.serializers) {
	        self.serializers = {};
	    }
	    Object.keys(serializers).forEach(function (field) {
	        var serializer = serializers[field];
	        if (typeof (serializer) !== 'function') {
	            throw new TypeError(format(
	                'invalid serializer for "%s" field: must be a function',
	                field));
	        } else {
	            self.serializers[field] = serializer;
	        }
	    });
	};
	
	
	/**
	 * Create a child logger, typically to add a few log record fields.
	 *
	 * This can be useful when passing a logger to a sub-component, e.g. a
	 * 'wuzzle' component of your service:
	 *
	 *    var wuzzleLog = log.child({component: 'wuzzle'})
	 *    var wuzzle = new Wuzzle({..., log: wuzzleLog})
	 *
	 * Then log records from the wuzzle code will have the same structure as
	 * the app log, *plus the component='wuzzle' field*.
	 *
	 * @param options {Object} Optional. Set of options to apply to the child.
	 *    All of the same options for a new Logger apply here. Notes:
	 *      - The parent's streams are inherited and cannot be removed in this
	 *        call. Any given `streams` are *added* to the set inherited from
	 *        the parent.
	 *      - The parent's serializers are inherited, though can effectively be
	 *        overwritten by using duplicate keys.
	 *      - Can use `level` to set the level of the streams inherited from
	 *        the parent. The level for the parent is NOT affected.
	 * @param simple {Boolean} Optional. Set to true to assert that `options`
	 *    (a) only add fields (no config) and (b) no serialization handling is
	 *    required for them. IOW, this is a fast path for frequent child
	 *    creation. See 'tools/timechild.js' for numbers.
	 */
	Logger.prototype.child = function (options, simple) {
	    return new (this.constructor)(this, options || {}, simple);
	};
	
	/**
	 * Get/set the level of all streams on this logger.
	 *
	 * Get Usage:
	 *    // Returns the current log level (lowest level of all its streams).
	 *    log.level() -> INFO
	 *
	 * Set Usage:
	 *    log.level(INFO)       // set all streams to level INFO
	 *    log.level('info')     // can use 'info' et al aliases
	 */
	Logger.prototype.level = function level(value) {
	    if (value === undefined) {
	        return this._level;
	    }
	    var newLevel = resolveLevel(value);
	    var len = this.streams.length;
	    for (var i = 0; i < len; i++) {
	        this.streams[i].level = newLevel;
	    }
	    this._level = newLevel;
	};
	
	
	/**
	 * Get/set the level of a particular stream on this logger.
	 *
	 * Get Usage:
	 *    // Returns an array of the levels of each stream.
	 *    log.levels() -> [TRACE, INFO]
	 *
	 *    // Returns a level of the identified stream.
	 *    log.levels(0) -> TRACE      // level of stream at index 0
	 *    log.levels('foo')           // level of stream with name 'foo'
	 *
	 * Set Usage:
	 *    log.levels(0, INFO)         // set level of stream 0 to INFO
	 *    log.levels(0, 'info')       // can use 'info' et al aliases
	 *    log.levels('foo', WARN)     // set stream named 'foo' to WARN
	 *
	 * Stream names: When streams are defined, they can optionally be given
	 * a name. For example,
	 *       log = new Logger({
	 *         streams: [
	 *           {
	 *             name: 'foo',
	 *             path: '/var/log/my-service/foo.log'
	 *             level: 'trace'
	 *           },
	 *         ...
	 *
	 * @param name {String|Number} The stream index or name.
	 * @param value {Number|String} The level value (INFO) or alias ('info').
	 *    If not given, this is a 'get' operation.
	 * @throws {Error} If there is no stream with the given name.
	 */
	Logger.prototype.levels = function levels(name, value) {
	    if (name === undefined) {
	        return this.streams.map(
	            function (s) {
	                return s.level;
	            });
	    }
	    var stream;
	    if (typeof (name) === 'number') {
	        stream = this.streams[name];
	        if (stream === undefined) {
	            throw new Error('invalid stream index: ' + name);
	        }
	    } else {
	        var len = this.streams.length;
	        for (var i = 0; i < len; i++) {
	            var s = this.streams[i];
	            if (s.name === name) {
	                stream = s;
	                break;
	            }
	        }
	        if (!stream) {
	            throw new Error(format('no stream with name "%s"', name));
	        }
	    }
	    if (value === undefined) {
	        return stream.level;
	    } else {
	        var newLevel = resolveLevel(value);
	        stream.level = newLevel;
	        if (newLevel < this._level) {
	            this._level = newLevel;
	        }
	    }
	};
	
	
	/**
	 * Apply registered serializers to the appropriate keys in the given fields.
	 *
	 * Pre-condition: This is only called if there is at least one serializer.
	 *
	 * @param fields (Object) The log record fields.
	 * @param excludeFields (Object) Optional mapping of keys to `true` for
	 *    keys to NOT apply a serializer.
	 */
	Logger.prototype._applySerializers = function (fields, excludeFields) {
	    var self = this;
	
	    // Check each serializer against these (presuming number of serializers
	    // is typically less than number of fields).
	    Object.keys(this.serializers).forEach(function (name) {
	        if (fields[name] === undefined ||
	            (excludeFields && excludeFields[name])) {
	            return;
	        }
	        try {
	            fields[name] = self.serializers[name](fields[name]);
	        } catch (err) {
	            _warn(format('bunyan: ERROR: Exception thrown from the "%s" ' +
	                    'Bunyan serializer. This should never happen. This is a bug' +
	                    'in that serializer function.\n%s',
	                name, err.stack || err));
	            fields[name] = format('(Error in Bunyan log "%s" serializer broke field. See stderr for details.)', name);
	        }
	    });
	};
	
	
	/**
	 * Emit a log record.
	 *
	 * @param rec {log record}
	 * @param noemit {Boolean} Optional. Set to true to skip emission
	 *      and just return the JSON string.
	 */
	Logger.prototype._emit = function (rec, noemit) {
	    var i;
	
	    // Lazily determine if this Logger has non-'raw' streams. If there are
	    // any, then we need to stringify the log record.
	    if (this.haveNonRawStreams === undefined) {
	        this.haveNonRawStreams = false;
	        for (i = 0; i < this.streams.length; i++) {
	            if (!this.streams[i].raw) {
	                this.haveNonRawStreams = true;
	                break;
	            }
	        }
	    }
	
	    // Stringify the object. Attempt to warn/recover on error.
	    var str;
	    if (noemit || this.haveNonRawStreams) {
	        try {
	            str = JSON.stringify(rec, safeCycles()) + '\n';
	        } catch (e) {
	            var dedupKey = e.stack.split(/\n/g, 2).join('\n');
	            _warn('bunyan: ERROR: Exception in ' +
	                    '`JSON.stringify(rec)`. You can install the ' +
	                    '"safe-json-stringify" module to have Bunyan fallback ' +
	                    'to safer stringification. Record:\n' +
	                    _indent(format('%s\n%s', rec, e.stack)),
	                dedupKey);
	            str = format('(Exception in JSON.stringify(rec): %j. See stderr for details.)\n', e.message);
	
	        }
	    }
	
	    if (noemit) {
	        return str;
	    }
	
	
	    var level = rec.level;
	    for (i = 0; i < this.streams.length; i++) {
	        var s = this.streams[i];
	        if (s.level <= level) {
	            s.stream.write(s.raw ? rec : str);
	        }
	    }
	
	    return str;
	};
	
	
	/**
	 * Build a log emitter function for level minLevel. I.e. this is the
	 * creator of `log.info`, `log.error`, etc.
	 */
	function mkLogEmitter(minLevel) {
	    return function () {
	        var log = this;
	
	        function mkRecord(args) {
	            var excludeFields;
	            if (args[0] instanceof Error) {
	                // `log.<level>(err, ...)`
	                fields = {
	                    // Use this Logger's err serializer, if defined.
	                    err: (log.serializers && log.serializers.err ? log.serializers.err(args[0]) : Logger.stdSerializers.err(args[0]))
	                };
	                excludeFields = {err: true};
	                if (args.length === 1) {
	                    msgArgs = [fields.err.message];
	                } else {
	                    msgArgs = Array.prototype.slice.call(args, 1);
	                }
	            } else if (typeof (args[0]) !== 'object' && args[0] !== null ||
	                Array.isArray(args[0])) {
	                // `log.<level>(msg, ...)`
	                fields = null;
	                msgArgs = Array.prototype.slice.call(args);
	            } else {  // `log.<level>(fields, msg, ...)`
	                fields = args[0];
	                msgArgs = Array.prototype.slice.call(args, 1);
	            }
	
	            // Build up the record object.
	            var rec = objCopy(log.fields);
	            rec.level = minLevel;
	            var recFields = (fields ? objCopy(fields) : null);
	            if (recFields) {
	                if (log.serializers) {
	                    log._applySerializers(recFields, excludeFields);
	                }
	                Object.keys(recFields).forEach(function (k) {
	                    rec[k] = recFields[k];
	                });
	            }
	            rec.levelName = nameFromLevel[minLevel];
	            rec.msg = format.apply(log, msgArgs);
	            if (!rec.time) {
	                rec.time = (new Date());
	            }
	            // Get call source info
	            if (log.src && !rec.src) {
	                rec.src = getCaller3Info();
	            }
	            rec.v = LOG_VERSION;
	
	            return rec;
	        }
	
	        var fields = null;
	        var msgArgs = arguments;
	        var rec = null;
	        if (!this._emit) {
	            /*
	             * Show this invalid Bunyan usage warning *once*.
	             *
	             * See <https://github.com/trentm/node-bunyan/issues/100> for
	             * an example of how this can happen.
	             */
	            var dedupKey = 'unbound';
	            if (!_haveWarned[dedupKey]) {
	                var caller = getCaller3Info();
	                _warn(format('bunyan usage error: %s:%s: attempt to log with an unbound log method: `this` is: %s',
	                        caller.file, caller.line, this.toString()),
	                    dedupKey);
	            }
	            return;
	        } else if (arguments.length === 0) {   // `log.<level>()`
	            return (this._level <= minLevel);
	        } else if (this._level > minLevel) {
	            /* pass through */
	        } else {
	            rec = mkRecord(msgArgs);
	            this._emit(rec);
	        }
	    };
	}
	
	
	/**
	 * The functions below log a record at a specific level.
	 *
	 * Usages:
	 *    log.<level>()  -> boolean is-trace-enabled
	 *    log.<level>(<Error> err, [<string> msg, ...])
	 *    log.<level>(<string> msg, ...)
	 *    log.<level>(<object> fields, <string> msg, ...)
	 *
	 * where <level> is the lowercase version of the log level. E.g.:
	 *
	 *    log.info()
	 *
	 * @params fields {Object} Optional set of additional fields to log.
	 * @params msg {String} Log message. This can be followed by additional
	 *    arguments that are handled like
	 *    [util.format](http://nodejs.org/docs/latest/api/all.html#util.format).
	 */
	Logger.prototype.trace = mkLogEmitter(TRACE);
	Logger.prototype.debug = mkLogEmitter(DEBUG);
	Logger.prototype.info = mkLogEmitter(INFO);
	Logger.prototype.warn = mkLogEmitter(WARN);
	Logger.prototype.error = mkLogEmitter(ERROR);
	Logger.prototype.fatal = mkLogEmitter(FATAL);
	
	
	//---- Standard serializers
	// A serializer is a function that serializes a JavaScript object to a
	// JSON representation for logging. There is a standard set of presumed
	// interesting objects in node.js-land.
	
	Logger.stdSerializers = {};
	
	/*
	 * This function dumps long stack traces for exceptions having a cause()
	 * method. The error classes from
	 * [verror](https://github.com/davepacheco/node-verror) and
	 * [restify v2.0](https://github.com/mcavage/node-restify) are examples.
	 *
	 * Based on `dumpException` in
	 * https://github.com/davepacheco/node-extsprintf/blob/master/lib/extsprintf.js
	 */
	function getFullErrorStack(ex) {
	    var ret = ex.stack || ex.toString();
	    if (ex.cause && typeof (ex.cause) === 'function') {
	        var cex = ex.cause();
	        if (cex) {
	            ret += '\nCaused by: ' + getFullErrorStack(cex);
	        }
	    }
	    return (ret);
	}
	
	// Serialize an Error object
	// (Core error properties are enumerable in node 0.4, not in 0.6).
	Logger.stdSerializers.err = function(err) {
	    if (!err || !err.stack) {
	        return err;
	    }
	
	    var obj = {
	        message: err.message,
	        name: err.name,
	        stack: getFullErrorStack(err),
	        code: err.code,
	        signal: err.signal
	    };
	    return obj;
	};
	
	
	// A JSON stringifier that handles cycles safely.
	// Usage: JSON.stringify(obj, safeCycles())
	function safeCycles() {
	    var seen = [];
	    return function (key, val) {
	        if (!val || typeof (val) !== 'object') {
	            return val;
	        }
	        if (seen.indexOf(val) !== -1) {
	            return '[Circular]';
	        }
	        seen.push(val);
	        return val;
	    };
	}
	
	//---- Exports
	
	module.exports = Logger;
	
	module.exports.TRACE = TRACE;
	module.exports.DEBUG = DEBUG;
	module.exports.INFO = INFO;
	module.exports.WARN = WARN;
	module.exports.ERROR = ERROR;
	module.exports.FATAL = FATAL;
	module.exports.resolveLevel = resolveLevel;
	module.exports.levelFromName = levelFromName;
	module.exports.nameFromLevel = nameFromLevel;
	
	module.exports.VERSION = VERSION;
	module.exports.LOG_VERSION = LOG_VERSION;
	
	module.exports.createLogger = function createLogger(options) {
	    return new Logger(options);
	};
	
	// Useful for custom `type == 'raw'` streams that may do JSON stringification
	// of log records themselves. Usage:
	//    var str = JSON.stringify(rec, bunyan.safeCycles());
	module.exports.safeCycles = safeCycles;
	
	//streams
	module.exports.ConsoleFormattedStream = ConsoleFormattedStream;
	module.exports.ConsoleRawStream = ConsoleRawStream;

/***/ },
/* 302 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.RawStream = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _browserBunyan = __webpack_require__(301);
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var RawStream = exports.RawStream = function () {
	  function RawStream() {
	    _classCallCheck(this, RawStream);
	  }
	
	  _createClass(RawStream, [{
	    key: 'write',
	    value: function write(rec) {
	      console.log('[%s] %s: %s',
	      //                rec.time.toISOString(),
	      rec.name, _browserBunyan.nameFromLevel[rec.level], rec.msg);
	    }
	  }]);

	  return RawStream;
	}();

/***/ },
/* 303 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var common = exports.common = Object.freeze({
	  CONNECT_SUCCESS: 'Connect.Success',
	  CONNECT_FAILURE: 'Connect.Failure',
	  PUBLISH_START: 'Publish.Start',
	  PUBLISH_FAIL: 'Publish.Fail',
	  PUBLISH_INVALID_NAME: 'Publish.InvalidName',
	  UNPUBLISH_SUCCESS: 'Unpublish.Success'
	});
	
	var failover = exports.failover = Object.freeze({
	  PUBLISHER_REJECT: 'Publisher.Reject',
	  PUBLISHER_ACCEPT: 'Publisher.Accept'
	});
	
	var rtc = exports.rtc = Object.freeze({
	  MEDIA_STREAM_AVAILABLE: 'WebRTC.MediaStream.Available',
	  PEER_CONNECTION_AVAILABLE: 'WebRTC.PeerConnection.Available',
	  OFFER_START: 'WebRTC.Offer.Start',
	  OFFER_END: 'WebRTC.Offer.End',
	  ICE_TRICKLE_COMPLETE: 'WebRTC.IceTrickle.Complete'
	});
	
	var rtmp = exports.rtmp = Object.freeze({
	  EMBED_SUCCESS: 'FlashPlayer.Embed.Success',
	  EMBED_FAILURE: 'FlashPlayer.Embed.Failure'
	});

/***/ },
/* 304 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var common = exports.common = Object.freeze({
	  CONNECT_SUCCESS: 'Connect.Success',
	  CONNECT_FAILURE: 'Connect.Failure',
	  SUBSCRIBE_START: 'Subscribe.Start',
	  SUBSCRIBE_STOP: 'Subscribe.Stop',
	  SUBSCRIBE_FAIL: 'Subscribe.Fail',
	  SUBSCRIBE_INVALID_NAME: 'Subscribe.InvalidName'
	});
	
	var failover = exports.failover = Object.freeze({
	  SUBSCRIBER_REJECT: 'Subscriber.Reject',
	  SUBSCRIBER_ACCEPT: 'Subscriber.Accept'
	});
	
	var rtc = exports.rtc = Object.freeze({
	  PEER_CONNECTION_AVAILABLE: 'WebRTC.PeerConnection.Available',
	  OFFER_START: 'WebRTC.Offer.Start',
	  OFFER_END: 'WebRTC.Offer.End',
	  ANSWER_START: 'WebRTC.Answer.Start',
	  ANSWER_END: 'WebRTC.Answer.End',
	  CANDIDATE_START: 'WebRTC.Candidate.Start',
	  CANDIDATE_END: 'WebRTC.Candidate.End',
	  ICE_TRICKLE_COMPLETE: 'WebRTC.IceTrickle.Complete'
	});
	
	var rtmp = exports.rtmp = Object.freeze({
	  EMBED_SUCCESS: 'FlashPlayer.Embed.Success',
	  EMBED_FAILURE: 'FlashPlayer.Embed.Failure'
	});

/***/ },
/* 305 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Main entry for failover support of all subscriber implementations.
	 */
	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.RTMPSubscriber = exports.R5LiveSubscriber = exports.VideoJSSubscriber = exports.HLSSubscriber = exports.RTCSubscriber = exports.Red5ProSubscriber = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _eventEmitter = __webpack_require__(306);
	
	var _eventEmitter2 = _interopRequireDefault(_eventEmitter);
	
	var _red5proRtc = __webpack_require__(307);
	
	var _red5proRtc2 = _interopRequireDefault(_red5proRtc);
	
	var _red5proHls = __webpack_require__(317);
	
	var _red5proHls2 = _interopRequireDefault(_red5proHls);
	
	var _red5proRtmp = __webpack_require__(320);
	
	var _red5proRtmp2 = _interopRequireDefault(_red5proRtmp);
	
	var _red5proRtmpLive = __webpack_require__(322);
	
	var _red5proRtmpLive2 = _interopRequireDefault(_red5proRtmpLive);
	
	var _red5proRtmpVideojs = __webpack_require__(321);
	
	var _red5proRtmpVideojs2 = _interopRequireDefault(_red5proRtmpVideojs);
	
	var _implFactoryOrder = __webpack_require__(325);
	
	var _implFactoryOrder2 = _interopRequireDefault(_implFactoryOrder);
	
	var _promise = __webpack_require__(313);
	
	var _playback = __webpack_require__(326);
	
	var _log = __webpack_require__(300);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var NAME = 'R5ProSubscriber';
	var playbackFactory = new _implFactoryOrder2.default();
	
	var playbackImpl = function () {
	  var map = new Map();
	  map.set(_playback.PlaybackTypes.RTMP, _red5proRtmp2.default);
	  map.set(_playback.PlaybackTypes.RTC, _red5proRtc2.default);
	  map.set(_playback.PlaybackTypes.HLS, _red5proHls2.default);
	  return map;
	}();
	
	var Red5ProSubscriber = function (_EventEmitter) {
	  _inherits(Red5ProSubscriber, _EventEmitter);
	
	  function Red5ProSubscriber() {
	    _classCallCheck(this, Red5ProSubscriber);
	
	    // Configuration options
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Red5ProSubscriber).call(this));
	
	    _this._options = undefined;
	    // The playback view
	    _this._view = undefined;
	    // Selected failover subscriber.
	    _this._currentSubscriber = undefined;
	    // Default order.
	    _this._order = [_playback.PlaybackTypes.RTMP, _playback.PlaybackTypes.RTC, _playback.PlaybackTypes.HLS];
	    _this._boundBubbleSubscriberEvent = _this.bubbleSubscriberEvent.bind(_this);
	    return _this;
	  }
	
	  _createClass(Red5ProSubscriber, [{
	    key: 'getPlaybackOrder',
	    value: function getPlaybackOrder() {
	      return this._order;
	    }
	  }, {
	    key: 'setPlaybackOrder',
	    value: function setPlaybackOrder(order) {
	      // Allow for string value to define single item in order.
	      order = typeof order === 'string' ? [order] : order;
	
	      // Filter out values not available in enumeration of playback types.
	      var t = order.filter(function (entry) {
	        var key = void 0;
	        for (key in _playback.PlaybackTypes) {
	          if (_playback.PlaybackTypes[key].toLowerCase() === entry.toLowerCase()) {
	            return true;
	          }
	        }
	        return false;
	      }).map(function (entry) {
	        return entry.toLowerCase();
	      });
	
	      // Define new order.
	      this._order = [].concat(_toConsumableArray(new Set(t)));
	      (0, _log.debug)(NAME, '[orderupdate]: ' + this._order);
	      return this;
	    }
	  }, {
	    key: 'setView',
	    value: function setView(playbackView) {
	      this._view = playbackView;
	      return this;
	    }
	  }, {
	    key: 'getPlaybackFromOrder',
	    value: function getPlaybackFromOrder(order, options) {
	      return playbackFactory.create(order, playbackImpl, options, 'init');
	    }
	  }, {
	    key: 'init',
	    value: function init(options) {
	      var _this2 = this;
	
	      this._options = options;
	      var deferred = new _promise.DeferredPromise();
	      (0, _log.debug)(NAME, '[play]');
	      this.getPlaybackFromOrder(this._order, this._options).then(function (subscriber) {
	        (0, _log.debug)(NAME, '[playsuccess]: subscriber found ' + subscriber.getType());
	        subscriber.on('*', _this2._boundBubbleSubscriberEvent);
	        _this2._currentSubscriber = subscriber;
	        _this2._currentSubscriber.setView(_this2._view);
	        deferred.resolve(_this2._currentSubscriber);
	      }).catch(function (err) {
	        (0, _log.warn)(NAME, '[playerror]: Could not implement a subscriber: ' + err);
	        deferred.reject(err);
	      });
	      return deferred.promise;
	    }
	  }, {
	    key: 'stop',
	    value: function stop() {
	      var _this3 = this;
	
	      var deferred = new _promise.DeferredPromise();
	      if (!this._currentSubscriber) {
	        (0, _log.warn)(NAME, '[stop]: Could not invoke stop() on undefined subscriber.');
	        deferred.reject('A current subscriber is not available to issue a :stop() command to.');
	      } else {
	        (0, _log.debug)(NAME, '[stop]: Invoking stop on held subscriber.');
	        this._currentSubscriber.stop().then(function () {
	          (0, _log.debug)(NAME, '[stopsuccess]');
	          _this3._currentSubscriber.off('*', _this3._boundBubbleSubscriberEvent);
	          _this3._currentSubscriber = undefined;
	          deferred.resolve();
	        }).catch(function (err) {
	          (0, _log.debug)(NAME, '[stoperror]: ' + err);
	          if (_this3._currentSubscriber) {
	            _this3._currentSubscriber.off('*', _this3._boundBubbleSubscriberEvent);
	          }
	          _this3._currentSubscriber = undefined;
	          deferred.reject(err);
	        });
	      }
	      return deferred.promise;
	    }
	  }, {
	    key: 'bubbleSubscriberEvent',
	    value: function bubbleSubscriberEvent(subscriberEvent) {
	      this.trigger.call(this, subscriberEvent);
	    }
	  }, {
	    key: 'playbackTypes',
	    get: function get() {
	      return _playback.PlaybackTypes;
	    }
	  }, {
	    key: 'currentSubscriber',
	    get: function get() {
	      return this._currentSubscriber;
	    }
	  }]);
	
	  return Red5ProSubscriber;
	}(_eventEmitter2.default);
	
	exports.Red5ProSubscriber = Red5ProSubscriber;
	exports.RTCSubscriber = _red5proRtc2.default;
	exports.HLSSubscriber = _red5proHls2.default;
	exports.VideoJSSubscriber = _red5proRtmpVideojs2.default;
	exports.R5LiveSubscriber = _red5proRtmpLive2.default;
	/**
	 * Using the RTMPSubscriber will determine the RTMP-based Subscriber
	 * to be used based on `options.useVideoJS` property.
	 *
	 * If `options.useVideoJS` is left undefined, it will default to `true`
	 * If `options.useVideoJs` is defined, it is required to be a boolean value
	 *
	 * true: VideoJSSubscriber - utilizes the videojs lib and custom SWF.
	 * false: R5LiveSubscriber - utilized the default "live" SWF shipped with Red5 Pro examples.
	*/
	
	var RTMPSubscriber = exports.RTMPSubscriber = _red5proRtmp2.default;

/***/ },
/* 306 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var WILDCARD = '*';
	var WILDCARD_KEY = 'RED5PRO';
	
	var EventEmitter = function () {
	  function EventEmitter() {
	    _classCallCheck(this, EventEmitter);
	
	    this._callbacks = {};
	    this._callbacks[WILDCARD_KEY] = [];
	  }
	
	  _createClass(EventEmitter, [{
	    key: '_notify',
	    value: function _notify(callbacks, event) {
	      var i = void 0,
	          length = callbacks.length;
	      for (i = 0; i < length; i++) {
	        callbacks[i](event);
	      }
	    }
	  }, {
	    key: 'on',
	    value: function on(type, fn) {
	      if (typeof fn !== 'function') {
	        return;
	      }
	
	      if (type === WILDCARD) {
	        this._callbacks[WILDCARD_KEY].push(fn);
	        return;
	      }
	
	      if (this._callbacks[type] === undefined) {
	        this._callbacks[type] = [];
	      }
	
	      if (this._callbacks[type].indexOf(fn) === -1) {
	        this._callbacks[type].push(fn);
	      }
	    }
	  }, {
	    key: 'off',
	    value: function off(type, fn) {
	      var map = this._callbacks[type];
	      if (type === WILDCARD) {
	        map = this._callbacks[WILDCARD_KEY];
	      }
	      if (map) {
	        var index = map.indexOf(fn);
	        if (index !== -1) {
	          map.splice(index, 1);
	        }
	      }
	    }
	  }, {
	    key: 'trigger',
	    value: function trigger(event) {
	      var type = event.type;
	      if (this._callbacks[type]) {
	        this._notify(this._callbacks[type], event);
	      }
	      this._notify(this._callbacks[WILDCARD_KEY], event);
	    }
	  }]);
	
	  return EventEmitter;
	}();
	
	exports.default = EventEmitter;

/***/ },
/* 307 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _eventEmitter = __webpack_require__(306);
	
	var _eventEmitter2 = _interopRequireDefault(_eventEmitter);
	
	var _event = __webpack_require__(308);
	
	var _socketHelperSub = __webpack_require__(309);
	
	var _socketHelperSub2 = _interopRequireDefault(_socketHelperSub);
	
	var _webrtcHelperSub = __webpack_require__(315);
	
	var _webrtcHelperSub2 = _interopRequireDefault(_webrtcHelperSub);
	
	var _promise = __webpack_require__(313);
	
	var _webrtc = __webpack_require__(316);
	
	var webrtc = _interopRequireWildcard(_webrtc);
	
	var _websocket = __webpack_require__(311);
	
	var websocket = _interopRequireWildcard(_websocket);
	
	var _log = __webpack_require__(300);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var NAME = 'R5ProRTCSubscriber';
	var defaultStreamType = 'webrtc';
	var generateSubscriptionId = function generateSubscriptionId() {
	  var id = Math.floor(Math.random() * 0x10000).toString(16);
	  return 'subscriber-' + id;
	};
	var endpointFromOptions = function endpointFromOptions(options) {
	  var protocol = options.wsprotocol || options.protocol;
	  var port = options.wsport || options.port;
	  var appEndpoint = options.context ? [options.app, options.context].join('/') : options.app;
	  return protocol + '://' + options.host + ':' + port + '/' + appEndpoint + '?id=' + options.subscriptionId;
	};
	
	var RTCSubscriber = function (_EventEmitter) {
	  _inherits(RTCSubscriber, _EventEmitter);
	
	  function RTCSubscriber() {
	    _classCallCheck(this, RTCSubscriber);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(RTCSubscriber).call(this));
	
	    _this._view = undefined;
	    _this._options = undefined;
	    _this._peerHelper = undefined;
	    _this._socketHelper = undefined;
	    return _this;
	  }
	
	  _createClass(RTCSubscriber, [{
	    key: 'init',
	    value: function init(options) {
	      var deferred = new _promise.DeferredPromise();
	      if (!webrtc.isSupported() || !websocket.isSupported()) {
	        deferred.reject('Cannot create WebRTC playback instance. Your environment does not support WebRTC and/or WebSockets.');
	      } else {
	        this._options = options;
	        this._options.subscriptionId = this._options.subscriptionId || generateSubscriptionId();
	        this._peerHelper = new _webrtcHelperSub2.default(this);
	        this._socketHelper = new _socketHelperSub2.default(this);
	        deferred.resolve(this);
	      }
	      return deferred.promise;
	    }
	  }, {
	    key: 'setView',
	    value: function setView(view) {
	      this._view = view;
	      //  TODO: Normalize returns to either all be chainable or not be chainable
	      return this;
	    }
	  }, {
	    key: 'requestAvailability',
	    value: function requestAvailability(streamName, type) {
	      (0, _log.debug)(NAME, '[requestavailability]');
	      // message on socket returns -> onStream(Un)Available
	      this._socketHelper.post({
	        isAvailable: streamName,
	        type: type
	      });
	      //  TODO: Normalize returns to either all be chainable or not be chainable
	      return this;
	    }
	  }, {
	    key: 'requestOffer',
	    value: function requestOffer(streamName, subscriptionId) {
	      (0, _log.debug)(NAME, '[requestoffer]');
	      this.trigger(new _event.SubscriberEvent(_event.RTCSubscriberEventTypes.OFFER_START, this));
	      // message on socket returns -> onSDPOffer
	      this._socketHelper.post({
	        requestOffer: streamName,
	        requestId: subscriptionId
	      });
	    }
	  }, {
	    key: 'requestAnswer',
	    value: function requestAnswer(sdp) {
	      var _this2 = this;
	
	      (0, _log.debug)(NAME, '[requestanswer]');
	      // invokes -> sendAnswer
	      this._peerHelper.createAnswer(sdp).then(function (sessionDescription) {
	        (0, _log.debug)(NAME, '[onanswercreated]');
	        if (_this2._options.bandwidth) {
	          sessionDescription.sdp = webrtc.updateBandwidth(_this2._options.bandwidth, sessionDescription.sdp);
	        }
	        (0, _log.debug)(NAME, '[> sendanswer]');
	        _this2.sendAnswer(_this2._options.streamName, _this2._options.subscriptionId, sessionDescription);
	      }).catch(this.onSDPError);
	    }
	  }, {
	    key: 'sendAnswer',
	    value: function sendAnswer(streamName, subscriptionId, sdp) {
	      (0, _log.debug)(NAME, '[sendanswer]: streamname(' + streamName + '), subscriptionid(' + subscriptionId + ')');
	      this.trigger(new _event.SubscriberEvent(_event.RTCSubscriberEventTypes.ANSWER_START, this, sdp));
	      // message on socket response -> onAddIceCandidate
	      // message on peer response -> onaddstream
	      this._socketHelper.post({
	        handleAnswer: streamName,
	        requestId: subscriptionId,
	        data: {
	          sdp: sdp
	        }
	      });
	    }
	  }, {
	    key: 'sendCandidate',
	    value: function sendCandidate(candidate) {
	      (0, _log.debug)(NAME, '[sendcandidate]');
	      this.trigger(new _event.SubscriberEvent(_event.RTCSubscriberEventTypes.CANDIDATE_START, this, candidate));
	      // message on peer response -> onicecandidate
	      this._socketHelper.post({
	        handleCandidate: this._options.streamName,
	        requestId: this._options.subscriptionId,
	        data: {
	          candidate: candidate
	        }
	      });
	    }
	  }, {
	    key: 'sendSubscribe',
	    value: function sendSubscribe() {
	      (0, _log.debug)(NAME, '[sendsubscribe]');
	      this._socketHelper.post({
	        subscribe: this._options.streamName,
	        requestId: this._options.subscriptionId
	      });
	    }
	  }, {
	    key: 'onStreamAvailable',
	    value: function onStreamAvailable(receipt) {
	      (0, _log.debug)(NAME, '[onstreamavailable]: ' + JSON.stringify(receipt, null, 2));
	      this._connect(this._options.iceServers);
	    }
	  }, {
	    key: 'onStreamUnavailable',
	    value: function onStreamUnavailable(receipt) {
	      (0, _log.debug)(NAME, 'Stream ' + this._options.streamName + ' does not exist.');
	      (0, _log.debug)(NAME, '[onstreamunavailable]: ' + JSON.stringify(receipt, null, 2));
	      this.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.SUBSCRIBE_INVALID_NAME, this));
	      this._disconnect();
	    }
	  }, {
	    key: 'onSDPSuccess',
	    value: function onSDPSuccess(receipt) {
	      (0, _log.debug)(NAME, '[onsdpsuccess]: ' + JSON.stringify(receipt, null, 2));
	    }
	  }, {
	    key: 'onSDPOffer',
	    value: function onSDPOffer(receipt) {
	      (0, _log.debug)(NAME, '[onsdpoffer]: ' + JSON.stringify(receipt, null, 2));
	      var sdp = new webrtc.RTCSessionDescription(receipt.sdp);
	      this.trigger(new _event.SubscriberEvent(_event.RTCSubscriberEventTypes.OFFER_END, this));
	      this.requestAnswer(sdp);
	    }
	  }, {
	    key: 'onSDPError',
	    value: function onSDPError(receipt) {
	      (0, _log.error)(NAME, '[onsdperror]: ' + JSON.stringify(receipt, null, 2));
	      this.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.SUBSCRIBE_FAIL, this, receipt));
	    }
	  }, {
	    key: 'onAnswerMediaStream',
	    value: function onAnswerMediaStream() {
	      var stream = arguments.length <= 0 || arguments[0] === undefined ? undefined : arguments[0];
	      // eslint-disable-line no-unused-vars
	      this.trigger(new _event.SubscriberEvent(_event.RTCSubscriberEventTypes.ANSWER_END, this));
	    }
	  }, {
	    key: 'onIceCandidate',
	    value: function onIceCandidate(candidate) {
	      (0, _log.debug)(NAME, '[onicecandidate]');
	      this.trigger(new _event.SubscriberEvent(_event.RTCSubscriberEventTypes.CANDIDATE_END, this));
	      this.sendCandidate(candidate);
	    }
	  }, {
	    key: 'onIceCandidateTrickleEnd',
	    value: function onIceCandidateTrickleEnd(stream) {
	      (0, _log.debug)(NAME, '[onicetrickleend]');
	      this._view.attachStream(stream, this._options.autoplay || true);
	      this.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.SUBSCRIBE_START, this));
	    }
	  }, {
	    key: 'onAddIceCandidate',
	    value: function onAddIceCandidate(candidate) {
	      (0, _log.debug)(NAME, '[onaddicecandidate]');
	      this._peerHelper.addIceCandidate(candidate);
	    }
	  }, {
	    key: 'onSocketIceCandidateEnd',
	    value: function onSocketIceCandidateEnd() {
	      (0, _log.debug)(NAME, '[onsocketicecandidateend]');
	      this.trigger(new _event.SubscriberEvent(_event.RTCSubscriberEventTypes.ICE_TRICKLE_COMPLETE, this));
	      this.sendSubscribe();
	    }
	  }, {
	    key: 'onSocketMessageError',
	    value: function onSocketMessageError(message) {
	      var detail = arguments.length <= 1 || arguments[1] === undefined ? undefined : arguments[1];
	
	      (0, _log.error)(NAME, 'Error in stream subscription: ' + message + '.\n[Optional detail]: ' + detail);
	      this.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.SUBSCRIBE_FAIL, this, message));
	    }
	  }, {
	    key: '_disconnect',
	    value: function _disconnect() {
	      (0, _log.debug)(NAME, '[disconnect]');
	      if (this._socketHelper) {
	        this._socketHelper.tearDown();
	      }
	      if (this._peerHelper) {
	        this._peerHelper.tearDown();
	      }
	    }
	  }, {
	    key: '_connect',
	    value: function _connect(iceServers) {
	      var _this3 = this;
	
	      (0, _log.debug)(NAME, '[connect]');
	      this._options.iceServers = iceServers;
	      var p = this._peerHelper.setUp(this._options.iceServers);
	      p.then(function () {
	        _this3.requestOffer(_this3._options.streamName, _this3._options.subscriptionId);
	      }).catch(function () {
	        (0, _log.warn)(NAME, 'Could not establish RTCPeerConnection.');
	        _this3.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.CONNECT_FAILURE, _this3));
	      });
	      //  TODO: Normalize returns to either all be chainable or not be chainable
	      return this;
	    }
	  }, {
	    key: 'play',
	    value: function play() {
	      var _this4 = this;
	
	      var streamName = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
	      var promise = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	
	      (0, _log.debug)(NAME, '[play]');
	      this._options.streamName = streamName || this._options.streamName;
	      var p = promise || new _promise.DeferredPromise();
	      var socketPromise = new _promise.DeferredPromise();
	      var socketurl = endpointFromOptions(this._options);
	      this._socketHelper.setUp(socketurl, socketPromise);
	      socketPromise.promise.then(function () {
	        p.resolve(_this4);
	        _this4.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.CONNECT_SUCCESS, _this4));
	        _this4.requestAvailability(_this4._options.streamName, _this4._options.streamType || defaultStreamType);
	      }).catch(function (error) {
	        p.reject(error);
	        _this4.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.CONNECT_FAILURE, _this4, error));
	      });
	      return p.hasOwnProperty('promise') ? p.promise : p;
	    }
	  }, {
	    key: 'stop',
	    value: function stop() {
	      (0, _log.debug)(NAME, '[stop]');
	      var deferred = new _promise.DeferredPromise();
	      this._disconnect();
	      this._view.stop();
	      deferred.resolve(this);
	      this.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.UNSUBSCRIBE_SUCCESS, this));
	      return deferred.promise;
	    }
	  }, {
	    key: 'getPeerConnection',
	    value: function getPeerConnection() {
	      return this._peerHelper ? this._peerHelper.connection : undefined;
	    }
	  }, {
	    key: 'getType',
	    value: function getType() {
	      return 'RTC';
	    }
	  }]);
	
	  return RTCSubscriber;
	}(_eventEmitter2.default);
	
	exports.default = RTCSubscriber;

/***/ },
/* 308 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _publisherEvent = __webpack_require__(303);
	
	Object.defineProperty(exports, 'PublisherEventTypes', {
	  enumerable: true,
	  get: function get() {
	    return _publisherEvent.common;
	  }
	});
	Object.defineProperty(exports, 'RTCPublisherEventTypes', {
	  enumerable: true,
	  get: function get() {
	    return _publisherEvent.rtc;
	  }
	});
	Object.defineProperty(exports, 'RTMPPublisherEventTypes', {
	  enumerable: true,
	  get: function get() {
	    return _publisherEvent.rtmp;
	  }
	});
	Object.defineProperty(exports, 'FailoverPublisherEventTypes', {
	  enumerable: true,
	  get: function get() {
	    return _publisherEvent.failover;
	  }
	});
	
	var _subscriberEvent = __webpack_require__(304);
	
	Object.defineProperty(exports, 'SubscriberEventTypes', {
	  enumerable: true,
	  get: function get() {
	    return _subscriberEvent.common;
	  }
	});
	Object.defineProperty(exports, 'RTCSubscriberEventTypes', {
	  enumerable: true,
	  get: function get() {
	    return _subscriberEvent.rtc;
	  }
	});
	Object.defineProperty(exports, 'RTMPSubscriberEventTypes', {
	  enumerable: true,
	  get: function get() {
	    return _subscriberEvent.rtmp;
	  }
	});
	Object.defineProperty(exports, 'FailoverSubscriberEventTypes', {
	  enumerable: true,
	  get: function get() {
	    return _subscriberEvent.failover;
	  }
	});
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var Event = function () {
	  function Event(type) {
	    var data = arguments.length <= 1 || arguments[1] === undefined ? undefined : arguments[1];
	
	    _classCallCheck(this, Event);
	
	    this._type = type;
	    this._data = data;
	  }
	
	  _createClass(Event, [{
	    key: 'type',
	    get: function get() {
	      return this._type;
	    }
	  }, {
	    key: 'data',
	    get: function get() {
	      return this._data;
	    }
	  }]);
	
	  return Event;
	}();
	
	var PublisherEvent = function (_Event) {
	  _inherits(PublisherEvent, _Event);
	
	  function PublisherEvent(type, publisher, data) {
	    _classCallCheck(this, PublisherEvent);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(PublisherEvent).call(this, type, data));
	
	    _this._publisher = publisher;
	    return _this;
	  }
	
	  _createClass(PublisherEvent, [{
	    key: 'publisher',
	    get: function get() {
	      return this._publisher;
	    }
	  }]);
	
	  return PublisherEvent;
	}(Event);
	
	var SubscriberEvent = function (_Event2) {
	  _inherits(SubscriberEvent, _Event2);
	
	  function SubscriberEvent(type, subscriber, data) {
	    _classCallCheck(this, SubscriberEvent);
	
	    var _this2 = _possibleConstructorReturn(this, Object.getPrototypeOf(SubscriberEvent).call(this, type, data));
	
	    _this2._subscriber = subscriber;
	    return _this2;
	  }
	
	  _createClass(SubscriberEvent, [{
	    key: 'subscriber',
	    get: function get() {
	      return this._subscriber;
	    }
	  }]);
	
	  return SubscriberEvent;
	}(Event);
	
	exports.PublisherEvent = PublisherEvent;
	exports.SubscriberEvent = SubscriberEvent;

/***/ },
/* 309 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _socketHelper = __webpack_require__(310);
	
	var _socketHelper2 = _interopRequireDefault(_socketHelper);
	
	var _log = __webpack_require__(300);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var NAME = 'R5ProSubscriptionSocket';
	
	var SubscriptionSocketHelper = function (_SocketHelper) {
	  _inherits(SubscriptionSocketHelper, _SocketHelper);
	
	  function SubscriptionSocketHelper(responder) {
	    _classCallCheck(this, SubscriptionSocketHelper);
	
	    return _possibleConstructorReturn(this, Object.getPrototypeOf(SubscriptionSocketHelper).call(this, responder, NAME));
	  }
	
	  _createClass(SubscriptionSocketHelper, [{
	    key: 'respond',
	    value: function respond(message) {
	      //    console.log(message)
	      if (message.data) {
	        var json = this.getJsonFromSocketMessage(message);
	        try {
	          if (!_get(Object.getPrototypeOf(SubscriptionSocketHelper.prototype), 'respond', this).call(this, message)) {
	            if (json.data !== undefined) {
	              if (json.data.sdp !== undefined) {
	                if (json.data.sdp.type === 'offer') {
	                  this._responder.onSDPOffer(json.data);
	                }
	              }
	              if (json.data.candidate !== undefined) {
	                this._responder.onAddIceCandidate(json.data.candidate);
	              }
	              if (json.data.type === 'status') {
	                if (json.data.code === 'NetConnection.ICE.TricleCompleted') {
	                  this._responder.onSocketIceCandidateEnd();
	                }
	              }
	            }
	          }
	        } catch (e) {
	          (0, _log.error)(NAME, '[ws.onmessage] - Error in accessing message data as JSON. ' + e.message);
	          this._responder.onSocketMessageError('[ws.onmessage] - Error in accessing message data as JSON. ' + e.message);
	        }
	      } else {
	        (0, _log.warn)(NAME, '[ws.onmessage] - No Message Data.');
	      }
	    }
	  }]);
	
	  return SubscriptionSocketHelper;
	}(_socketHelper2.default);
	
	exports.default = SubscriptionSocketHelper;

/***/ },
/* 310 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _websocket = __webpack_require__(311);
	
	var websocket = _interopRequireWildcard(_websocket);
	
	var _browser = __webpack_require__(312);
	
	var _browser2 = _interopRequireDefault(_browser);
	
	var _log = __webpack_require__(300);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var SocketHelper = function () {
	  function SocketHelper(responder, name) {
	    _classCallCheck(this, SocketHelper);
	
	    this._responder = responder;
	    this._pendingPostRequests = [];
	    this._websocket = undefined;
	    this._name = name;
	    this._onclose = this.tearDown.bind(this);
	  }
	
	  _createClass(SocketHelper, [{
	    key: '_removeSocketHandlers',
	    value: function _removeSocketHandlers(ws) {
	      ws.onopen = undefined;
	      ws.onmessage = undefined;
	      ws.onerror = undefined;
	    }
	  }, {
	    key: '_addSocketHandlers',
	    value: function _addSocketHandlers(ws, promise) {
	      var _this = this;
	
	      ws.onopen = function () {
	        (0, _log.info)(_this._name, '[websocketopen]');
	        while (_this._pendingPostRequests.length > 0) {
	          _this.post(_this._pendingPostRequests.shift());
	        }
	        promise.resolve();
	      };
	
	      ws.onerror = function (error) {
	        (0, _log.warn)(_this._name, '[websocketerror]: Error from WebSocket. ' + error.type);
	        promise.reject(error);
	      };
	
	      ws.onmessage = function (message) {
	        _this.respond(message);
	      };
	    }
	  }, {
	    key: 'setUp',
	    value: function setUp(url, setupPromise) {
	      this.tearDown();
	      this._websocket = websocket.create(url);
	      this._addSocketHandlers(this._websocket, setupPromise);
	      _browser2.default.addCloseHandler(this._onclose);
	    }
	  }, {
	    key: 'tearDown',
	    value: function tearDown() {
	      this._pendingPostRequests.length = 0;
	      if (typeof this._websocket !== 'undefined') {
	        this._removeSocketHandlers(this._websocket);
	        this._websocket.close();
	      }
	      this._websocket = undefined;
	      _browser2.default.removeCloseHandler(this._onclose);
	    }
	  }, {
	    key: 'getJsonFromSocketMessage',
	    value: function getJsonFromSocketMessage(message) {
	      return typeof message.data === 'string' ? JSON.parse(message.data) : message.data;
	    }
	  }, {
	    key: 'post',
	    value: function post(sendRequest) {
	      if (this._websocket !== undefined && this._websocket.readyState === 1 /* WebSocket.OPEN */) {
	          try {
	            (0, _log.debug)(this._name, '[websocket-post]: ' + JSON.stringify(sendRequest, null, 2));
	            this._websocket.send(JSON.stringify(sendRequest));
	          } catch (e) {
	            (0, _log.debug)(this._name, 'Could not send request: ' + sendRequest + '. ' + e);
	          }
	        } else {
	        this._pendingPostRequests.push(sendRequest);
	      }
	    }
	  }, {
	    key: 'respond',
	    value: function respond(message) {
	      // eslint-disable-line no-unused-vars
	      if (message.data) {
	        var json = this.getJsonFromSocketMessage(message);
	        (0, _log.debug)(this._name, '[websocket-response]: ' + JSON.stringify(json, null, 2));
	        if (json.isAvailable !== undefined) {
	          if (typeof json.isAvailable === 'boolean' && json.isAvailable) {
	            this._responder.onStreamAvailable(json);
	            return true;
	          } else {
	            this._responder.onStreamUnavailable(json);
	            return true;
	          }
	        } else if (json.data !== undefined) {
	          if (json.data.message !== undefined) {
	            if (json.data.type === 'error') {
	              this._responder.onSocketMessageError(json.data.message, json.data.detail);
	              return true;
	            }
	          }
	        }
	      }
	      return false;
	    }
	  }]);
	
	  return SocketHelper;
	}();
	
	exports.default = SocketHelper;

/***/ },
/* 311 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.create = exports.isSupported = undefined;
	
	var _browser = __webpack_require__(312);
	
	var _browser2 = _interopRequireDefault(_browser);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var isSupported = exports.isSupported = function isSupported() {
	  return _browser2.default.supportsWebSocket();
	};
	
	var create = exports.create = function create(url) {
	  return _browser2.default.createWebSocket(url);
	};

/***/ },
/* 312 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _promise = __webpack_require__(313);
	
	var _errors = __webpack_require__(314);
	
	var closeHandlers = new Set();
	function onwindowclose() {
	  closeHandlers.forEach(function (h) {
	    return h();
	  });
	}
	
	// https://github.com/videojs/video.js/blob/master/src/js/tech/flash.js#L476
	var flashVersion = function flashVersion() {
	  var version = '0,0,0';
	  // IE
	  try {
	    version = new window.ActiveXObject('ShockwaveFlash.ShockwaveFlash').GetVariable('$version').replace(/\D+/g, ',').match(/^,?(.+),?$/)[1];
	
	    // other browsers
	  } catch (e) {
	    try {
	      if (navigator.mimeTypes['application/x-shockwave-flash'].enabledPlugin) {
	        version = (navigator.plugins['Shockwave Flash 2.0'] || navigator.plugins['Shockwave Flash']).description.replace(/\D+/g, ',').match(/^,?(.+),?$/)[1];
	      }
	    } catch (err) {
	      // nada
	    }
	  }
	  return version.split(',');
	};
	
	var isMoz = !!navigator.mozGetUserMedia;
	navigator.getUserMedia = navigator.getUserMedia || navigator.mozGetUserMedia || navigator.webkitGetUserMedia || navigator.msGetUserMedia;
	
	var defaultUserMediaAudio = isMoz ? true : {
	  manditory: {
	    googAutoGainControl: true,
	    googHighpassFilter: true,
	    googEchoCancellation: true,
	    googNoiseSuppression: true
	  },
	  optional: [{
	    bandwidth: 50
	  }, {
	    echoCancellation: true
	  }]
	};
	var defaultUserMediaVideo = isMoz ? true : {
	  mandatory: {
	    minWidth: 320,
	    minHeight: 240,
	    minFrameRate: 4,
	    maxWidth: 640,
	    maxHeight: 480,
	    maxFrameRate: 24
	  },
	  optional: [{
	    bandwidth: 256
	  }]
	};
	
	exports.default = {
	  supportsWebSocket: function supportsWebSocket() {
	    return !!window.WebSocket;
	  },
	
	  supportsFlashVersion: function supportsFlashVersion(version) {
	    var delimiter = arguments.length <= 1 || arguments[1] === undefined ? '.' : arguments[1];
	
	    return flashVersion()[0] >= version.split(delimiter)[0];
	  },
	
	  resolveElement: function resolveElement(id) {
	    try {
	      var el = document.getElementById(id);
	      if (!el) {
	        throw new _errors.NoElementFoundError('Element with id(' + id + ') could not be found.');
	      }
	      return el;
	    } catch (e) {
	      throw new _errors.NoElementFoundError('Error in accessing element with id(' + id + '). ' + e.message);
	    }
	  },
	
	  createWebSocket: function createWebSocket(url) {
	    return new window.WebSocket(url);
	  },
	
	  setVideoSource: function setVideoSource(videoElement, mediaStream) {
	    var autoplay = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];
	
	    if (isMoz) {
	      videoElement['mozSrcObject'] = mediaStream;
	    } else {
	      videoElement.src = window.URL.createObjectURL(mediaStream);
	    }
	    if (autoplay) {
	      videoElement.play();
	    }
	  },
	
	  injectScript: function injectScript(url) {
	    var dfd = new _promise.DeferredPromise();
	    var script = document.createElement('script');
	    script.type = 'text/javascript';
	    script.onload = function () {
	      dfd.resolve();
	    };
	    script.onreadystatechange = function () {
	      if (script.readyState === 'loaded' || script.readyState === 'complete') {
	        script.onreadystatechange = null;
	        dfd.resolve();
	      }
	    };
	    script.src = url;
	    document.getElementsByTagName('head')[0].appendChild(script);
	    return dfd.promise;
	  },
	
	  getSwfObject: function getSwfObject() {
	    return window.swfobject;
	  },
	
	  getEmbedObject: function getEmbedObject(id) {
	    return document.getElementById(id);
	  },
	
	  getVideoJs: function getVideoJs() {
	    return window.videojs;
	  },
	
	  getUserMedia: function getUserMedia() {
	    var audio = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
	    var video = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	
	    var deferred = new _promise.DeferredPromise();
	    navigator.getUserMedia({
	      audio: audio || defaultUserMediaAudio,
	      video: video || defaultUserMediaVideo
	    }, deferred.resolve, deferred.reject);
	    return deferred.promise;
	  },
	
	  getDefaultPublishConstraints: function getDefaultPublishConstraints() {
	    var audio = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];
	    var video = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
	
	    if (isMoz) {
	      return {
	        offerToReceiveVideo: video,
	        offerToReceiveAudio: audio
	      };
	    }
	    return {
	      mandatory: {
	        offerToReceiveVideo: video,
	        offerToReceiveAudio: audio
	      }
	    };
	  },
	
	  getIsMoz: function getIsMoz() {
	    return isMoz;
	  },
	
	  addCloseHandler: function addCloseHandler(handler) {
	    closeHandlers.add(handler);
	    if (window.onbeforeunload !== onwindowclose) {
	      window.onbeforeunload = onwindowclose;
	    }
	  },
	
	  removeCloseHandler: function removeCloseHandler(handler) {
	    if (closeHandlers.has(handler)) {
	      closeHandlers.delete(handler);
	    }
	  }
	
	};

/***/ },
/* 313 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var _DeferredPromise = function _DeferredPromise() {
	  var _this = this;
	
	  _classCallCheck(this, _DeferredPromise);
	
	  this.resolve = undefined;
	  this.reject = undefined;
	  this.promise = new Promise(function (resolve, reject) {
	    _this.resolve = resolve;
	    _this.reject = reject;
	  });
	};
	
	var _Future = {
	  createIfNotExist: function createIfNotExist(deferredIfExist) {
	    var f = deferredIfExist;
	    if (!f) {
	      f = new _DeferredPromise();
	    }
	    return f;
	  }
	};
	
	var DeferredPromise = exports.DeferredPromise = _DeferredPromise;
	var Future = exports.Future = _Future;

/***/ },
/* 314 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var NoElementFoundError = exports.NoElementFoundError = function NoElementFoundError(message) {
	  _classCallCheck(this, NoElementFoundError);
	
	  this.name = 'NoElementFound';
	  this.message = message;
	};

/***/ },
/* 315 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _webrtc = __webpack_require__(316);
	
	var webrtc = _interopRequireWildcard(_webrtc);
	
	var _promise = __webpack_require__(313);
	
	var _log = __webpack_require__(300);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var NAME = 'R5ProSubscriptionPeer';
	
	var SubscriptionPeerHelper = function () {
	  function SubscriptionPeerHelper(responder) {
	    _classCallCheck(this, SubscriptionPeerHelper);
	
	    this._responder = responder;
	    this._peerConnection = undefined;
	    this._pendingMediaStream = undefined;
	  }
	
	  _createClass(SubscriptionPeerHelper, [{
	    key: '_removeConnectionHandlers',
	    value: function _removeConnectionHandlers(connection) {
	      connection.onconnectionstatechange = undefined;
	      connection.onicecandidate = undefined;
	      connection.onaddstream = undefined;
	      connection.ontrack = undefined;
	    }
	  }, {
	    key: '_addConnectionHandlers',
	    value: function _addConnectionHandlers(connection, promise) {
	      var _this = this;
	
	      connection.onconnectionstatechange = function () {
	        if (connection.connectionState === 'connected') {
	          (0, _log.debug)(NAME, '[peerconnection:open]');
	          if (promise) {
	            promise.resolve(_this);
	          }
	        } else if (connection.connectionState === 'failed' || connection.connectionState === 'disconnected') {
	          (0, _log.warn)(NAME, '[peerconnection:error]');
	          if (promise) {
	            promise.reject();
	          }
	        }
	      };
	
	      connection.onicecandidate = function (event) {
	        (0, _log.debug)(NAME, '[peer.onicecandidate] - Peer Candidate: ' + event.candidate);
	        if (event.candidate) {
	          _this._responder.onIceCandidate(event.candidate);
	        } else if (event.candidate === null) {
	          // null means they have finished sending candidates back and forth?
	          _this._responder.onIceCandidateTrickleEnd(_this._pendingMediaStream);
	          _this._pendingMediaStream = undefined;
	        }
	      };
	
	      connection.onaddstream = function (event) {
	        (0, _log.debug)(NAME, 'Peer Add Stream: ' + event.stream);
	        if (event.stream) {
	          _this._pendingMediaStream = event.stream;
	          _this._responder.onAnswerMediaStream(event.stream);
	        }
	      };
	
	      connection.ontrack = function (event) {
	        (0, _log.debug)(NAME, 'Peer Add Stream: ' + event.streams);
	        if (event.streams && event.streams.length > 0) {
	          _this._pendingMediaStream = event.streams[0];
	        }
	      };
	    }
	  }, {
	    key: 'setUp',
	    value: function setUp(iceServers, setUpPromise) {
	      this.tearDown();
	      (0, _log.debug)(NAME, '[setup]');
	      var p = setUpPromise || new _promise.DeferredPromise();
	      try {
	        var peer = new webrtc.RTCPeerConnection({
	          iceServers: iceServers
	        }, {
	          optional: [{ DtlsSrtpKeyAgreement: true }, { RtpDataChannels: false }, { googCpuOveruseDetection: true }]
	        });
	        this._peerConnection = peer;
	        this._addConnectionHandlers(peer);
	        p.resolve();
	      } catch (e) {
	        (0, _log.warn)(NAME, 'Could not create a RTCPeerConnection. Error: ' + e.message);
	        p.reject(e.message);
	      }
	      return p.hasOwnProperty('promise') ? p.promise : p;
	    }
	  }, {
	    key: 'tearDown',
	    value: function tearDown() {
	      (0, _log.debug)(NAME, '[teardown]');
	      if (this._peerConnection) {
	        this._removeConnectionHandlers(this._peerConnection);
	        try {
	          this._peerConnection.close();
	        } catch (e) {
	          (0, _log.warn)(NAME, '[peerconnection.close] error: ' + e.message);
	        }
	      }
	      this._pendingMediaStream = undefined;
	      this._peerConnection = undefined;
	    }
	  }, {
	    key: 'createAnswer',
	    value: function createAnswer(sdp) {
	      var _this2 = this;
	
	      (0, _log.debug)(NAME, '[createanswer]');
	      var deferred = new _promise.DeferredPromise();
	
	      this._peerConnection.setRemoteDescription(sdp).then(this._responder.onSDPSuccess).catch(this._responder.onSDPError);
	
	      this._peerConnection.createAnswer().then(function (sessionDescription) {
	        _this2._peerConnection.setLocalDescription(sessionDescription).then(_this2._responder.onSDPSuccess).catch(_this2._responder.onSDPError);
	        deferred.resolve(sessionDescription);
	      }).catch(deferred.reject);
	
	      return deferred.promise;
	    }
	  }, {
	    key: 'addIceCandidate',
	    value: function addIceCandidate(candidate) {
	      (0, _log.debug)(NAME, '[addicecandidate]');
	      var iceCandidate = new webrtc.RTCIceCandidate({
	        sdpMLineIndex: candidate.sdpMLineIndex,
	        candidate: candidate.candidate
	      });
	      this._peerConnection.addIceCandidate(iceCandidate).then(function () {
	        // nada
	      }).catch(function (err) {
	        (0, _log.error)(NAME, 'Error in add of ICE Candidiate + ' + err);
	      });
	    }
	  }, {
	    key: 'connection',
	    get: function get() {
	      return this._peerConnection;
	    }
	  }]);
	
	  return SubscriptionPeerHelper;
	}();
	
	exports.default = SubscriptionPeerHelper;

/***/ },
/* 316 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.RTCSessionDescription = exports.RTCIceCandidate = exports.RTCPeerConnection = exports.updateBandwidth = exports.isSupported = undefined;
	
	var _browser = __webpack_require__(312);
	
	var _browser2 = _interopRequireDefault(_browser);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/** -- handled by adapter.js -- */
	var _RTCPeerConnection = window.RTCPeerConnection || window.mozRTCPeerConnection || window.webkitRTCPeerConnection;
	var _RTCIceCandidate = window.RTCIceCandidate || window.mozRTCIceCandidate || window.webkitRTCIceCandidate;
	var _RTCSessionDescription = window.RTCSessionDescription || window.mozRTCSessionDescription || window.webkitRTCSessionDescription;
	
	var isSupported = exports.isSupported = function isSupported() {
	  return _RTCPeerConnection && _RTCIceCandidate && _RTCSessionDescription;
	};
	
	// https://github.com/muaz-khan/WebRTC-Experiment/blob/master/RTCPeerConnection/RTCPeerConnection-v1.6.js#L158
	// Muaz Khan     - github.com/muaz-khan
	// MIT License   - www.WebRTC-Experiment.com/licence
	// Documentation - github.com/muaz-khan/WebRTC-Experiment/tree/master/RTCPeerConnection
	var updateBandwidth = exports.updateBandwidth = function updateBandwidth(options, sdp) {
	  if (_browser2.default.getIsMoz()) {
	    return sdp;
	  }
	  sdp = sdp.replace(/b=AS([^\r\n]+\r\n)/g, '');
	  if (options.audio) {
	    sdp = sdp.replace(/a=mid:audio\r\n/g, 'a=mid:audio\r\nb=AS:' + options.audio + '\r\n');
	  }
	  if (options.video) {
	    sdp = sdp.replace(/a=mid:video\r\n/g, 'a=mid:video\r\nb=AS:' + options.video + '\r\n');
	  }
	  return sdp;
	};
	
	var RTCPeerConnection = exports.RTCPeerConnection = _RTCPeerConnection;
	var RTCIceCandidate = exports.RTCIceCandidate = _RTCIceCandidate;
	var RTCSessionDescription = exports.RTCSessionDescription = _RTCSessionDescription;

/***/ },
/* 317 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _eventEmitter = __webpack_require__(306);
	
	var _eventEmitter2 = _interopRequireDefault(_eventEmitter);
	
	var _event = __webpack_require__(308);
	
	var _browser = __webpack_require__(312);
	
	var _browser2 = _interopRequireDefault(_browser);
	
	var _videojsSourceHandler = __webpack_require__(318);
	
	var _videojsSourceHandler2 = _interopRequireDefault(_videojsSourceHandler);
	
	var _promise = __webpack_require__(313);
	
	var _log = __webpack_require__(300);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var NAME = 'R5ProHLSSubscriber';
	var videojs = _browser2.default.getVideoJs();
	var defaultMimeType = 'application/x-mpegURL';
	var defaultSWF = 'lib/red5pro/red5pro-video-js.swf';
	var optionsToHlsURL = function optionsToHlsURL(options) {
	  var protocol = options.hlsprotocol ? options.hlsprotocol : options.protocol;
	  var port = options.hlsport ? options.hlsport : options.port;
	  var appEndpoint = options.context ? [options.app, options.context].join('/') : options.app;
	  return protocol + '://' + options.host + ':' + port + '/' + appEndpoint + '/' + options.streamName + '.m3u8';
	};
	
	var HLSSubscriber = function (_EventEmitter) {
	  _inherits(HLSSubscriber, _EventEmitter);
	
	  function HLSSubscriber() {
	    _classCallCheck(this, HLSSubscriber);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(HLSSubscriber).call(this));
	
	    _this._options = undefined;
	    _this._view = undefined;
	    _this._videojsHandler = undefined;
	    _this._boundBubbleSubscriberEvents = _this.bubbleSubscriberEvents.bind(_this);
	    return _this;
	  }
	
	  _createClass(HLSSubscriber, [{
	    key: 'bubbleSubscriberEvents',
	    value: function bubbleSubscriberEvents(event) {
	      this.trigger.call(this, event);
	    }
	  }, {
	    key: 'init',
	    value: function init(options) {
	      var deferred = new _promise.DeferredPromise();
	      if (!_browser2.default.getVideoJs()) {
	        deferred.reject('Could not resolve HLSSubscriber. Requires videojs library.');
	      } else {
	        this._options = options;
	        deferred.resolve(this);
	      }
	      return deferred.promise;
	    }
	  }, {
	    key: 'setView',
	    value: function setView(view) {
	      this._view = view;
	      if (this._videojsHandler !== undefined) {
	        this._videojsHandler.off('*', this._boundBubbleSubscriberEvents);
	        this._videojsHandler.disconnect();
	        this._videojsHandler = undefined;
	      }
	      this._videojsHandler = new _videojsSourceHandler2.default(this._view.view, this.getType());
	      return this;
	    }
	  }, {
	    key: 'play',
	    value: function play() {
	      var _this2 = this;
	
	      var streamName = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
	      var promise = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	
	      var p = promise || new _promise.DeferredPromise();
	      this._options.streamName = streamName || this._options.streamName;
	      var url = optionsToHlsURL(this._options);
	      var type = defaultMimeType;
	      var swfURL = defaultSWF;
	      if (_typeof(this._options) === 'object') {
	        type = this._options.rtmpMimeType || this._options.mimeType || type;
	        swfURL = this._options.swf || swfURL;
	      }
	      (0, _log.debug)(NAME, '[play]: URL(' + url + ').');
	      this._videojsHandler.on('*', this._boundBubbleSubscriberEvents);
	      this._videojsHandler.addSource(url, type, videojs, swfURL).then(function () {
	        p.resolve(_this2);
	        _this2.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.CONNECT_SUCCESS));
	      }).catch(function (error) {
	        p.reject(error);
	        _this2.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.CONNECT_FAILURE));
	      });
	      return p.hasOwnProperty('promise') ? p.promise : p;
	    }
	  }, {
	    key: 'stop',
	    value: function stop() {
	      (0, _log.debug)(NAME, '[stop]');
	      var deferred = new _promise.DeferredPromise();
	      try {
	        this._videojsHandler.off('*', this._boundBubbleSubscriberEvents);
	        this._videojsHandler.disconnect();
	        deferred.resolve();
	      } catch (e) {
	        deferred.reject(e.message);
	      }
	      return deferred.promise;
	    }
	  }, {
	    key: 'getType',
	    value: function getType() {
	      return 'HLS';
	    }
	  }]);
	
	  return HLSSubscriber;
	}(_eventEmitter2.default);
	
	exports.default = HLSSubscriber;

/***/ },
/* 318 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Base handler for utilizing the videojs
	 * library to intergate playback of live video.
	 *
	 * @see red5pro-hls
	 * @see red5pro-rtmp
	 */
	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _eventEmitter = __webpack_require__(306);
	
	var _eventEmitter2 = _interopRequireDefault(_eventEmitter);
	
	var _event = __webpack_require__(308);
	
	var _browser = __webpack_require__(312);
	
	var _browser2 = _interopRequireDefault(_browser);
	
	var _object = __webpack_require__(319);
	
	var _log = __webpack_require__(300);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var NAME = 'R5ProBaseVideoJSHandler';
	
	var videojs = _browser2.default.getVideoJs();
	var mimeType = 'video/webm';
	var optionsToURL = function optionsToURL(options) {
	  var appEndpoint = options.context ? [options.app, options.context].join('/') : options.app;
	  return options.protocol + '://' + options.host + ':' + options.port + '/' + appEndpoint + '/' + options.streamName;
	};
	
	var BaseHandler = function (_EventEmitter) {
	  _inherits(BaseHandler, _EventEmitter);
	
	  function BaseHandler(video) {
	    var playerType = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	
	    _classCallCheck(this, BaseHandler);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(BaseHandler).call(this));
	
	    _this.video = video;
	    _this.clone = _this.video.cloneNode(true);
	    _this.holder = _this.video.parentNode;
	    _this.videojs = null;
	    _this.source = null;
	    _this.playerType = playerType;
	    _this.hasAssignedEventListeners = false;
	
	    //  TODO: Temporary adjustment. Better to pass videojs up the chain so end users can set their own handlers.
	    _this.onVideoJSError = _this.onVideoJSError.bind(_this);
	    _this.onVideoJSLoadedData = _this.onVideoJSLoadedData.bind(_this);
	    _this.onVideoJSLoadedMetadata = _this.onVideoJSLoadedMetadata.bind(_this);
	    _this.onVideoJSTimeUpdate = _this.onVideoJSTimeUpdate.bind(_this);
	    _this.onVideoJSUserActive = _this.onVideoJSUserActive.bind(_this);
	    _this.onVideoJSUserInactive = _this.onVideoJSUserInactive.bind(_this);
	    _this.onVideoJSVolumeChange = _this.onVideoJSVolumeChange.bind(_this);
	    _this.onVideoJSEnded = _this.onVideoJSEnded.bind(_this);
	    return _this;
	  }
	
	  //  Assign all video.js listeners (those which are listed on http://docs.videojs.com/docs/api/player.html#events)
	
	
	  _createClass(BaseHandler, [{
	    key: 'addVideoJSEventListeners',
	    value: function addVideoJSEventListeners() {
	      if (this.hasAssignedEventListeners) {
	        return;
	      }
	      this.videojs.on('error', this.onVideoJSError);
	      this.videojs.on('loadeddata', this.onVideoJSLoadedData);
	      this.videojs.on('loadedmetadata', this.onVideoJSLoadedMetadata);
	      this.videojs.on('timeupdate', this.onVideoJSTimeUpdate);
	      this.videojs.on('useractive', this.onVideoJSUserActive);
	      this.videojs.on('userinactive', this.onVideoJSUserInactive);
	      this.videojs.on('volumechange', this.onVideoJSVolumeChange);
	      this.videojs.on('ended', this.onVideoJSEnded);
	      this.hasAssignedEventListeners = true;
	    }
	
	    //  Remove all video.js listeners (those which are listed on http://docs.videojs.com/docs/api/player.html#events)
	
	  }, {
	    key: 'removeVideoJSEventListeners',
	    value: function removeVideoJSEventListeners() {
	      if (!this.hasAssignedEventListeners) {
	        return;
	      }
	      this.videojs.off('error', this.onVideoJSError);
	      this.videojs.off('loadeddata', this.onVideoJSLoadedData);
	      this.videojs.off('loadedmetadata', this.onVideoJSLoadedMetadata);
	      this.videojs.off('timeupdate', this.onVideoJSTimeUpdate);
	      this.videojs.off('useractive', this.onVideoJSUserActive);
	      this.videojs.off('userinactive', this.onVideoJSUserInactive);
	      this.videojs.off('volumechange', this.onVideoJSVolumeChange);
	      this.videojs.off('ended', this.onVideoJSEnded);
	      this.hasAssignedEventListeners = false;
	    }
	
	    //  Cleanup our <source> if it exists
	
	  }, {
	    key: 'cleanup',
	    value: function cleanup() {
	      if (this.source) {
	        this.source.remove();
	      }
	      this.source = null;
	    }
	
	    //  Cleanup our video.js implementation
	
	  }, {
	    key: 'cleanupVideoJS',
	    value: function cleanupVideoJS() {
	      if (this.videojs) {
	        this.video.remove();
	        this.removeVideoJSEventListeners();
	        this.videojs.dispose();
	        //  This recreates our original <video> element and appends it to the original containing element
	        this.video = this.clone.cloneNode(true);
	        this.holder.appendChild(this.video);
	      }
	      this.videojs = null;
	    }
	
	    //  Add a new <source> for our <video> and startup video.js
	
	  }, {
	    key: 'addSource',
	    value: function addSource(src) {
	      var type = arguments.length <= 1 || arguments[1] === undefined ? mimeType : arguments[1];
	      var videoImpl = arguments.length <= 2 || arguments[2] === undefined ? videojs : arguments[2];
	      var swfURL = arguments.length <= 3 || arguments[3] === undefined ? null : arguments[3];
	
	      var self = this;
	
	      function createSource(_src, _type) {
	        var sourceEl = document.createElement('source');
	        sourceEl.src = _src;
	        sourceEl.type = _type;
	        return sourceEl;
	      }
	
	      function insertSourceInto(_src, _type, _parent) {
	        var sourceEl = createSource(_src, _type);
	        if (_parent.firstChild) {
	          _parent.insertBefore(sourceEl, _parent.firstChild);
	        } else {
	          _parent.appendChild(sourceEl);
	        }
	        return sourceEl;
	      }
	
	      return new Promise(function (resolve, reject) {
	        try {
	          //  If we have a current <source> element, remove it
	          self.cleanup();
	          //  If video.js has already been instantiated, dispose of it
	          self.cleanupVideoJS();
	
	          //  Create the new <source> element
	          var srcURL = typeof src === 'string' ? src : optionsToURL(src);
	          var _mimeType = typeof src === 'string' ? type : src.mimeType ? src.mimeType : type;
	          (0, _log.debug)(NAME, '"' + self.playerType + '" loading ' + srcURL);
	          self.source = insertSourceInto(srcURL, _mimeType, self.video);
	
	          //  Instantiate video.js
	          var opts = {
	            techOrder: ['html5', 'flash']
	          };
	          if (swfURL) {
	            (0, _object.deepDefine)(videoImpl, ['options', 'flash', 'swf'], swfURL);
	          }
	
	          self.videojs = videoImpl(self.video, opts, function () {
	            (0, _log.debug)(NAME, 'videoJS embed complete.');
	            resolve(self);
	          });
	          self.addVideoJSEventListeners();
	        } catch (e) {
	          (0, _log.error)(NAME, 'Could not instantiate new VideoJS-based "' + self.playerType + '" Player.\nReason: ' + e.message);
	          reject('Could not instantiate new VideoJS-based "' + self.playerType + '" Player.\nReason: ' + e.message);
	        }
	      });
	    }
	  }, {
	    key: 'onVideoJSError',
	    value: function onVideoJSError(e) {
	      (0, _log.error)(NAME, 'onVideoJSError: ' + JSON.stringify(e, null, 2));
	      this.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.SUBSCRIBE_FAIL, e));
	    }
	  }, {
	    key: 'onVideoJSLoadedData',
	    value: function onVideoJSLoadedData() {
	      this.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.SUBSCRIBE_START));
	    }
	  }, {
	    key: 'onVideoJSEnded',
	    value: function onVideoJSEnded() {
	      this.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.SUBSCRIBE_STOP));
	    }
	  }, {
	    key: 'onVideoJSLoadedMetadata',
	    value: function onVideoJSLoadedMetadata() {}
	  }, {
	    key: 'onVideoJSTimeUpdate',
	    value: function onVideoJSTimeUpdate() {}
	  }, {
	    key: 'onVideoJSUserActive',
	    value: function onVideoJSUserActive() {}
	  }, {
	    key: 'onVideoJSUserInactive',
	    value: function onVideoJSUserInactive() {}
	  }, {
	    key: 'onVideoJSVolumeChange',
	    value: function onVideoJSVolumeChange() {}
	  }, {
	    key: 'getType',
	    value: function getType() {
	      return this.playerType;
	    }
	  }, {
	    key: 'disconnect',
	    value: function disconnect() {
	      try {
	        this.video.pause();
	      } catch (e) {
	        // nada.
	      }
	      this.cleanup();
	      this.cleanupVideoJS();
	    }
	  }]);
	
	  return BaseHandler;
	}(_eventEmitter2.default);
	
	exports.default = BaseHandler;

/***/ },
/* 319 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * Modifies target `object` in place with a namespaced value.
	 */
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var deepDefine = exports.deepDefine = function deepDefine(object, paths, value) {
	  var i = 0;
	  var tail = object;
	  var prop = paths.pop();
	  var length = paths.length;
	  for (i; i < length; i++) {
	    var path = paths[i];
	    tail[path] = tail[path] || {};
	    tail = tail[path];
	  }
	  tail[prop] = value;
	};

/***/ },
/* 320 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _eventEmitter = __webpack_require__(306);
	
	var _eventEmitter2 = _interopRequireDefault(_eventEmitter);
	
	var _red5proRtmpVideojs = __webpack_require__(321);
	
	var _red5proRtmpVideojs2 = _interopRequireDefault(_red5proRtmpVideojs);
	
	var _red5proRtmpLive = __webpack_require__(322);
	
	var _red5proRtmpLive2 = _interopRequireDefault(_red5proRtmpLive);
	
	var _log = __webpack_require__(300);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var NAME = 'R5ProRTMPSubscriberProxy';
	
	var RTMPSubscriberProxy = function (_EventEmitter) {
	  _inherits(RTMPSubscriberProxy, _EventEmitter);
	
	  function RTMPSubscriberProxy() {
	    _classCallCheck(this, RTMPSubscriberProxy);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(RTMPSubscriberProxy).call(this));
	
	    _this._view = undefined;
	    _this._boundBubbleSubImplEvent = _this.bubbleSubscriberEvent.bind(_this);
	    return _this;
	  }
	
	  _createClass(RTMPSubscriberProxy, [{
	    key: 'init',
	    value: function init(options) {
	      var impl = void 0;
	      (0, _log.debug)(NAME, 'Options property for useVideoJS: ' + options.useVideoJS + '.');
	      if (options.hasOwnProperty('useVideoJS') && typeof options.useVideoJS === 'boolean' && !options.useVideoJS) {
	        (0, _log.debug)(NAME, 'Defaulting to RTMPSubscriber using custom live SWF.');
	        impl = new _red5proRtmpLive2.default();
	        impl.on('*', this._boundBubbleSubImplEvent);
	      } else {
	        (0, _log.debug)(NAME, 'Default to RTMPSubscriber using videojs support.');
	        impl = new _red5proRtmpVideojs2.default();
	        impl.on('*', this._boundBubbleSubImplEvent);
	      }
	      if (this._view) {
	        impl.setView(this._view);
	        this._view = undefined;
	      }
	      return impl.init(options);
	    }
	  }, {
	    key: 'setView',
	    value: function setView(view) {
	      this._view = view;
	    }
	  }, {
	    key: 'bubbleSubscriberEvent',
	    value: function bubbleSubscriberEvent(subscriberEvent) {
	      this.trigger.call(this, subscriberEvent);
	    }
	  }, {
	    key: 'getType',
	    value: function getType() {
	      return 'RTMPSubscriberProxy';
	    }
	  }]);
	
	  return RTMPSubscriberProxy;
	}(_eventEmitter2.default);
	
	exports.default = RTMPSubscriberProxy;

/***/ },
/* 321 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _browser = __webpack_require__(312);
	
	var _browser2 = _interopRequireDefault(_browser);
	
	var _eventEmitter = __webpack_require__(306);
	
	var _eventEmitter2 = _interopRequireDefault(_eventEmitter);
	
	var _videojsSourceHandler = __webpack_require__(318);
	
	var _videojsSourceHandler2 = _interopRequireDefault(_videojsSourceHandler);
	
	var _promise = __webpack_require__(313);
	
	var _log = __webpack_require__(300);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var NAME = 'R5ProRTMPSubscriber';
	var videojs = _browser2.default.getVideoJs();
	var defaultMimeType = 'rtmp/flv';
	var defaultFlashVersion = '10.0.0';
	var defaultSWF = 'lib/red5pro/red5pro-video-js.swf';
	var optionsToRtmpURL = function optionsToRtmpURL(options) {
	  var protocol = options.rtmpprotocol ? options.rtmpprotocol : options.protocol;
	  var port = options.rtmpport ? options.rtmpport : options.port;
	  var appEndpoint = options.context ? [options.app, options.context].join('/') : options.app;
	  return protocol + '://' + options.host + ':' + port + '/' + appEndpoint + '/' + options.streamName;
	};
	
	var VideoJSSubscriber = function (_EventEmitter) {
	  _inherits(VideoJSSubscriber, _EventEmitter);
	
	  function VideoJSSubscriber() {
	    _classCallCheck(this, VideoJSSubscriber);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(VideoJSSubscriber).call(this));
	
	    _this._options = undefined;
	    _this._view = undefined;
	    _this._videojsHandler = undefined;
	    _this._boundBubbleSubscriberEvents = _this.bubbleSubscriberEvents.bind(_this);
	    return _this;
	  }
	
	  _createClass(VideoJSSubscriber, [{
	    key: 'bubbleSubscriberEvents',
	    value: function bubbleSubscriberEvents(event) {
	      this.trigger.call(this, event);
	    }
	  }, {
	    key: 'init',
	    value: function init(options) {
	      var deferred = new _promise.DeferredPromise();
	      if (!_browser2.default.supportsFlashVersion(defaultFlashVersion)) {
	        deferred.reject('Could not resolve RTMPSubscriber instance. Requires minimum Flash Player install of ' + defaultFlashVersion + '.');
	      } else if (!_browser2.default.getVideoJs()) {
	        deferred.reject('Could not resolve RTMPSubscriber instance. Requires videojs library.');
	      } else {
	        this._options = options;
	        deferred.resolve(this);
	      }
	      return deferred.promise;
	    }
	  }, {
	    key: 'setView',
	    value: function setView(view) {
	      this._view = view;
	      if (this._videojsHandler !== undefined) {
	        this._videojsHandler.off('*', this._boundBubbleSubscriberEvents);
	        this._videojsHandler.disconnect();
	        this._videojsHandler = undefined;
	      }
	      if (view) {
	        this._videojsHandler = new _videojsSourceHandler2.default(this._view.view, this.getType());
	      }
	      return this;
	    }
	  }, {
	    key: 'play',
	    value: function play() {
	      var _this2 = this;
	
	      var streamName = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
	      var promise = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	
	      var p = promise || new _promise.DeferredPromise();
	      this._options.streamName = streamName || this._options.streamName;
	      var url = optionsToRtmpURL(this._options);
	      var type = defaultMimeType;
	      var swfURL = defaultSWF;
	      if (_typeof(this._options) === 'object') {
	        type = this._options.rtmpMimeType || this._options.mimeType || type;
	        swfURL = this._options.swf || swfURL;
	      }
	      (0, _log.debug)(NAME, '[play]: URL(' + url + ').');
	      this._videojsHandler.on('*', this._boundBubbleSubscriberEvents);
	      this._videojsHandler.addSource(url, type, videojs, swfURL).then(function () {
	        p.resolve(_this2);
	      }).catch(p.reject);
	      return p.hasOwnProperty('promise') ? p.promise : p;
	    }
	  }, {
	    key: 'stop',
	    value: function stop() {
	      (0, _log.debug)(NAME, '[stop]');
	      var deferred = new _promise.DeferredPromise();
	      try {
	        this._videojsHandler.off('*', this._boundBubbleSubscriberEvents);
	        this._videojsHandler.disconnect();
	        deferred.resolve();
	      } catch (e) {
	        deferred.reject(e.message);
	      }
	      return deferred.promise;
	    }
	  }, {
	    key: 'getType',
	    value: function getType() {
	      return 'RTMP';
	    }
	  }]);
	
	  return VideoJSSubscriber;
	}(_eventEmitter2.default);
	
	exports.default = VideoJSSubscriber;

/***/ },
/* 322 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _eventEmitter = __webpack_require__(306);
	
	var _eventEmitter2 = _interopRequireDefault(_eventEmitter);
	
	var _event = __webpack_require__(308);
	
	var _browser = __webpack_require__(312);
	
	var _browser2 = _interopRequireDefault(_browser);
	
	var _promise = __webpack_require__(313);
	
	var _liveSourceHandler = __webpack_require__(323);
	
	var _liveSourceHandler2 = _interopRequireDefault(_liveSourceHandler);
	
	var _log = __webpack_require__(300);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var NAME = 'R5ProLiveRTMPSubcriber';
	var swfId = 'RTMPSubscriber';
	var defaultFlashVersion = '10.0.0';
	var defaultSWF = 'lib/red5pro/red5pro-subscriber.swf';
	var swfobjectURL = 'lib/swfobject/swfobject.js';
	var productInstallURL = 'lib/swfobject/playerProductInstall.swf';
	
	var R5LiveSubscriber = function (_EventEmitter) {
	  _inherits(R5LiveSubscriber, _EventEmitter);
	
	  function R5LiveSubscriber() {
	    _classCallCheck(this, R5LiveSubscriber);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(R5LiveSubscriber).call(this));
	
	    _this._options = undefined;
	    _this._view = undefined;
	    _this._sourceHandler = undefined;
	    return _this;
	  }
	
	  _createClass(R5LiveSubscriber, [{
	    key: 'init',
	    value: function init(options) {
	      var self = this;
	      var deferred = new _promise.DeferredPromise();
	      var version = options.minFlashVersion || defaultFlashVersion;
	      if (!_browser2.default.supportsFlashVersion(version)) {
	        deferred.reject('Could not resolve LiveRTMPSubscriber instance. Requires minimum Flash Player install of ' + version + '.');
	      } else {
	        this._options = options;
	        this._options.swf = this._options.swf || defaultSWF;
	        this._options.minFlashVersion = version;
	        this._options.swfobjectURL = this._options.swfobjectURL || swfobjectURL;
	        this._options.productInstallURL = this._options.productInstallURL || productInstallURL;
	        try {
	          _browser2.default.injectScript(this._options.swfobjectURL).then(function () {
	            (0, _log.debug)(NAME, 'SWFObject embedded.');
	            if (self._sourceHandler) {
	              return self._sourceHandler.addSource(swfId, self._options);
	            }
	            return true;
	          }).then(function () {
	            deferred.resolve(self);
	            self.trigger(new _event.SubscriberEvent(_event.RTMPSubscriberEventTypes.EMBED_SUCCESS, self));
	          }).catch(function (err) {
	            (0, _log.error)(NAME, 'Could not embed Flash-based RTMP Player. Reason: ' + err);
	            if (self._sourceHandler) {
	              self._sourceHandler.disconnect();
	            }
	            deferred.reject(err);
	            self.trigger(new _event.SubscriberEvent(_event.RTMPSubscriberEventTypes.EMBED_FAILURE, self));
	          });
	        } catch (e) {
	          deferred.reject('Could not inject Flash-based Player into the page. Reason: ' + e.message);
	          self.trigger(new _event.SubscriberEvent(_event.RTMPSubscriberEventTypes.EMBED_FAILURE, self));
	        }
	      }
	      return deferred.promise;
	    }
	  }, {
	    key: 'setView',
	    value: function setView(view) {
	      var self = this;
	      this._view = view;
	      if (this._sourceHandler !== undefined) {
	        this._sourceHandler.disconnect();
	        this._sourceHandler = undefined;
	      }
	
	      if (view) {
	        this._sourceHandler = new _liveSourceHandler2.default(this._view.view, this.getType());
	        if (this._options) {
	          this._sourceHandler.addSource(swfId, this._options).catch(function () {
	            self.trigger(new _event.SubscriberEvent(_event.RTMPSubscriberEventTypes.EMBED_FAILURE, self));
	          });
	        }
	      }
	      return this;
	    }
	  }, {
	    key: '_establishExtIntHandlers',
	    value: function _establishExtIntHandlers() {
	      var _this2 = this;
	
	      var id = this._options.streamName;
	      var invokeFn = function invokeFn(label) {
	        return ['subscriber', label, id].join('_');
	      };
	      window[invokeFn('r5proConnectSuccess')] = function () {
	        return _this2.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.CONNECT_SUCCESS));
	      };
	      window[invokeFn('r5proConnectFailure')] = function () {
	        return _this2.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.CONNECT_FAILURE));
	      };
	      window[invokeFn('r5proSubscribeStart')] = function () {
	        return _this2.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.SUBSCRIBE_START));
	      };
	      window[invokeFn('r5proSubscribeStop')] = function () {
	        return _this2.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.SUBSCRIBE_STOP));
	      };
	      window[invokeFn('r5proSubscribeFail')] = function () {
	        return _this2.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.SUBSCRIBE_FAIL));
	      };
	      window[invokeFn('r5proSubscribeInvalidName')] = function () {
	        return _this2.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.SUBSCRIBE_INVALID_NAME));
	      };
	    }
	  }, {
	    key: 'play',
	    value: function play() {
	      var _this3 = this;
	
	      var streamName = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
	      var promise = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	      // eslint-disable-line no-unused-vars
	      this._establishExtIntHandlers();
	      this._sourceHandler.connect();
	      var cb = function cb(resolve) {
	        resolve(_this3);
	      };
	      return new Promise(cb);
	    }
	  }, {
	    key: 'stop',
	    value: function stop() {
	      var _this4 = this;
	
	      // Live subsciber.swf previously created for Red5 Pro examples could use some love with an invocation API.
	      var cb = function cb(resolve, reject) {
	        try {
	          _this4._sourceHandler.disconnect();
	          resolve();
	        } catch (e) {
	          reject(e.message);
	        }
	      };
	      return new Promise(cb);
	    }
	  }, {
	    key: 'getType',
	    value: function getType() {
	      return 'LiveRTMP';
	    }
	  }]);
	
	  return R5LiveSubscriber;
	}(_eventEmitter2.default);
	
	exports.default = R5LiveSubscriber;

/***/ },
/* 323 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	'use script';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _embed = __webpack_require__(324);
	
	var embed = _interopRequireWildcard(_embed);
	
	var _browser = __webpack_require__(312);
	
	var _browser2 = _interopRequireDefault(_browser);
	
	var _promise = __webpack_require__(313);
	
	var _log = __webpack_require__(300);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var NAME = 'RTMPLiveSourceHandler';
	
	var LiveSourceHandler = function () {
	  function LiveSourceHandler(video, type) {
	    _classCallCheck(this, LiveSourceHandler);
	
	    this.video = video;
	    this.clone = this.video.cloneNode(true);
	    this.holder = this.video.parentNode;
	    this.playerType = type;
	  }
	
	  _createClass(LiveSourceHandler, [{
	    key: 'cleanUp',
	    value: function cleanUp() {
	      // Return to prior DOM manipulation.
	      this.video.remove();
	      this.video = this.clone.cloneNode(true);
	      this.holder.appendChild(this.video);
	    }
	  }, {
	    key: '_setUpInitCallback',
	    value: function _setUpInitCallback(promise) {
	      var _this = this;
	
	      window.setSubscriberId = function (successId) {
	        // successId === _options.streamName
	        (0, _log.debug)(NAME, 'Embed and init() complete for subscriber swf. successId(' + successId + ').');
	        promise.resolve(successId);
	        _this._tearDownInitCallback();
	      };
	      // TODO: Setup timeout to reject?
	    }
	  }, {
	    key: '_tearDownInitCallback',
	    value: function _tearDownInitCallback() {
	      window.setActiveId = undefined;
	    }
	  }, {
	    key: 'addSource',
	    value: function addSource(swfId, options) {
	      var swfUrl = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
	      var minFlashVersion = arguments.length <= 3 || arguments[3] === undefined ? null : arguments[3];
	
	      var deferred = new _promise.DeferredPromise();
	      options.swf = swfUrl || options.swf;
	      options.minFlashVersion = minFlashVersion || options.minFlashVersion;
	      this._setUpInitCallback(deferred);
	      embed.defineEmbedElement(this.video, this.holder).then(function (elementId) {
	        var flashvars = {
	          stream: options.streamName,
	          app: options.context ? options.app + '/' + options.context : options.app,
	          host: options.host
	        };
	        if (options.buffer && !isNaN(Number(options.buffer))) {
	          flashvars.buffer = options.buffer;
	        }
	        if (options.width && !isNaN(Number(options.width))) {
	          flashvars.width = options.width;
	        }
	        if (options.height && !isNaN(Number(options.height))) {
	          flashvars.height = options.height;
	        }
	        return embed.embedSwfObject(swfId, options, flashvars, _browser2.default.getSwfObject(), elementId);
	      }).catch(function (e) {
	        return deferred.reject(e);
	      });
	      return deferred.promise;
	    }
	  }, {
	    key: 'connect',
	    value: function connect() {
	      try {
	        _browser2.default.getEmbedObject().connect();
	      } catch (e) {
	        // nada.
	      }
	    }
	  }, {
	    key: 'disconnect',
	    value: function disconnect() {
	      try {
	        // No invocable API for custom live flash subscriber from Red5 Pro at the time.
	        _browser2.default.getEmbedObject().disconnect();
	      } catch (e) {
	        // nada.
	      }
	      this.cleanUp();
	    }
	  }, {
	    key: 'getType',
	    value: function getType() {
	      return this.playerType;
	    }
	  }]);
	
	  return LiveSourceHandler;
	}();
	
	exports.default = LiveSourceHandler;

/***/ },
/* 324 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.embedSwfObject = exports.defineEmbedElement = undefined;
	
	var _promise = __webpack_require__(313);
	
	var defineEmbedElement = exports.defineEmbedElement = function defineEmbedElement(targetElement, targetParent) {
	  var dfd = new _promise.DeferredPromise();
	  var elementId = targetElement.id;
	  if (targetElement.nodeName.toLowerCase() === 'video') {
	    var div = document.createElement('div');
	    div.id = elementId + '_rtmp';
	    targetParent.appendChild(div);
	    targetElement.remove();
	    dfd.resolve(div.id);
	  } else {
	    dfd.resolve(elementId);
	  }
	  return dfd.promise;
	};
	
	var embedSwfObject = exports.embedSwfObject = function embedSwfObject(idName, options, flashvars, swfobject, elementId) {
	  var dfd = new _promise.DeferredPromise();
	  var params = {
	    quality: 'high',
	    bgcolor: '#000',
	    allowscriptaccess: 'always',
	    allowfullscreen: 'true'
	  };
	  var attributes = {
	    id: idName,
	    name: idName,
	    align: 'middle'
	  };
	  if (swfobject.hasFlashPlayerVersion(options.minFlashVersion)) {
	    swfobject.embedSWF(options.swf, elementId, options.width || '320', options.height || '240', options.minFlashVersion, options.productInstallURL, flashvars, params, attributes, dfd.resolve);
	  } else {
	    dfd.reject('Flash Player Version is not supported.');
	  }
	  return dfd.promise;
	};

/***/ },
/* 325 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.ImplFactoryOrder = undefined;
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _promise = __webpack_require__(313);
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var map = new WeakMap();
	
	var pvt = function pvt(ctx) {
	  if (!map.has(ctx)) {
	    map.set(ctx, {});
	  }
	
	  return map.get(ctx);
	};
	
	var ImplFactoryOrder = exports.ImplFactoryOrder = function () {
	  function ImplFactoryOrder() {
	    var _this = this;
	
	    _classCallCheck(this, ImplFactoryOrder);
	
	    this.listorder = function () {
	      return regeneratorRuntime.mark(function listorder(list) {
	        return regeneratorRuntime.wrap(function listorder$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                if (!(list.length > 0)) {
	                  _context.next = 5;
	                  break;
	                }
	
	                _context.next = 3;
	                return list.shift();
	
	              case 3:
	                _context.next = 0;
	                break;
	
	              case 5:
	              case 'end':
	                return _context.stop();
	            }
	          }
	        }, listorder, this);
	      });
	    }();
	
	    pvt(this).find = function (iterator, map, options, promise) {
	      var initFn = arguments.length <= 4 || arguments[4] === undefined ? null : arguments[4];
	
	      var _pvt$next = pvt(_this).next(iterator, map);
	
	      var _pvt$next2 = _slicedToArray(_pvt$next, 2);
	
	      var type = _pvt$next2[0];
	      var Impl = _pvt$next2[1];
	
	      if (!Impl) {
	        promise.reject();
	      } else {
	        var p = void 0;
	        var src = options[type];
	        src = src || options;
	        if (initFn) {
	          p = new Impl()[initFn](src);
	        } else {
	          p = new Impl(src);
	        }
	        p.then(function (concrete) {
	          promise.resolve(concrete);
	        }).catch(function () {
	          // eslint-disable-line no-unused-vars
	          pvt(_this).find(iterator, map, options, promise, initFn);
	        });
	      }
	    };
	
	    pvt(this).next = function (order, map) {
	      var Impl = void 0;
	      var key = void 0;
	      var next = order.next();
	      if (!next.done) {
	        key = next.value;
	        Impl = map.get(key);
	      }
	      return [key, Impl];
	    };
	  }
	
	  _createClass(ImplFactoryOrder, [{
	    key: 'create',
	    value: function create(order, map, options) {
	      var initFn = arguments.length <= 3 || arguments[3] === undefined ? null : arguments[3];
	
	      var promise = new _promise.DeferredPromise();
	      pvt(this).find(this.listorder(order.slice()), map, options, promise, initFn);
	      return promise.promise;
	    }
	  }]);
	
	  return ImplFactoryOrder;
	}();
	
	exports.default = ImplFactoryOrder;

/***/ },
/* 326 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var PlaybackTypes = exports.PlaybackTypes = Object.freeze({
	  RTMP: 'rtmp',
	  RTC: 'rtc',
	  HLS: 'hls'
	});

/***/ },
/* 327 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Main entry for failover support of all publisher implementations.
	 */
	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.RTCPublisher = exports.RTMPPublisher = exports.Red5ProPublisher = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _implFactoryOrder = __webpack_require__(325);
	
	var _implFactoryOrder2 = _interopRequireDefault(_implFactoryOrder);
	
	var _eventEmitter = __webpack_require__(306);
	
	var _eventEmitter2 = _interopRequireDefault(_eventEmitter);
	
	var _red5proRtmp = __webpack_require__(328);
	
	var _red5proRtmp2 = _interopRequireDefault(_red5proRtmp);
	
	var _red5proRtc = __webpack_require__(331);
	
	var _red5proRtc2 = _interopRequireDefault(_red5proRtc);
	
	var _promise = __webpack_require__(313);
	
	var _publish = __webpack_require__(329);
	
	var _log = __webpack_require__(300);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var NAME = 'R5ProPublisher';
	var publishFactory = new _implFactoryOrder2.default();
	var publisherImpl = function () {
	  var map = new Map();
	  map.set(_publish.PublishTypes.RTMP, _red5proRtmp2.default);
	  map.set(_publish.PublishTypes.RTC, _red5proRtc2.default);
	  return map;
	}();
	
	var Red5ProPublisher = function (_EventEmitter) {
	  _inherits(Red5ProPublisher, _EventEmitter);
	
	  function Red5ProPublisher() {
	    _classCallCheck(this, Red5ProPublisher);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Red5ProPublisher).call(this));
	
	    _this._options = undefined;
	    _this._view = undefined;
	    _this._currentPublisher = undefined;
	    _this._boundBubblePublisherEvent = _this.bubblePublisherEvent.bind(_this);
	    _this._order = [_publish.PublishTypes.RTMP, _publish.PublishTypes.RTC];
	    return _this;
	  }
	
	  _createClass(Red5ProPublisher, [{
	    key: 'getPublishOrder',
	    value: function getPublishOrder() {
	      return this._order;
	    }
	  }, {
	    key: 'setPublishOrder',
	    value: function setPublishOrder(order) {
	      // Allow for string value to define single item in order.
	      order = typeof order === 'string' ? [order] : order;
	
	      // Filter out values not available in enumeration of playback types.
	      var t = order.filter(function (entry) {
	        var key = void 0;
	        for (key in _publish.PublishTypes) {
	          if (_publish.PublishTypes[key].toLowerCase() === entry.toLowerCase()) {
	            return true;
	          }
	        }
	        return false;
	      }).map(function (entry) {
	        return entry.toLowerCase();
	      });
	
	      // Define new order.
	      this._order = [].concat(_toConsumableArray(new Set(t)));
	      (0, _log.debug)(NAME, '[orderupdate]: ' + this._order);
	      return this;
	    }
	  }, {
	    key: 'setView',
	    value: function setView(publishView) {
	      this._view = publishView;
	      return this;
	    }
	  }, {
	    key: 'getPublisherFromOrder',
	    value: function getPublisherFromOrder(order, options) {
	      return publishFactory.create(order, publisherImpl, options, 'init');
	    }
	  }, {
	    key: 'init',
	    value: function init(options) {
	      var _this2 = this;
	
	      var deferred = new _promise.DeferredPromise();
	      (0, _log.debug)(NAME, '[publish]');
	      this._options = options;
	      this.getPublisherFromOrder(this._order, this._options).then(function (publisher) {
	        _this2._currentPublisher = publisher;
	        _this2._currentPublisher.setView(_this2._view);
	        _this2._currentPublisher.on('*', _this2._boundBubblePublisherEvent);
	        deferred.resolve(_this2._currentPublisher);
	      }).catch(function (err) {
	        (0, _log.warn)(NAME, '[publisherror]: Could not implement a publisher: ' + err);
	        deferred.reject(err);
	      });
	      return deferred.promise;
	    }
	  }, {
	    key: 'stop',
	    value: function stop() {
	      var _this3 = this;
	
	      var deferred = new _promise.DeferredPromise();
	      if (!this._currentPublisher) {
	        (0, _log.warn)(NAME, '[stop]: Could not invoke stop() on undefined publisher.');
	        deferred.reject('A current publisher is not available to issue a :stop() command to.');
	      } else {
	        (0, _log.debug)(NAME, '[stop]: Invoking stop on held publisher');
	        this._currentPublisher.unpublish().then(function () {
	          (0, _log.debug)(NAME, '[stopsuccess]');
	          _this3._currentPublisher.off('*', _this3._boundBubblePublisherEvent);
	          _this3._currentPublisher = undefined;
	          deferred.resolve();
	        }).catch(function (err) {
	          (0, _log.debug)(NAME, '[stoperror]: ' + err);
	          if (_this3._currentPublisher) {
	            _this3._currentPublisher.off('*', _this3._boundBubblePublisherEvent);
	          }
	          _this3._currentPublisher = undefined;
	          deferred.reject(err);
	        });
	      }
	      return deferred.promise;
	    }
	  }, {
	    key: 'bubblePublisherEvent',
	    value: function bubblePublisherEvent(publisherEvent) {
	      this.trigger.call(this, publisherEvent);
	    }
	  }, {
	    key: 'publishTypes',
	    get: function get() {
	      return _publish.PublishTypes;
	    }
	  }, {
	    key: 'currentPublisher',
	    get: function get() {
	      return this._currentPublisher;
	    }
	  }]);
	
	  return Red5ProPublisher;
	}(_eventEmitter2.default);
	
	exports.Red5ProPublisher = Red5ProPublisher;
	exports.RTMPPublisher = _red5proRtmp2.default;
	exports.RTCPublisher = _red5proRtc2.default;

/***/ },
/* 328 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _eventEmitter = __webpack_require__(306);
	
	var _eventEmitter2 = _interopRequireDefault(_eventEmitter);
	
	var _event = __webpack_require__(308);
	
	var _browser = __webpack_require__(312);
	
	var _browser2 = _interopRequireDefault(_browser);
	
	var _promise = __webpack_require__(313);
	
	var _publish = __webpack_require__(329);
	
	var _pubSourceHandler = __webpack_require__(330);
	
	var _pubSourceHandler2 = _interopRequireDefault(_pubSourceHandler);
	
	var _log = __webpack_require__(300);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var NAME = 'R5ProRTMPPublisher';
	var swfId = 'RTMPPublisher';
	var defaultMode = 'live';
	var defaultFlashVersion = '10.0.0';
	var defaultSWF = 'lib/red5pro/red5pro-publisher.swf';
	var swfobjectURL = 'lib/swfobject/swfobject.js';
	var productInstallURL = 'lib/swfobject/playerProductInstall.swf';
	
	var RTMPPublisher = function (_EventEmitter) {
	  _inherits(RTMPPublisher, _EventEmitter);
	
	  function RTMPPublisher() {
	    _classCallCheck(this, RTMPPublisher);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(RTMPPublisher).call(this));
	
	    _this._options = undefined;
	    _this._view = undefined;
	    _this._sourceHandler = undefined;
	    return _this;
	  }
	
	  _createClass(RTMPPublisher, [{
	    key: 'init',
	    value: function init(options) {
	      var self = this;
	      var deferred = new _promise.DeferredPromise();
	      var version = options.minFlashVersion || defaultFlashVersion;
	      if (!_browser2.default.supportsFlashVersion(version)) {
	        deferred.reject('Could not resolve RTMPPublisher instance. Requires minimum Flash Player install of ' + version);
	      } else {
	        this._options = options;
	        this._options.swf = this._options.swf || defaultSWF;
	        this._options.minFlashVersion = version;
	        this._options.streamMode = this._options.streamMode || defaultMode;
	        this._options.swfobjectURL = this._options.swfobjectURL || swfobjectURL;
	        this._options.productInstallURL = this._options.productInstallURL || productInstallURL;
	        try {
	          _browser2.default.injectScript(this._options.swfobjectURL).then(function () {
	            (0, _log.debug)(NAME, 'SWFObject embedded.');
	            if (self._sourceHandler) {
	              (0, _log.debug)(NAME, 'Publish handler established.');
	              return self._sourceHandler.addSource(swfId, self._options);
	            } else {
	              (0, _log.debug)(NAME, 'Publish handler not established.');
	              return true;
	            }
	          }).then(function () {
	            return deferred.resolve(self);
	          }).catch(function (err) {
	            (0, _log.error)(NAME, 'Could not embed Flash-based RTMP Publisher. Reason: ' + err);
	            if (self._sourceHandler) {
	              self._sourceHandler.disconnect();
	            }
	            deferred.reject(err);
	            self.trigger(new _event.PublisherEvent(_event.RTMPPublisherEventTypes.EMBED_FAILURE, self));
	          });
	        } catch (e) {
	          deferred.reject('Could not inject Flash-based Publisher into the page. Reason: ' + e.message);
	          self.trigger(new _event.PublisherEvent(_event.RTMPPublisherEventTypes.EMBED_FAILURE, self));
	        }
	      }
	      return deferred.promise;
	    }
	  }, {
	    key: '_setUpConnectCallback',
	    value: function _setUpConnectCallback(promise) {
	      var _this2 = this;
	
	      window.setActiveId = function (successId) {
	        // successId === _options.streamName
	        (0, _log.debug)(NAME, 'Embed and connect() complete for publisher swf. successId(' + successId + ').');
	        promise.resolve(successId);
	        _this2.trigger(new _event.PublisherEvent(_event.RTMPPublisherEventTypes.EMBED_SUCCESS, _this2));
	        _this2._tearDownConnectCallback();
	      };
	      // TODO: Setup timeout to reject?
	    }
	  }, {
	    key: '_tearDownConnectCallback',
	    value: function _tearDownConnectCallback() {
	      window.setActiveId = undefined;
	    }
	  }, {
	    key: '_establishExtIntHandlers',
	    value: function _establishExtIntHandlers() {
	      var _this3 = this;
	
	      var id = this._options.streamName;
	      var invokeFn = function invokeFn(label) {
	        return ['publisher', label, id].join('_');
	      };
	      window[invokeFn('r5proConnectSuccess')] = function () {
	        return _this3.trigger(new _event.PublisherEvent(_event.PublisherEventTypes.CONNECT_SUCCESS));
	      };
	      window[invokeFn('r5proConnectFailure')] = function () {
	        return _this3.trigger(new _event.PublisherEvent(_event.PublisherEventTypes.CONNECT_FAILURE));
	      };
	      window[invokeFn('r5proPublishStart')] = function () {
	        return _this3.trigger(new _event.PublisherEvent(_event.PublisherEventTypes.PUBLISH_START));
	      };
	      window[invokeFn('r5proPublishFail')] = function () {
	        return _this3.trigger(new _event.PublisherEvent(_event.PublisherEventTypes.PUBLISH_FAIL));
	      };
	      window[invokeFn('r5proPublishInvalidName')] = function () {
	        return _this3.trigger(new _event.PublisherEvent(_event.PublisherEventTypes.PUBLISH_INVALID_NAME));
	      };
	      window[invokeFn('r5proUnpublishSuccess')] = function () {
	        return _this3.trigger(new _event.PublisherEvent(_event.PublisherEventTypes.UNPUBLISH_SUCCESS));
	      };
	    }
	  }, {
	    key: 'publish',
	    value: function publish() {
	      var _this4 = this;
	
	      var streamName = arguments.length <= 0 || arguments[0] === undefined ? undefined : arguments[0];
	      // eslint-disable-line no-unused-vars
	      var dfd = new _promise.DeferredPromise();
	      this._setUpConnectCallback(dfd);
	      try {
	        this._sourceHandler.getEmbedOperation().then(function () {
	          (0, _log.debug)(NAME, '[handler:embed:complete]');
	          var el = _browser2.default.getEmbedObject(swfId);
	          if (el) {
	            _this4._establishExtIntHandlers();
	          }
	          var count = 0;
	          var limit = 1000;
	          var tryConnect = function tryConnect() {
	            var timeout = void 0;
	            timeout = setTimeout(function () {
	              try {
	                clearTimeout(timeout);
	                el.connect();
	              } catch (e) {
	                if (count++ > limit) {
	                  throw e;
	                } else {
	                  tryConnect();
	                }
	              }
	            }, 300);
	          };
	          tryConnect();
	        }).catch(function (err) {
	          dfd.reject(err);
	          _this4.trigger(new _event.PublisherEvent(_event.PublisherEventTypes.CONNECT_FAILURE, _this4));
	        });
	      } catch (e) {
	        (0, _log.error)(NAME, '[handler:embed:error]');
	        dfd.reject('Could not initiate connection sequence. Reason: ' + e.message);
	        this.trigger(new _event.PublisherEvent(_event.PublisherEventTypes.CONNECT_FAILURE, this));
	        this._tearDownConnectCallback();
	      }
	      return dfd.promise;
	    }
	  }, {
	    key: 'unpublish',
	    value: function unpublish() {
	      var deferred = new _promise.DeferredPromise();
	      try {
	        _browser2.default.getEmbedObject(swfId).disconnect();
	        deferred.resolve();
	      } catch (e) {
	        (0, _log.error)(NAME, 'Could not initiate disconnection sequence. Reason: ' + e.message);
	        deferred.reject(e.message);
	      }
	      return deferred.promise;
	    }
	  }, {
	    key: 'setView',
	    value: function setView(view) {
	      var _this5 = this;
	
	      this._view = view;
	      if (this._sourceHandler !== undefined) {
	        this._sourceHandler.disconnect();
	        this._sourceHandler = undefined;
	      }
	      if (this._view) {
	        this._sourceHandler = new _pubSourceHandler2.default(this._view.view, this.getType());
	      }
	      if (this._options && this._sourceHandler) {
	        this._sourceHandler.addSource(swfId, this._options).catch(function (err) {
	          (0, _log.error)(NAME, 'Could not establish proper RTMP publisher: ' + err);
	          _this5.trigger(new _event.PublisherEvent(_event.RTMPPublisherEventTypes.EMBED_FAILURE, _this5));
	        });
	      }
	      return this;
	    }
	  }, {
	    key: 'getType',
	    value: function getType() {
	      return _publish.PublishTypes.RTMP.toUpperCase();
	    }
	  }]);
	
	  return RTMPPublisher;
	}(_eventEmitter2.default);
	
	exports.default = RTMPPublisher;

/***/ },
/* 329 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var PublishTypes = exports.PublishTypes = Object.freeze({
	  RTMP: 'rtmp',
	  RTC: 'rtc'
	});
	
	var PublishModeTypes = exports.PublishModeTypes = Object.freeze({
	  LIVE: 'live',
	  RECORD: 'record',
	  APPEND: 'append'
	});

/***/ },
/* 330 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _embed = __webpack_require__(324);
	
	var embed = _interopRequireWildcard(_embed);
	
	var _browser = __webpack_require__(312);
	
	var _browser2 = _interopRequireDefault(_browser);
	
	var _promise = __webpack_require__(313);
	
	var _log = __webpack_require__(300);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var NAME = 'R5ProPublisherSourceHandler';
	
	var PublisherSourceHandler = function () {
	  function PublisherSourceHandler(video, type) {
	    _classCallCheck(this, PublisherSourceHandler);
	
	    this.video = video;
	    this.clone = this.video.cloneNode(true);
	    this.holder = this.video.parentNode;
	    this.publisherType = type;
	    this._embedFuture = undefined;
	  }
	
	  _createClass(PublisherSourceHandler, [{
	    key: 'getEmbedOperation',
	    value: function getEmbedOperation() {
	      this._embedFuture = _promise.Future.createIfNotExist(this._embedFuture);
	      return this._embedFuture.promise;
	    }
	  }, {
	    key: 'cleanUp',
	    value: function cleanUp() {
	      // Return to prior DOM manipulation.
	      this.video.remove();
	      this.video = this.clone.cloneNode(true);
	      this.holder.appendChild(this.video);
	      this._embedFuture = undefined;
	    }
	  }, {
	    key: 'addSource',
	    value: function addSource(swfId, options) {
	      var swfUrl = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
	      var minFlashVersion = arguments.length <= 3 || arguments[3] === undefined ? null : arguments[3];
	
	      (0, _log.debug)(NAME, '[addsource]');
	      var self = this;
	      this._embedFuture = _promise.Future.createIfNotExist(this._embedFuture);
	      var deferred = this._embedFuture;
	      options.swf = swfUrl || options.swf;
	      options.minFlashVersion = minFlashVersion || options.minFlashVersion;
	      embed.defineEmbedElement(this.video, this.holder).then(function (elementId) {
	        (0, _log.debug)(NAME, '[element:complete]');
	        var flashvars = {
	          buffer: options.buffer != null ? options.buffer : 2,
	          streamMode: options.streamMode,
	          streamName: options.streamName,
	          appName: options.app,
	          host: options.host
	        };
	        if (options.context) {
	          flashvars.roomName = options.context;
	        }
	        if (options.width && !isNaN(Number(options.width))) {
	          flashvars.width = options.width;
	        }
	        if (options.height && !isNaN(Number(options.height))) {
	          flashvars.height = options.height;
	        }
	        return embed.embedSwfObject(swfId, options, flashvars, _browser2.default.getSwfObject(), elementId);
	      }).then(function () {
	        (0, _log.debug)(NAME, '[embed:complete]');
	        deferred.resolve(self);
	      }).catch(function (err) {
	        return deferred.reject(err);
	      });
	      return deferred.promise;
	    }
	  }, {
	    key: 'disconnect',
	    value: function disconnect() {
	      try {
	        // No invocable API for custom live flash publisher from Red5 Pro at the time.
	      } catch (e) {
	        // nada.
	      }
	      this.cleanUp();
	    }
	  }, {
	    key: 'getType',
	    value: function getType() {
	      return this.publisherType;
	    }
	  }]);
	
	  return PublisherSourceHandler;
	}();
	
	exports.default = PublisherSourceHandler;

/***/ },
/* 331 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _eventEmitter = __webpack_require__(306);
	
	var _eventEmitter2 = _interopRequireDefault(_eventEmitter);
	
	var _event = __webpack_require__(308);
	
	var _socketHelperPub = __webpack_require__(332);
	
	var _socketHelperPub2 = _interopRequireDefault(_socketHelperPub);
	
	var _webrtcHelperPub = __webpack_require__(333);
	
	var _webrtcHelperPub2 = _interopRequireDefault(_webrtcHelperPub);
	
	var _publish = __webpack_require__(329);
	
	var _promise = __webpack_require__(313);
	
	var _browser = __webpack_require__(312);
	
	var _browser2 = _interopRequireDefault(_browser);
	
	var _webrtc = __webpack_require__(316);
	
	var webrtc = _interopRequireWildcard(_webrtc);
	
	var _websocket = __webpack_require__(311);
	
	var websocket = _interopRequireWildcard(_websocket);
	
	var _log = __webpack_require__(300);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var defaultStreamType = 'webrtc';
	var endpointFromOptions = function endpointFromOptions(options) {
	  var protocol = options.wsprotocol || options.protocol;
	  var port = options.wsport || options.port;
	  var appEndpoint = options.context ? [options.app, options.context].join('/') : options.app;
	  return protocol + '://' + options.host + ':' + port + '/' + appEndpoint + '?id=' + options.streamName;
	};
	
	var pubStartRegex = /(.*) starting/gi;
	var pubStopRegex = /(.*) stopping/gi;
	var NAME = 'RTCPublisher';
	var debug = function debug(message) {
	  (0, _log.debug)(NAME, message);
	};
	var warn = function warn(message) {
	  (0, _log.warn)(NAME, message);
	};
	var error = function error(message) {
	  (0, _log.error)(NAME, message);
	};
	
	var RTCPublisher = function (_EventEmitter) {
	  _inherits(RTCPublisher, _EventEmitter);
	
	  function RTCPublisher() {
	    _classCallCheck(this, RTCPublisher);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(RTCPublisher).call(this));
	
	    _this._options = undefined;
	    _this._view = undefined;
	    _this._peerHelper = undefined;
	    _this._socketHelper = undefined;
	    _this._mediaStream = undefined;
	
	    _this._streamFuture = undefined;
	    _this._availableFuture = undefined;
	    _this._peerFuture = undefined;
	    _this._offerFuture = undefined;
	    _this._sendOfferFuture = undefined;
	    _this._trickleEndFuture = undefined;
	    _this._publishFuture = undefined;
	    _this._unpublishFuture = undefined;
	    return _this;
	  }
	
	  _createClass(RTCPublisher, [{
	    key: '_getMediaStream',
	    value: function _getMediaStream() {
	      this._streamFuture = _promise.Future.createIfNotExist(this._streamFuture);
	      return this._streamFuture.promise;
	    }
	  }, {
	    key: '_getTrickleEnd',
	    value: function _getTrickleEnd() {
	      return _promise.Future.createIfNotExist(this._trickleEndFuture);
	    }
	  }, {
	    key: 'init',
	    value: function init(options) {
	      var deferred = new _promise.DeferredPromise();
	      if (!webrtc.isSupported() || !websocket.isSupported()) {
	        deferred.reject('Cannot create WebRTC playback instance. Your environment does not support WebRTC and/or WebSockets.');
	      } else {
	        this._options = options;
	        this._peerHelper = new _webrtcHelperPub2.default(this);
	        this._socketHelper = new _socketHelperPub2.default(this);
	        deferred.resolve(this);
	      }
	      return deferred.promise;
	    }
	  }, {
	    key: 'setView',
	    value: function setView(view) {
	      this._view = view;
	      return this;
	    }
	  }, {
	    key: 'attachStream',
	    value: function attachStream(media) {
	      this._streamFuture = _promise.Future.createIfNotExist(this._streamFuture);
	      this._streamFuture.resolve(media);
	      return this;
	    }
	  }, {
	    key: 'detachStream',
	    value: function detachStream() {
	      if (this._mediaStream && this._mediaStream.stop) {
	        this._mediaStream.stop();
	      } else if (this._mediaStream && this._mediaStream.getTracks) {
	        var tracks = this._mediaStream.getTracks();
	        var trackLength = tracks.length;
	        while (--trackLength > -1) {
	          if (tracks[trackLength].stop) {
	            tracks[trackLength].stop();
	          }
	        }
	      }
	      this._streamFuture = undefined;
	      this._mediaStream = undefined;
	      return this;
	    }
	  }, {
	    key: 'requestAvailability',
	    value: function requestAvailability(streamName, type) {
	      debug('[requestavailability]');
	      this._availableFuture = undefined;
	      this._availableFuture = _promise.Future.createIfNotExist(this._availableFuture);
	      // message on socket returns -> onStream(Un)Available
	      this._socketHelper.post({
	        isAvailable: streamName,
	        type: type,
	        bundle: false
	      });
	      return this._availableFuture.promise;
	    }
	  }, {
	    key: 'createPeerConnection',
	    value: function createPeerConnection(iceServers) {
	      debug('[createpeeer]');
	      this._peerFuture = undefined;
	      this._peerFuture = _promise.Future.createIfNotExist(this._peerFuture);
	      this._peerHelper.setUp(iceServers, this._peerFuture);
	      return this._peerFuture.promise;
	    }
	  }, {
	    key: 'createOffer',
	    value: function createOffer(constraints) {
	      var bandwidth = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	
	      debug('[createoffer]');
	      this._offerFuture = undefined;
	      this._offerFuture = _promise.Future.createIfNotExist(this._offerFuture);
	      this._peerHelper.createOffer(bandwidth, this._offerFuture);
	      return this._offerFuture.promise;
	    }
	  }, {
	    key: 'setRemoteDescription',
	    value: function setRemoteDescription(sdp) {
	      debug('[setremotedescription]');
	      return this._peerHelper.setRemoteDescription(sdp);
	    }
	  }, {
	    key: 'sendOffer',
	    value: function sendOffer(sdp, streamName) {
	      debug('[sendoffer]');
	      this._sendOfferFuture = undefined;
	      this._sendOfferFuture = _promise.Future.createIfNotExist(this._sendOffFuture);
	      this._socketHelper.post({
	        handleOffer: streamName,
	        data: {
	          sdp: sdp
	        }
	      });
	      return this._sendOfferFuture.promise;
	    }
	  }, {
	    key: 'sendCandidate',
	    value: function sendCandidate(candidate, streamName) {
	      debug('[sendcandidate]');
	      this._socketHelper.post({
	        handleCandidate: streamName,
	        data: {
	          candidate: candidate
	        }
	      });
	    }
	  }, {
	    key: 'requestPublish',
	    value: function requestPublish(streamName, streamMode) {
	      debug('[requestpublish]');
	      this._publishFuture = undefined;
	      this._publishFuture = _promise.Future.createIfNotExist(this._publishFuture);
	      this._socketHelper.post({
	        publish: streamName,
	        mode: streamMode
	      });
	      return this._publishFuture.promise;
	    }
	  }, {
	    key: 'requestUnpublish',
	    value: function requestUnpublish(streamName) {
	      this._unpublishFuture = undefined;
	      this._unpublishFuture = _promise.Future.createIfNotExist(this._unpublishFuture);
	      this._socketHelper.post({
	        unpublish: streamName
	      });
	      return this._unpublishFuture.promise;
	    }
	  }, {
	    key: 'publish',
	    value: function publish() {
	      var _this2 = this;
	
	      var streamName = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
	      var promise = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	
	      debug('[publish]');
	      this._options.streamName = streamName || this._options.streamName;
	      this._options.streamMode = this._options.streamMode || _publish.PublishModeTypes.LIVE;
	      var p = promise || new _promise.DeferredPromise();
	      var socketPromise = new _promise.DeferredPromise();
	      var socketurl = endpointFromOptions(this._options);
	      this._trickleEndFuture = this._getTrickleEnd();
	      this._socketHelper.setUp(socketurl, socketPromise);
	      // 0. Establish socket connection.
	      socketPromise.promise
	      // 1. Wait for stream attach
	      .then(function () {
	        _this2.trigger(new _event.PublisherEvent(_event.PublisherEventTypes.CONNECT_SUCCESS, _this2));
	        return _this2._getMediaStream();
	      })
	      // 2. Request available stream to publish on
	      .then(function (mediaStream) {
	        _this2._mediaStream = mediaStream;
	        _this2.trigger(new _event.PublisherEvent(_event.RTCPublisherEventTypes.MEDIA_STREAM_AVAILABLE, _this2, mediaStream));
	        return _this2.requestAvailability(_this2._options.streamName, _this2._options.streamType || defaultStreamType);
	      })
	      // 3. Create Peer Connection
	      .then(function () {
	        return _this2.createPeerConnection(_this2._options.iceServers);
	      })
	      // 4. Make Offer on Peer Connection
	      .then(function (connection) {
	        connection.addStream(_this2._mediaStream);
	        _this2.trigger(new _event.PublisherEvent(_event.RTCPublisherEventTypes.PEER_CONNECTION_AVAILABLE, _this2, connection));
	        _this2._options.publishConstraints = _this2._options.publishConstraint || _browser2.default.getDefaultPublishConstraints();
	        return _this2.createOffer(_this2._options.publishConstraints, _this2._options.bandwidth);
	      })
	      // 5. Send Offer
	      .then(function (sessionDescription) {
	        _this2.trigger(new _event.PublisherEvent(_event.RTCPublisherEventTypes.OFFER_START, _this2, sessionDescription));
	        return _this2.sendOffer(sessionDescription, _this2._options.streamName);
	      })
	      // 6. Set the session description remotely
	      .then(function (sdp) {
	        return _this2.setRemoteDescription(sdp.sdp);
	      })
	      // 7. Wait until ice trickle end
	      .then(function (sdp) {
	        _this2.trigger(new _event.PublisherEvent(_event.RTCPublisherEventTypes.OFFER_END, _this2, sdp));
	        return _this2._getTrickleEnd().promise;
	      })
	      // 8. Request to publish stream
	      .then(function () {
	        _this2.trigger(new _event.PublisherEvent(_event.RTCPublisherEventTypes.ICE_TRICKLE_COMPLETE, _this2));
	        return _this2.requestPublish(_this2._options.streamName, _this2._options.streamMode);
	      })
	      // 9. Results in socket message of publish (see :onPublishStatus)
	      .then(function () {
	        p.resolve(_this2);
	        _this2.trigger(new _event.PublisherEvent(_event.PublisherEventTypes.PUBLISH_START, _this2));
	      }).catch(function (error) {
	        p.reject(error);
	        _this2.trigger(new _event.PublisherEvent(_event.PublisherEventTypes.CONNECT_FAILURE, _this2, error));
	      });
	      return p.hasOwnProperty('promise') ? p.promise : p;
	    }
	  }, {
	    key: 'unpublish',
	    value: function unpublish() {
	      var _this3 = this;
	
	      debug('[unpublish]');
	      if (this._socketHelper) {
	        this._socketHelper.tearDown();
	      }
	      if (this._peerHelper) {
	        this._peerHelper.tearDown();
	      }
	      this.detachStream();
	      this._availableFuture = undefined;
	      this._peerFuture = undefined;
	      this._offerFuture = undefined;
	      this._sendOfferFuture = undefined;
	      this._trickleEndFuture = undefined;
	      this._publishFuture = undefined;
	      var f = this.requestUnpublish(this._options.streamName);
	      f.then(function () {
	        _this3._unpublishFuture = undefined;
	        _this3.trigger(new _event.PublisherEvent(_event.PublisherEventTypes.UNPUBLISH_SUCCESS, _this3));
	      });
	      return f;
	    }
	  }, {
	    key: 'onStreamAvailable',
	    value: function onStreamAvailable(receipt) {
	      debug('[onstreamavailable]: ' + JSON.stringify(receipt, null, 2));
	      this._availableFuture = _promise.Future.createIfNotExist(this._availableFuture);
	      this._availableFuture.reject('Stream with name ' + this._options.streamName + ' already has a broadcast session.');
	      this.trigger(new _event.PublisherEvent(_event.PublisherEventTypes.PUBLISH_INVALID_NAME, this));
	    }
	  }, {
	    key: 'onStreamUnavailable',
	    value: function onStreamUnavailable(receipt) {
	      // Being unavailable, is a good thing for allowing to publish using `options.streamName`
	      debug('Stream ' + this._options.streamName + ' does not exist.');
	      debug('[onstreamunavailable]: ' + JSON.stringify(receipt, null, 2));
	      this._availableFuture = _promise.Future.createIfNotExist(this._availableFuture);
	      this._availableFuture.resolve(true);
	    }
	  }, {
	    key: 'onSocketMessageError',
	    value: function onSocketMessageError(message) {
	      var detail = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	
	      error('Error in stream playback: ' + message + '.\n[Optional detail]: ' + detail);
	      if (this._publishFuture) {
	        this.trigger(new _event.PublisherEvent(_event.PublisherEventTypes.PUBLISH_FAIL, this));
	        this._publishFuture.reject(message);
	      }
	    }
	  }, {
	    key: 'onSDPSuccess',
	    value: function onSDPSuccess(receipt) {
	      var info = receipt ? ': ' + JSON.stringify(receipt, null, 2) : '';
	      debug('[onsdpsuccess]' + info);
	    }
	  }, {
	    key: 'onSDPError',
	    value: function onSDPError(receipt) {
	      var error = receipt ? ': ' + JSON.stringify(receipt, null, 2) : '';
	      error('[onsdperror]' + error);
	    }
	  }, {
	    key: 'onSDPAnswer',
	    value: function onSDPAnswer(sdp) {
	      debug('[sdpanswer]');
	      this._sendOfferFuture = _promise.Future.createIfNotExist(this._sendOfferFuture);
	      this._sendOfferFuture.resolve(sdp);
	    }
	  }, {
	    key: 'onAddIceCandidate',
	    value: function onAddIceCandidate(candidate) {
	      debug('[addicecandidate]');
	      this._peerHelper.addIceCandidate(candidate).then(function () {
	        debug('[addicecandidate:success]');
	      }).catch(function (err) {
	        warn('[addicecandidate:error] - ' + err);
	      });
	    }
	  }, {
	    key: 'onIceCandidate',
	    value: function onIceCandidate(candidate) {
	      debug('[icecandidatetrickle]');
	      this.sendCandidate(candidate, this._options.streamName);
	    }
	  }, {
	    key: 'onIceCandidateTrickleEnd',
	    value: function onIceCandidateTrickleEnd() {
	      debug('[icecandidatetrickle:end]');
	    }
	  }, {
	    key: 'onSocketIceCandidateEnd',
	    value: function onSocketIceCandidateEnd() {
	      debug('[socketicecandidate:end]');
	      this._getTrickleEnd().resolve();
	      this._trickleEndFuture = undefined;
	    }
	  }, {
	    key: 'onPublisherStatus',
	    value: function onPublisherStatus(status) {
	      debug('[publisherstatus] - ' + JSON.stringify(status, null, 2));
	      var stopResult = pubStopRegex.exec(status.message);
	      var startResult = pubStartRegex.exec(status.message);
	      if (stopResult && stopResult[1] === this._options.streamName) {
	        this._unpublishFuture.resolve();
	      } else if (startResult && startResult[1] === this._options.streamName) {
	        this._publishFuture.resolve();
	      } else {
	        warn('Publisher status received, but could not handle.');
	      }
	    }
	  }, {
	    key: 'getPeerConnection',
	    value: function getPeerConnection() {
	      return this._peerHelper ? this._peerHelper.connection : undefined;
	    }
	  }, {
	    key: 'getMediaStream',
	    value: function getMediaStream() {
	      return this._mediaStream;
	    }
	  }, {
	    key: 'getType',
	    value: function getType() {
	      return _publish.PublishTypes.RTC.toUpperCase();
	    }
	  }, {
	    key: 'socket',
	    get: function get() {
	      return this._websocket;
	    }
	  }]);
	
	  return RTCPublisher;
	}(_eventEmitter2.default);
	
	exports.default = RTCPublisher;

/***/ },
/* 332 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _socketHelper = __webpack_require__(310);
	
	var _socketHelper2 = _interopRequireDefault(_socketHelper);
	
	var _log = __webpack_require__(300);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var NAME = 'R5ProPublisherSocket';
	
	var PublisherSocketHelper = function (_SocketHelper) {
	  _inherits(PublisherSocketHelper, _SocketHelper);
	
	  function PublisherSocketHelper(responder) {
	    _classCallCheck(this, PublisherSocketHelper);
	
	    return _possibleConstructorReturn(this, Object.getPrototypeOf(PublisherSocketHelper).call(this, responder, NAME));
	  }
	
	  _createClass(PublisherSocketHelper, [{
	    key: 'respond',
	    value: function respond(message) {
	      //    console.log(message)
	      if (message.data) {
	        var json = this.getJsonFromSocketMessage(message);
	        try {
	          if (!_get(Object.getPrototypeOf(PublisherSocketHelper.prototype), 'respond', this).call(this, message)) {
	            if (json.data !== undefined) {
	              if (json.data.sdp !== undefined) {
	                if (json.data.sdp.type === 'answer') {
	                  this._responder.onSDPAnswer(json.data);
	                }
	              }
	              if (json.data.candidate !== undefined) {
	                this._responder.onAddIceCandidate(json.data.candidate);
	              }
	              if (json.data.type === 'status') {
	                if (json.data.code === 'NetConnection.ICE.TricleCompleted') {
	                  this._responder.onSocketIceCandidateEnd();
	                } else {
	                  this._responder.onPublisherStatus(json.data);
	                }
	              }
	            }
	          }
	        } catch (e) {
	          (0, _log.error)(NAME, '[ws.onmessage] - Error in accessing message data as JSON. ' + e.message);
	          this._responder.onSocketMessageError('[ws.onmessage] - Error in accessing message data as JSON. ' + e.message);
	        }
	      } else {
	        (0, _log.warn)(NAME, '[ws.onmessage] - No Message Data.');
	      }
	    }
	  }]);
	
	  return PublisherSocketHelper;
	}(_socketHelper2.default);
	
	exports.default = PublisherSocketHelper;

/***/ },
/* 333 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _webrtc = __webpack_require__(316);
	
	var webrtc = _interopRequireWildcard(_webrtc);
	
	var _promise = __webpack_require__(313);
	
	var _log = __webpack_require__(300);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var NAME = 'R5ProPublishPeer';
	
	var PublisherPeerHelper = function () {
	  function PublisherPeerHelper(responder) {
	    _classCallCheck(this, PublisherPeerHelper);
	
	    this._responder = responder;
	    this._peerConnection = undefined;
	  }
	
	  _createClass(PublisherPeerHelper, [{
	    key: '_removeConnectionHandlers',
	    value: function _removeConnectionHandlers(connection) {
	      connection.onconnectionstatechange = undefined;
	      connection.onicecandidate = undefined;
	    }
	  }, {
	    key: '_addConnectionHandlers',
	    value: function _addConnectionHandlers(connection, promise) {
	      var _this = this;
	
	      connection.onconnectionstatechange = function () {
	        if (connection.connectionState === 'connected') {
	          (0, _log.debug)(NAME, '[peerconnection:open]');
	          if (promise) {
	            promise.resolve(_this);
	          }
	        } else if (connection.connectionState === 'failed' || connection.connectionState === 'disconnected') {
	          (0, _log.warn)(NAME, '[peerconnection:error]');
	          if (promise) {
	            promise.reject();
	          }
	        }
	      };
	
	      connection.onicecandidate = function (event) {
	        (0, _log.debug)(NAME, '[peer.onicecandidate] - Peer Candidate: ' + event.candidate);
	        if (event.candidate) {
	          _this._responder.onIceCandidate(event.candidate);
	        } else if (event.candidate === null) {
	          // null means they have finished sending candidates back and forth?
	          // Moved to notification from server on trickle end event.
	          // this._responder.onIceCandidateTrickleEnd()
	        }
	      };
	    }
	  }, {
	    key: 'createOffer',
	    value: function createOffer() {
	      var _this2 = this;
	
	      var bandwidth = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
	      var offerPromise = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	
	      (0, _log.debug)(NAME, '[createoffer]');
	      var p = offerPromise || new _promise.DeferredPromise();
	      this._peerConnection.createOffer().then(function (sessionDescription) {
	        _this2.setLocalDescription(sessionDescription, bandwidth).then(function () {
	          _this2._responder.onSDPSuccess();
	          p.resolve(sessionDescription);
	        }).catch(function (err) {
	          _this2._responder.onSDPError(err);
	          p.reject(err);
	        });
	      }).catch(function (err) {
	        (0, _log.debug)(NAME, '[createoffer:error]');
	        p.reject(err);
	      });
	      return p.hasOwnProperty('promise') ? p.promise : p;
	    }
	  }, {
	    key: 'setLocalDescription',
	    value: function setLocalDescription(sessionDescription) {
	      var bandwidth = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	
	      (0, _log.debug)(NAME, '[setlocaldescription]');
	      if (bandwidth) {
	        sessionDescription.sdp = webrtc.updateBandwidth(bandwidth, sessionDescription.sdp);
	      }
	      return this._peerConnection.setLocalDescription(sessionDescription);
	    }
	  }, {
	    key: 'setRemoteDescription',
	    value: function setRemoteDescription(sdp) {
	      (0, _log.debug)(NAME, '[setremotedescription]');
	      return this._peerConnection.setRemoteDescription(new webrtc.RTCSessionDescription(sdp));
	    }
	  }, {
	    key: 'addIceCandidate',
	    value: function addIceCandidate(candidate) {
	      (0, _log.debug)(NAME, '[addcandidate]');
	      return this._peerConnection.addIceCandidate(candidate);
	    }
	  }, {
	    key: 'setUp',
	    value: function setUp(iceServers) {
	      var setUpPromise = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	
	      this.tearDown();
	      (0, _log.debug)(NAME, '[setup]');
	      var p = setUpPromise || new _promise.DeferredPromise();
	      try {
	        var peer = new webrtc.RTCPeerConnection({
	          iceServers: iceServers
	        }, {
	          optional: [{ DtlsSrtpKeyAgreement: true }, { RtpDataChannels: false }, { googCpuOveruseDetection: true }]
	        });
	        this._addConnectionHandlers(peer);
	        this._peerConnection = peer;
	        p.resolve(peer);
	      } catch (e) {
	        (0, _log.warn)(NAME, 'Could not establish a PeerConnection. ' + e.message);
	        p.reject(e.message);
	      }
	      return p.hasOwnProperty('promise') ? p.promise : p;
	    }
	  }, {
	    key: 'tearDown',
	    value: function tearDown() {
	      (0, _log.debug)(NAME, '[teardown]');
	      if (this._peerConnection) {
	        this._removeConnectionHandlers(this._peerConnection);
	        try {
	          this._peerConnection.close();
	        } catch (e) {
	          (0, _log.warn)(NAME, '[peerconnection.close] error: ' + e.message);
	        }
	      }
	    }
	  }, {
	    key: 'connection',
	    get: function get() {
	      return this._peerConnection;
	    }
	  }]);
	
	  return PublisherPeerHelper;
	}();
	
	exports.default = PublisherPeerHelper;

/***/ },
/* 334 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	'use script';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.PlaybackView = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _browser = __webpack_require__(312);
	
	var _browser2 = _interopRequireDefault(_browser);
	
	var _log = __webpack_require__(300);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var NAME = 'R5ProPlaybackView';
	var playbackId = 'red5pro-subscriber';
	
	var PlaybackView = exports.PlaybackView = function () {
	  function PlaybackView() {
	    var elementId = arguments.length <= 0 || arguments[0] === undefined ? playbackId : arguments[0];
	
	    _classCallCheck(this, PlaybackView);
	
	    try {
	      // Target video element.
	      this._targetElement = _browser2.default.resolveElement(elementId);
	    } catch (e) {
	      (0, _log.error)(NAME, 'Could not instantiate a new instance of Red5ProSubscriber. Reason: ' + e.message);
	      throw e;
	    }
	  }
	
	  _createClass(PlaybackView, [{
	    key: 'attachSubscriber',
	    value: function attachSubscriber(subscriber) {
	      (0, _log.debug)(NAME, '[attachsubscriber]');
	      subscriber.setView(this);
	    }
	  }, {
	    key: 'attachStream',
	    value: function attachStream(mediaStream) {
	      var autoplay = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
	
	      (0, _log.debug)(NAME, '[attachstream]: autoplay(' + autoplay + ')');
	      _browser2.default.setVideoSource(this._targetElement, mediaStream, autoplay);
	    }
	  }, {
	    key: 'stop',
	    value: function stop() {
	      (0, _log.debug)(NAME, '[stop]');
	      try {
	        this._targetElement.pause();
	      } catch (e) {
	        (0, _log.warn)(NAME, 'Could not stop video element: ' + e.message);
	      }
	    }
	  }, {
	    key: 'view',
	    get: function get() {
	      return this._targetElement;
	    }
	  }]);
	
	  return PlaybackView;
	}();
	
	exports.default = PlaybackView;

/***/ },
/* 335 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _browser = __webpack_require__(312);
	
	var _browser2 = _interopRequireDefault(_browser);
	
	var _log = __webpack_require__(300);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var NAME = 'R5ProPublishView';
	
	var publisherId = 'red5pro-publisher';
	
	var PublishView = function () {
	  function PublishView() {
	    var elementId = arguments.length <= 0 || arguments[0] === undefined ? publisherId : arguments[0];
	
	    _classCallCheck(this, PublishView);
	
	    try {
	      this._targetElement = _browser2.default.resolveElement(elementId);
	    } catch (e) {
	      (0, _log.error)(NAME, 'Could not instantiate a new instance of Red5ProPublisher. Reason: ' + e.message);
	      throw e;
	    }
	  }
	
	  _createClass(PublishView, [{
	    key: 'attachPublisher',
	    value: function attachPublisher(publisher) {
	      (0, _log.debug)(NAME, '[attachpublisher]');
	      publisher.setView(this);
	    }
	  }, {
	    key: 'preview',
	    value: function preview(mediaStream) {
	      var autoplay = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
	
	      (0, _log.debug)(NAME, '[preview]: autoplay(' + autoplay + ')');
	      _browser2.default.setVideoSource(this._targetElement, mediaStream, autoplay);
	    }
	  }, {
	    key: 'view',
	    get: function get() {
	      return this._targetElement;
	    }
	  }]);
	
	  return PublishView;
	}();
	
	exports.default = PublishView;

/***/ }
/******/ ])
});
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCAwMjYxOTYzMDNmZWFkYjBhOTk3NSIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXBvbHlmaWxsL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvc2hpbS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3ltYm9sLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2hhcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fZGVzY3JpcHRvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2ZhaWxzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19leHBvcnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2NvcmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2hpZGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1kcC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fYW4tb2JqZWN0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19pcy1vYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2llOC1kb20tZGVmaW5lLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19kb20tY3JlYXRlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL190by1wcmltaXRpdmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3Byb3BlcnR5LWRlc2MuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3JlZGVmaW5lLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL191aWQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2N0eC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fYS1mdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fbWV0YS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fc2hhcmVkLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19zZXQtdG8tc3RyaW5nLXRhZy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fd2tzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL193a3MtZXh0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL193a3MtZGVmaW5lLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19saWJyYXJ5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19rZXlvZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1rZXlzLWludGVybmFsLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL190by1pb2JqZWN0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19pb2JqZWN0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19jb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2RlZmluZWQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2FycmF5LWluY2x1ZGVzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL190by1sZW5ndGguanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3RvLWludGVnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3RvLWluZGV4LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19zaGFyZWQta2V5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19lbnVtLWJ1Zy1rZXlzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19lbnVtLWtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1nb3BzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtcGllLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19pcy1hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWRwcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9faHRtbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcG4tZXh0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcGQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydGllcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LXNhcC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmdldC1wcm90b3R5cGUtb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3RvLW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdwby5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LW5hbWVzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuZnJlZXplLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3Quc2VhbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnByZXZlbnQtZXh0ZW5zaW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmlzLWZyb3plbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmlzLXNlYWxlZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmlzLWV4dGVuc2libGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5hc3NpZ24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1hc3NpZ24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5pcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fc2FtZS12YWx1ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnNldC1wcm90b3R5cGUtb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3NldC1wcm90by5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fY2xhc3NvZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuZnVuY3Rpb24uYmluZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fYmluZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9faW52b2tlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5mdW5jdGlvbi5uYW1lLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5mdW5jdGlvbi5oYXMtaW5zdGFuY2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnBhcnNlLWludC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fcGFyc2UtaW50LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19zdHJpbmctdHJpbS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLXdzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5wYXJzZS1mbG9hdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fcGFyc2UtZmxvYXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5jb25zdHJ1Y3Rvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9faW5oZXJpdC1pZi1yZXF1aXJlZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLnRvLWZpeGVkLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19hbi1pbnN0YW5jZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fYS1udW1iZXItdmFsdWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1yZXBlYXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci50by1wcmVjaXNpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5lcHNpbG9uLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuaXMtZmluaXRlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuaXMtaW50ZWdlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9faXMtaW50ZWdlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmlzLW5hbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmlzLXNhZmUtaW50ZWdlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLm1heC1zYWZlLWludGVnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5taW4tc2FmZS1pbnRlZ2VyLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIucGFyc2UtZmxvYXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5wYXJzZS1pbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguYWNvc2guanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX21hdGgtbG9nMXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguYXNpbmguanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguYXRhbmguanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguY2JydC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fbWF0aC1zaWduLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmNsejMyLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmNvc2guanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguZXhwbTEuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX21hdGgtZXhwbTEuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguZnJvdW5kLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmh5cG90LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmltdWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGgubG9nMTAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGgubG9nMXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGgubG9nMi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5zaWduLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLnNpbmguanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGgudGFuaC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC50cnVuYy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmZyb20tY29kZS1wb2ludC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnJhdy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnRyaW0uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLWF0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19pdGVyLWRlZmluZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9faXRlcmF0b3JzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19pdGVyLWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmNvZGUtcG9pbnQtYXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5lbmRzLXdpdGguanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1jb250ZXh0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19pcy1yZWdleHAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2ZhaWxzLWlzLXJlZ2V4cC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmluY2x1ZGVzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcucmVwZWF0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuc3RhcnRzLXdpdGguanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5hbmNob3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1odG1sLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuYmlnLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuYmxpbmsuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5ib2xkLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuZml4ZWQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5mb250Y29sb3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5mb250c2l6ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLml0YWxpY3MuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5saW5rLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuc21hbGwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5zdHJpa2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5zdWIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5zdXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmRhdGUubm93LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5kYXRlLnRvLWpzb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmRhdGUudG8taXNvLXN0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuZGF0ZS50by1zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmRhdGUudG8tcHJpbWl0aXZlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19kYXRlLXRvLXByaW1pdGl2ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuaXMtYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZyb20uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2l0ZXItY2FsbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9faXMtYXJyYXktaXRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fY3JlYXRlLXByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9faXRlci1kZXRlY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lm9mLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5qb2luLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19zdHJpY3QtbWV0aG9kLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5zbGljZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuc29ydC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZm9yLWVhY2guanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2FycmF5LW1ldGhvZHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2FycmF5LXNwZWNpZXMtY3JlYXRlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19hcnJheS1zcGVjaWVzLWNvbnN0cnVjdG9yLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5tYXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuc29tZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZXZlcnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnJlZHVjZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fYXJyYXktcmVkdWNlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5yZWR1Y2UtcmlnaHQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmluZGV4LW9mLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5sYXN0LWluZGV4LW9mLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5jb3B5LXdpdGhpbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fYXJyYXktY29weS13aXRoaW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2FkZC10by11bnNjb3BhYmxlcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZmlsbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fYXJyYXktZmlsbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZmluZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZmluZC1pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuc3BlY2llcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fc2V0LXNwZWNpZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lml0ZXJhdG9yLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19pdGVyLXN0ZXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5jb25zdHJ1Y3Rvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fZmxhZ3MuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC50by1zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5mbGFncy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLm1hdGNoLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19maXgtcmUtd2tzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAucmVwbGFjZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLnNlYXJjaC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLnNwbGl0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5wcm9taXNlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19mb3Itb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3NwZWNpZXMtY29uc3RydWN0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3Rhc2suanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX21pY3JvdGFzay5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fcmVkZWZpbmUtYWxsLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2NvbGxlY3Rpb24tc3Ryb25nLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19jb2xsZWN0aW9uLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zZXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LndlYWstbWFwLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19jb2xsZWN0aW9uLXdlYWsuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LndlYWstc2V0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5hcnJheS1idWZmZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3R5cGVkLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL190eXBlZC1idWZmZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmRhdGEtdmlldy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuaW50OC1hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fdHlwZWQtYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvY29yZS5pcy1pdGVyYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQudWludDgtYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQ4LWNsYW1wZWQtYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmludDE2LWFycmF5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC51aW50MTYtYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmludDMyLWFycmF5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC51aW50MzItYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmZsb2F0MzItYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmZsb2F0NjQtYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuYXBwbHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuY29uc3RydWN0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmRlZmluZS1wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5kZWxldGUtcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZW51bWVyYXRlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmdldC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5oYXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuaXMtZXh0ZW5zaWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5vd24ta2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fb3duLWtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QucHJldmVudC1leHRlbnNpb25zLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LnNldC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5zZXQtcHJvdG90eXBlLW9mLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5hcnJheS5pbmNsdWRlcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLmF0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcucGFkLXN0YXJ0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19zdHJpbmctcGFkLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcucGFkLWVuZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLnRyaW0tbGVmdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLnRyaW0tcmlnaHQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnN0cmluZy5tYXRjaC1hbGwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnN5bWJvbC5hc3luYy1pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczcuc3ltYm9sLm9ic2VydmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QudmFsdWVzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtdG8tYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5lbnRyaWVzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QuZGVmaW5lLWdldHRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWZvcmNlZC1wYW0uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5kZWZpbmUtc2V0dGVyLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QubG9va3VwLWdldHRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0Lmxvb2t1cC1zZXR0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hcC50by1qc29uLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19jb2xsZWN0aW9uLXRvLWpzb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2FycmF5LWZyb20taXRlcmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnNldC50by1qc29uLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5zeXN0ZW0uZ2xvYmFsLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5lcnJvci5pcy1lcnJvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5pYWRkaC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5pc3ViaC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5pbXVsaC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC51bXVsaC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5kZWZpbmUtbWV0YWRhdGEuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX21ldGFkYXRhLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0LmRlbGV0ZS1tZXRhZGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtbWV0YWRhdGEuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW1ldGFkYXRhLWtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW93bi1tZXRhZGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtb3duLW1ldGFkYXRhLWtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuaGFzLW1ldGFkYXRhLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0Lmhhcy1vd24tbWV0YWRhdGEuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QubWV0YWRhdGEuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LmFzYXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm9ic2VydmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvd2ViLnRpbWVycy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fcGFydGlhbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fcGF0aC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy93ZWIuaW1tZWRpYXRlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9ub2RlLWxpYnMtYnJvd3Nlci9+L3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvZm4vcmVnZXhwL2VzY2FwZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9jb3JlLnJlZ2V4cC5lc2NhcGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3JlcGxhY2VyLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbG9nL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vYnJvd3Nlci1idW55YW4vbGliL2J1bnlhbi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbG9nL2J1bnlhbi13cml0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2V2ZW50L3B1Ymxpc2hlci1ldmVudC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvZXZlbnQvc3Vic2NyaWJlci1ldmVudC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvc3Vic2NyaWJlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvY29yZS9ldmVudC1lbWl0dGVyLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9zdWJzY3JpYmVyL3JlZDVwcm8tcnRjLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9ldmVudC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvaGVscGVyL3NvY2tldC1oZWxwZXItc3ViLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9oZWxwZXIvc29ja2V0LWhlbHBlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvYWRhcHRlci93ZWJzb2NrZXQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2Vudi9icm93c2VyLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy91dGlsL3Byb21pc2UuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2V4Y2VwdGlvbi9lcnJvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2hlbHBlci93ZWJydGMtaGVscGVyLXN1Yi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvYWRhcHRlci93ZWJydGMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL3N1YnNjcmliZXIvcmVkNXByby1obHMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL3N1YnNjcmliZXIvdmlkZW9qcy1zb3VyY2UtaGFuZGxlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvdXRpbC9vYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL3N1YnNjcmliZXIvcmVkNXByby1ydG1wLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9zdWJzY3JpYmVyL3JlZDVwcm8tcnRtcC12aWRlb2pzLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9zdWJzY3JpYmVyL3JlZDVwcm8tcnRtcC1saXZlLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9zdWJzY3JpYmVyL2xpdmUtc291cmNlLWhhbmRsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2Vudi9lbWJlZC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvdXRpbC9pbXBsLWZhY3Rvcnktb3JkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2VudW0vcGxheWJhY2suanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL3B1Ymxpc2hlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvcHVibGlzaGVyL3JlZDVwcm8tcnRtcC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvZW51bS9wdWJsaXNoLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9wdWJsaXNoZXIvcHViLXNvdXJjZS1oYW5kbGVyLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9wdWJsaXNoZXIvcmVkNXByby1ydGMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2hlbHBlci9zb2NrZXQtaGVscGVyLXB1Yi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvaGVscGVyL3dlYnJ0Yy1oZWxwZXItcHViLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy92aWV3L3BsYXliYWNrLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy92aWV3L3B1Ymxpc2guanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELE87QUNWQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUN0Q0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUMsRTs7Ozs7OztBQy9CRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDOzs7Ozs7QUMvS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUEyQixpQkFBaUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFOzs7Ozs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILEc7Ozs7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQWtCO0FBQ2xCLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSxNQUFLO0FBQ0w7QUFDQSxFQUFDLEU7Ozs7OztBQ2pIRDtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0gsRzs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHOzs7Ozs7QUNKQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU8sTUFBTTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILEc7Ozs7OztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLEU7Ozs7OztBQ05EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUMsRTs7Ozs7O0FDTkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQyxFOzs7Ozs7QUNORDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLEU7Ozs7OztBQ05EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUMsRTs7Ozs7O0FDTkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQyxFOzs7Ozs7QUNORDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLEU7Ozs7OztBQ05EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUMsRTs7Ozs7O0FDTkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQyxFOzs7Ozs7QUNORDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLEU7Ozs7OztBQ05EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUMsRTs7Ozs7O0FDTkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQyxFOzs7Ozs7QUNORDtBQUNBOztBQUVBLDZCQUE0QixnQkFBZ0IsNkJBQTZCLEdBQUcsRTs7Ozs7O0FDSDVFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUVBQXdFLHdCQUF3QixVQUFVLEdBQUc7QUFDN0csRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLEU7Ozs7OztBQ2JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0gsRzs7Ozs7O0FDZkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLEU7Ozs7OztBQ1REO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQyxFOzs7Ozs7QUNURDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUMsRTs7Ozs7O0FDVEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLEU7Ozs7OztBQ1REO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQyxFOzs7Ozs7QUNURDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU8sc0NBQXNDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLEc7Ozs7OztBQzNCQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUMsRTs7Ozs7O0FDVEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQyxFOzs7Ozs7QUNkRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVMsV0FBVztBQUNwQjtBQUNBO0FBQ0EsRUFBQyxFOzs7Ozs7QUNyQkQ7QUFDQTs7QUFFQSw4QkFBNkIscUNBQTRDOztBQUV6RSx3Qzs7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFzRTtBQUN0RTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUCxNQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUgsdUJBQXNCLHNCQUFzQixFQUFFLEVBQUU7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkNBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBK0IsYUFBYTtBQUM1QztBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBb0IsMEJBQTBCO0FBQzlDLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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K0IsU0FBUyxFOzs7Ozs7QUNwQnhDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQyxFOzs7Ozs7QUNURDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUMsRTs7Ozs7O0FDVEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUMsRTs7Ozs7O0FDUEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUMsRTs7Ozs7O0FDVkQ7QUFDQTs7QUFFQSxnQ0FBK0Isa0NBQWdDLEU7Ozs7OztBQ0gvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHOzs7Ozs7QUNUQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsRUFBQyxFOzs7Ozs7QUNmRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0NBQStCLFNBQVMsRTs7Ozs7O0FDOUJ4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEVBQUMsRTs7Ozs7O0FDZEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVELHNDOzs7Ozs7QUNYQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUMsRTs7Ozs7O0FDVEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLEU7Ozs7OztBQ1REO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNmQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUMsRTs7Ozs7O0FDVEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQyxlOzs7Ozs7QUNORDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLGE7Ozs7OztBQ05EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVU7QUFDVixFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQyxFOzs7Ozs7QUM3QkQsMEM7Ozs7OztBQ0FBLHVDOzs7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUMsRTs7Ozs7O0FDbEJEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUMsRTs7Ozs7O0FDUkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSxHOzs7Ozs7QUNmQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLEU7Ozs7OztBQ1JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkNBQTBDLDZEQUE2RDtBQUN2RztBQUNBLEVBQUMsRTs7Ozs7O0FDWEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNEMsYUFBYTtBQUN6RDtBQUNBLEVBQUMsRTs7Ozs7O0FDTkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMEMsNkRBQTZEO0FBQ3ZHO0FBQ0EsRUFBQyxFOzs7Ozs7QUNYRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLEVBQUMsRTs7Ozs7O0FDakJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsRUFBQyxFOzs7Ozs7QUNqQkQ7QUFDQTs7QUFFQSx3Q0FBdUMsd0NBQWdELEU7Ozs7OztBQ0h2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRzs7Ozs7O0FDUkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ05BO0FBQ0E7O0FBRUEsd0NBQXVDLHdDQUFnRCxFOzs7Ozs7QUNIdkY7QUFDQTs7QUFFQSwrQkFBOEIsK0JBQTZCLEU7Ozs7OztBQ0gzRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLEU7Ozs7OztBQ1JEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLEU7Ozs7OztBQ1ZEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLEU7Ozs7OztBQ1ZEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQyxFOzs7Ozs7QUNmRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUMsRTs7Ozs7O0FDZkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBYztBQUNkO0FBQ0EsR0FBRSxFOzs7Ozs7QUNQRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBc0QsZ0JBQWdCLEVBQUU7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHOzs7Ozs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFLEU7Ozs7OztBQ2RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBYztBQUNkO0FBQ0EsR0FBRSxFOzs7Ozs7QUNoQkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBYztBQUNkO0FBQ0EsR0FBRSxFOzs7Ozs7QUNsQkY7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBYztBQUNkO0FBQ0E7QUFDQSxHQUFFLEU7Ozs7OztBQ1JGO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWM7QUFDZDtBQUNBLEdBQUUsRTs7Ozs7O0FDUEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBYztBQUNkO0FBQ0EsR0FBRSxFOzs7Ozs7QUNmRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFjO0FBQ2Q7QUFDQTtBQUNBLEdBQUUsRTs7Ozs7O0FDUkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFLEU7Ozs7OztBQ2RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFjO0FBQ2QsTUFBSztBQUNMLGVBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0EsWUFBVztBQUNYOztBQUVBO0FBQ0E7QUFDQSx5Q0FBd0MsV0FBVztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDRCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7O0FBRUEsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBaUMsa0JBQWtCO0FBQ25EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFpQjs7QUFFakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsYUFBWTtBQUNaOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQ0FBOEMsUUFBUTtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7O0FBRUEsWUFBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQSxZQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBLFlBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQSwrQ0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBLCtDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBLCtDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUMzcEJBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBMkI7QUFDM0I7QUFDQTtBQUNB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O0FBQ0w7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSxNQUFLO0FBQ0w7QUFDQSxNQUFLO0FBQ0w7QUFDQSxNQUFLO0FBQ0w7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQiw2QkFBNkI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsa0JBQWtCO0FB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RUFBWSxRQUFaO0FBQ0EsV0FBSTtBQUNGLGNBQUssY0FBTCxDQUFvQixLQUFwQjtBQUNELFFBRkQsQ0FFRSxPQUFPLENBQVAsRUFBVTtBQUNWLHdCQUFLLElBQUwscUNBQTRDLEVBQUUsT0FBOUM7QUFDRDtBQUNGOzs7eUJBRVc7QUFDVixjQUFPLEtBQUssY0FBWjtBQUNEOzs7Ozs7bUJBSVksWTs7Ozs7O0FDN0NmOzs7Ozs7OztBQUVBOzs7O0FBRUE7Ozs7OztBQUNBLEtBQU0sT0FBTyxrQkFBYjs7QUFFQSxLQUFNLGNBQWMsbUJBQXBCOztLQUVNLFc7QUFFSiwwQkFBc0M7QUFBQSxTQUF6QixTQUF5Qix5REFBYixXQUFhOztBQUFBOztBQUNwQyxTQUFJO0FBQ0YsWUFBSyxjQUFMLEdBQXNCLGtCQUFZLGNBQVosQ0FBMkIsU0FBM0IsQ0FBdEI7QUFDRCxNQUZELENBRUUsT0FBTyxDQUFQLEVBQVU7QUFDVix1QkFBTSxJQUFOLHlFQUFpRixFQUFFLE9BQW5GO0FBQ0EsYUFBTSxDQUFOO0FBQ0Q7QUFDRjs7OztxQ0FFZ0IsUyxFQUFXO0FBQzFCLHVCQUFNLElBQU4sRUFBWSxtQkFBWjtBQUNBLGlCQUFVLE9BQVYsQ0FBa0IsSUFBbEI7QUFDRDs7OzZCQUVRLFcsRUFBK0I7QUFBQSxXQUFsQixRQUFrQix5REFBUCxLQUFPOztBQUN0Qyx1QkFBTSxJQUFOLDJCQUFtQyxRQUFuQztBQUNBLHlCQUFZLGNBQVosQ0FBMkIsS0FBSyxjQUFoQyxFQUFnRCxXQUFoRCxFQUE2RCxRQUE3RDtBQUNEOzs7eUJBRVc7QUFDVixjQUFPLEtBQUssY0FBWjtBQUNEOzs7Ozs7bUJBSVksVyIsImZpbGUiOiJyZWQ1cHJvLXNkay5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcInJlZDVwcm9zZGtcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wicmVkNXByb3Nka1wiXSA9IGZhY3RvcnkoKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKCkge1xucmV0dXJuIFxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIHdlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvblxuICoqLyIsIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRleHBvcnRzOiB7fSxcbiBcdFx0XHRpZDogbW9kdWxlSWQsXG4gXHRcdFx0bG9hZGVkOiBmYWxzZVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogd2VicGFjay9ib290c3RyYXAgMDI2MTk2MzAzZmVhZGIwYTk5NzVcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxucmVxdWlyZShcImNvcmUtanMvc2hpbVwiKTtcblxucmVxdWlyZShcInJlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZVwiKTtcblxucmVxdWlyZShcImNvcmUtanMvZm4vcmVnZXhwL2VzY2FwZVwiKTtcblxuLyogZXNsaW50IG1heC1sZW46IDAgKi9cblxuaWYgKGdsb2JhbC5fYmFiZWxQb2x5ZmlsbCkge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJvbmx5IG9uZSBpbnN0YW5jZSBvZiBiYWJlbC1wb2x5ZmlsbCBpcyBhbGxvd2VkXCIpO1xufVxuZ2xvYmFsLl9iYWJlbFBvbHlmaWxsID0gdHJ1ZTtcblxuLy8gU2hvdWxkIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZTpcblxudmFyIERFRklORV9QUk9QRVJUWSA9IFwiZGVmaW5lUHJvcGVydHlcIjtcbmZ1bmN0aW9uIGRlZmluZShPLCBrZXksIHZhbHVlKSB7XG4gIE9ba2V5XSB8fCBPYmplY3RbREVGSU5FX1BST1BFUlRZXShPLCBrZXksIHtcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgdmFsdWU6IHZhbHVlXG4gIH0pO1xufVxuXG5kZWZpbmUoU3RyaW5nLnByb3RvdHlwZSwgXCJwYWRMZWZ0XCIsIFwiXCIucGFkU3RhcnQpO1xuZGVmaW5lKFN0cmluZy5wcm90b3R5cGUsIFwicGFkUmlnaHRcIiwgXCJcIi5wYWRFbmQpO1xuXG5cInBvcCxyZXZlcnNlLHNoaWZ0LGtleXMsdmFsdWVzLGVudHJpZXMsaW5kZXhPZixldmVyeSxzb21lLGZvckVhY2gsbWFwLGZpbHRlcixmaW5kLGZpbmRJbmRleCxpbmNsdWRlcyxqb2luLHNsaWNlLGNvbmNhdCxwdXNoLHNwbGljZSx1bnNoaWZ0LHNvcnQsbGFzdEluZGV4T2YscmVkdWNlLHJlZHVjZVJpZ2h0LGNvcHlXaXRoaW4sZmlsbFwiLnNwbGl0KFwiLFwiKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgW11ba2V5XSAmJiBkZWZpbmUoQXJyYXksIGtleSwgRnVuY3Rpb24uY2FsbC5iaW5kKFtdW2tleV0pKTtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXBvbHlmaWxsL2xpYi9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3ltYm9sJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5jcmVhdGUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmRlZmluZS1wcm9wZXJ0eScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnRpZXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LXByb3RvdHlwZS1vZicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3Qua2V5cycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuZnJlZXplJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5zZWFsJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5wcmV2ZW50LWV4dGVuc2lvbnMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmlzLWZyb3plbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuaXMtc2VhbGVkJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5pcy1leHRlbnNpYmxlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5hc3NpZ24nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmlzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5zZXQtcHJvdG90eXBlLW9mJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuZnVuY3Rpb24uYmluZCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5mdW5jdGlvbi5uYW1lJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmZ1bmN0aW9uLmhhcy1pbnN0YW5jZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5wYXJzZS1pbnQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucGFyc2UtZmxvYXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLmNvbnN0cnVjdG9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci50by1maXhlZCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIudG8tcHJlY2lzaW9uJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5lcHNpbG9uJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5pcy1maW5pdGUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLmlzLWludGVnZXInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLmlzLW5hbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIuaXMtc2FmZS1pbnRlZ2VyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5tYXgtc2FmZS1pbnRlZ2VyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5taW4tc2FmZS1pbnRlZ2VyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5wYXJzZS1mbG9hdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIucGFyc2UtaW50Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguYWNvc2gnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5hc2luaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmF0YW5oJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguY2JydCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmNsejMyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguY29zaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmV4cG0xJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguZnJvdW5kJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguaHlwb3QnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5pbXVsJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGgubG9nMTAnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5sb2cxcCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmxvZzInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5zaWduJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguc2luaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLnRhbmgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC50cnVuYycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuZnJvbS1jb2RlLXBvaW50Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5yYXcnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLnRyaW0nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5jb2RlLXBvaW50LWF0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5lbmRzLXdpdGgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmluY2x1ZGVzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5yZXBlYXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLnN0YXJ0cy13aXRoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5hbmNob3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmJpZycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuYmxpbmsnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmJvbGQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmZpeGVkJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5mb250Y29sb3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmZvbnRzaXplJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5pdGFsaWNzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5saW5rJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5zbWFsbCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuc3RyaWtlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5zdWInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLnN1cCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5kYXRlLm5vdycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5kYXRlLnRvLWpzb24nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuZGF0ZS50by1pc28tc3RyaW5nJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmRhdGUudG8tc3RyaW5nJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmRhdGUudG8tcHJpbWl0aXZlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmlzLWFycmF5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmZyb20nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkub2YnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuam9pbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5zbGljZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5zb3J0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmZvci1lYWNoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5Lm1hcCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5maWx0ZXInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuc29tZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5ldmVyeScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5yZWR1Y2UnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkucmVkdWNlLXJpZ2h0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmluZGV4LW9mJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5Lmxhc3QtaW5kZXgtb2YnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuY29weS13aXRoaW4nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuZmlsbCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5maW5kJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmZpbmQtaW5kZXgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuc3BlY2llcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWdleHAuY29uc3RydWN0b3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVnZXhwLnRvLXN0cmluZycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWdleHAuZmxhZ3MnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVnZXhwLm1hdGNoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZ2V4cC5yZXBsYWNlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZ2V4cC5zZWFyY2gnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVnZXhwLnNwbGl0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnByb21pc2UnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWFwJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnNldCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi53ZWFrLW1hcCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi53ZWFrLXNldCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC5hcnJheS1idWZmZXInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQuZGF0YS12aWV3Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLmludDgtYXJyYXknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQudWludDgtYXJyYXknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQudWludDgtY2xhbXBlZC1hcnJheScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC5pbnQxNi1hcnJheScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC51aW50MTYtYXJyYXknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQuaW50MzItYXJyYXknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQudWludDMyLWFycmF5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLmZsb2F0MzItYXJyYXknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQuZmxvYXQ2NC1hcnJheScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmFwcGx5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuY29uc3RydWN0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuZGVmaW5lLXByb3BlcnR5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuZGVsZXRlLXByb3BlcnR5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuZW51bWVyYXRlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0LXByb3RvdHlwZS1vZicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmhhcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmlzLWV4dGVuc2libGUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5vd24ta2V5cycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LnByZXZlbnQtZXh0ZW5zaW9ucycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LnNldCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LnNldC1wcm90b3R5cGUtb2YnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuYXJyYXkuaW5jbHVkZXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3RyaW5nLmF0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN0cmluZy5wYWQtc3RhcnQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3RyaW5nLnBhZC1lbmQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3RyaW5nLnRyaW0tbGVmdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zdHJpbmcudHJpbS1yaWdodCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zdHJpbmcubWF0Y2gtYWxsJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN5bWJvbC5hc3luYy1pdGVyYXRvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zeW1ib2wub2JzZXJ2YWJsZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9ycycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5vYmplY3QudmFsdWVzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9iamVjdC5lbnRyaWVzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9iamVjdC5kZWZpbmUtZ2V0dGVyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9iamVjdC5kZWZpbmUtc2V0dGVyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9iamVjdC5sb29rdXAtZ2V0dGVyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9iamVjdC5sb29rdXAtc2V0dGVyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hcC50by1qc29uJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnNldC50by1qc29uJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN5c3RlbS5nbG9iYWwnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuZXJyb3IuaXMtZXJyb3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWF0aC5pYWRkaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXRoLmlzdWJoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hdGguaW11bGgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWF0aC51bXVsaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5yZWZsZWN0LmRlZmluZS1tZXRhZGF0YScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5yZWZsZWN0LmRlbGV0ZS1tZXRhZGF0YScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5yZWZsZWN0LmdldC1tZXRhZGF0YScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5yZWZsZWN0LmdldC1tZXRhZGF0YS1rZXlzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW93bi1tZXRhZGF0YScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5yZWZsZWN0LmdldC1vd24tbWV0YWRhdGEta2V5cycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5yZWZsZWN0Lmhhcy1tZXRhZGF0YScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5yZWZsZWN0Lmhhcy1vd24tbWV0YWRhdGEnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucmVmbGVjdC5tZXRhZGF0YScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5hc2FwJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9ic2VydmFibGUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy93ZWIudGltZXJzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvd2ViLmltbWVkaWF0ZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9tb2R1bGVzL19jb3JlJyk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9zaGltLmpzXG4gKiogbW9kdWxlIGlkID0gMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuLy8gRUNNQVNjcmlwdCA2IHN5bWJvbHMgc2hpbVxudmFyIGdsb2JhbCAgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBoYXMgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgREVTQ1JJUFRPUlMgICAgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpXG4gICwgJGV4cG9ydCAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHJlZGVmaW5lICAgICAgID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKVxuICAsIE1FVEEgICAgICAgICAgID0gcmVxdWlyZSgnLi9fbWV0YScpLktFWVxuICAsICRmYWlscyAgICAgICAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKVxuICAsIHNoYXJlZCAgICAgICAgID0gcmVxdWlyZSgnLi9fc2hhcmVkJylcbiAgLCBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJylcbiAgLCB1aWQgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3VpZCcpXG4gICwgd2tzICAgICAgICAgICAgPSByZXF1aXJlKCcuL193a3MnKVxuICAsIHdrc0V4dCAgICAgICAgID0gcmVxdWlyZSgnLi9fd2tzLWV4dCcpXG4gICwgd2tzRGVmaW5lICAgICAgPSByZXF1aXJlKCcuL193a3MtZGVmaW5lJylcbiAgLCBrZXlPZiAgICAgICAgICA9IHJlcXVpcmUoJy4vX2tleW9mJylcbiAgLCBlbnVtS2V5cyAgICAgICA9IHJlcXVpcmUoJy4vX2VudW0ta2V5cycpXG4gICwgaXNBcnJheSAgICAgICAgPSByZXF1aXJlKCcuL19pcy1hcnJheScpXG4gICwgYW5PYmplY3QgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIHRvSU9iamVjdCAgICAgID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgdG9QcmltaXRpdmUgICAgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKVxuICAsIGNyZWF0ZURlc2MgICAgID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpXG4gICwgX2NyZWF0ZSAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJylcbiAgLCBnT1BORXh0ICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuLWV4dCcpXG4gICwgJEdPUEQgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpXG4gICwgJERQICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKVxuICAsICRrZXlzICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKVxuICAsIGdPUEQgICAgICAgICAgID0gJEdPUEQuZlxuICAsIGRQICAgICAgICAgICAgID0gJERQLmZcbiAgLCBnT1BOICAgICAgICAgICA9IGdPUE5FeHQuZlxuICAsICRTeW1ib2wgICAgICAgID0gZ2xvYmFsLlN5bWJvbFxuICAsICRKU09OICAgICAgICAgID0gZ2xvYmFsLkpTT05cbiAgLCBfc3RyaW5naWZ5ICAgICA9ICRKU09OICYmICRKU09OLnN0cmluZ2lmeVxuICAsIFBST1RPVFlQRSAgICAgID0gJ3Byb3RvdHlwZSdcbiAgLCBISURERU4gICAgICAgICA9IHdrcygnX2hpZGRlbicpXG4gICwgVE9fUFJJTUlUSVZFICAgPSB3a3MoJ3RvUHJpbWl0aXZlJylcbiAgLCBpc0VudW0gICAgICAgICA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlXG4gICwgU3ltYm9sUmVnaXN0cnkgPSBzaGFyZWQoJ3N5bWJvbC1yZWdpc3RyeScpXG4gICwgQWxsU3ltYm9scyAgICAgPSBzaGFyZWQoJ3N5bWJvbHMnKVxuICAsIE9QU3ltYm9scyAgICAgID0gc2hhcmVkKCdvcC1zeW1ib2xzJylcbiAgLCBPYmplY3RQcm90byAgICA9IE9iamVjdFtQUk9UT1RZUEVdXG4gICwgVVNFX05BVElWRSAgICAgPSB0eXBlb2YgJFN5bWJvbCA9PSAnZnVuY3Rpb24nXG4gICwgUU9iamVjdCAgICAgICAgPSBnbG9iYWwuUU9iamVjdDtcbi8vIERvbid0IHVzZSBzZXR0ZXJzIGluIFF0IFNjcmlwdCwgaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzE3M1xudmFyIHNldHRlciA9ICFRT2JqZWN0IHx8ICFRT2JqZWN0W1BST1RPVFlQRV0gfHwgIVFPYmplY3RbUFJPVE9UWVBFXS5maW5kQ2hpbGQ7XG5cbi8vIGZhbGxiYWNrIGZvciBvbGQgQW5kcm9pZCwgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTY4N1xudmFyIHNldFN5bWJvbERlc2MgPSBERVNDUklQVE9SUyAmJiAkZmFpbHMoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIF9jcmVhdGUoZFAoe30sICdhJywge1xuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIGRQKHRoaXMsICdhJywge3ZhbHVlOiA3fSkuYTsgfVxuICB9KSkuYSAhPSA3O1xufSkgPyBmdW5jdGlvbihpdCwga2V5LCBEKXtcbiAgdmFyIHByb3RvRGVzYyA9IGdPUEQoT2JqZWN0UHJvdG8sIGtleSk7XG4gIGlmKHByb3RvRGVzYylkZWxldGUgT2JqZWN0UHJvdG9ba2V5XTtcbiAgZFAoaXQsIGtleSwgRCk7XG4gIGlmKHByb3RvRGVzYyAmJiBpdCAhPT0gT2JqZWN0UHJvdG8pZFAoT2JqZWN0UHJvdG8sIGtleSwgcHJvdG9EZXNjKTtcbn0gOiBkUDtcblxudmFyIHdyYXAgPSBmdW5jdGlvbih0YWcpe1xuICB2YXIgc3ltID0gQWxsU3ltYm9sc1t0YWddID0gX2NyZWF0ZSgkU3ltYm9sW1BST1RPVFlQRV0pO1xuICBzeW0uX2sgPSB0YWc7XG4gIHJldHVybiBzeW07XG59O1xuXG52YXIgaXNTeW1ib2wgPSBVU0VfTkFUSVZFICYmIHR5cGVvZiAkU3ltYm9sLml0ZXJhdG9yID09ICdzeW1ib2wnID8gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnO1xufSA6IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGl0IGluc3RhbmNlb2YgJFN5bWJvbDtcbn07XG5cbnZhciAkZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBEKXtcbiAgaWYoaXQgPT09IE9iamVjdFByb3RvKSRkZWZpbmVQcm9wZXJ0eShPUFN5bWJvbHMsIGtleSwgRCk7XG4gIGFuT2JqZWN0KGl0KTtcbiAga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKTtcbiAgYW5PYmplY3QoRCk7XG4gIGlmKGhhcyhBbGxTeW1ib2xzLCBrZXkpKXtcbiAgICBpZighRC5lbnVtZXJhYmxlKXtcbiAgICAgIGlmKCFoYXMoaXQsIEhJRERFTikpZFAoaXQsIEhJRERFTiwgY3JlYXRlRGVzYygxLCB7fSkpO1xuICAgICAgaXRbSElEREVOXVtrZXldID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSlpdFtISURERU5dW2tleV0gPSBmYWxzZTtcbiAgICAgIEQgPSBfY3JlYXRlKEQsIHtlbnVtZXJhYmxlOiBjcmVhdGVEZXNjKDAsIGZhbHNlKX0pO1xuICAgIH0gcmV0dXJuIHNldFN5bWJvbERlc2MoaXQsIGtleSwgRCk7XG4gIH0gcmV0dXJuIGRQKGl0LCBrZXksIEQpO1xufTtcbnZhciAkZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoaXQsIFApe1xuICBhbk9iamVjdChpdCk7XG4gIHZhciBrZXlzID0gZW51bUtleXMoUCA9IHRvSU9iamVjdChQKSlcbiAgICAsIGkgICAgPSAwXG4gICAgLCBsID0ga2V5cy5sZW5ndGhcbiAgICAsIGtleTtcbiAgd2hpbGUobCA+IGkpJGRlZmluZVByb3BlcnR5KGl0LCBrZXkgPSBrZXlzW2krK10sIFBba2V5XSk7XG4gIHJldHVybiBpdDtcbn07XG52YXIgJGNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShpdCwgUCl7XG4gIHJldHVybiBQID09PSB1bmRlZmluZWQgPyBfY3JlYXRlKGl0KSA6ICRkZWZpbmVQcm9wZXJ0aWVzKF9jcmVhdGUoaXQpLCBQKTtcbn07XG52YXIgJHByb3BlcnR5SXNFbnVtZXJhYmxlID0gZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUoa2V5KXtcbiAgdmFyIEUgPSBpc0VudW0uY2FsbCh0aGlzLCBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpKTtcbiAgaWYodGhpcyA9PT0gT2JqZWN0UHJvdG8gJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhcyhPUFN5bWJvbHMsIGtleSkpcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gRSB8fCAhaGFzKHRoaXMsIGtleSkgfHwgIWhhcyhBbGxTeW1ib2xzLCBrZXkpIHx8IGhhcyh0aGlzLCBISURERU4pICYmIHRoaXNbSElEREVOXVtrZXldID8gRSA6IHRydWU7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSl7XG4gIGl0ICA9IHRvSU9iamVjdChpdCk7XG4gIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSk7XG4gIGlmKGl0ID09PSBPYmplY3RQcm90byAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhaGFzKE9QU3ltYm9scywga2V5KSlyZXR1cm47XG4gIHZhciBEID0gZ09QRChpdCwga2V5KTtcbiAgaWYoRCAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0pKUQuZW51bWVyYWJsZSA9IHRydWU7XG4gIHJldHVybiBEO1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlOYW1lcyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpe1xuICB2YXIgbmFtZXMgID0gZ09QTih0b0lPYmplY3QoaXQpKVxuICAgICwgcmVzdWx0ID0gW11cbiAgICAsIGkgICAgICA9IDBcbiAgICAsIGtleTtcbiAgd2hpbGUobmFtZXMubGVuZ3RoID4gaSl7XG4gICAgaWYoIWhhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSAmJiBrZXkgIT0gSElEREVOICYmIGtleSAhPSBNRVRBKXJlc3VsdC5wdXNoKGtleSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgJGdldE93blByb3BlcnR5U3ltYm9scyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5U3ltYm9scyhpdCl7XG4gIHZhciBJU19PUCAgPSBpdCA9PT0gT2JqZWN0UHJvdG9cbiAgICAsIG5hbWVzICA9IGdPUE4oSVNfT1AgPyBPUFN5bWJvbHMgOiB0b0lPYmplY3QoaXQpKVxuICAgICwgcmVzdWx0ID0gW11cbiAgICAsIGkgICAgICA9IDBcbiAgICAsIGtleTtcbiAgd2hpbGUobmFtZXMubGVuZ3RoID4gaSl7XG4gICAgaWYoaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pICYmIChJU19PUCA/IGhhcyhPYmplY3RQcm90bywga2V5KSA6IHRydWUpKXJlc3VsdC5wdXNoKEFsbFN5bWJvbHNba2V5XSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIDE5LjQuMS4xIFN5bWJvbChbZGVzY3JpcHRpb25dKVxuaWYoIVVTRV9OQVRJVkUpe1xuICAkU3ltYm9sID0gZnVuY3Rpb24gU3ltYm9sKCl7XG4gICAgaWYodGhpcyBpbnN0YW5jZW9mICRTeW1ib2wpdGhyb3cgVHlwZUVycm9yKCdTeW1ib2wgaXMgbm90IGEgY29uc3RydWN0b3IhJyk7XG4gICAgdmFyIHRhZyA9IHVpZChhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7XG4gICAgdmFyICRzZXQgPSBmdW5jdGlvbih2YWx1ZSl7XG4gICAgICBpZih0aGlzID09PSBPYmplY3RQcm90bykkc2V0LmNhbGwoT1BTeW1ib2xzLCB2YWx1ZSk7XG4gICAgICBpZihoYXModGhpcywgSElEREVOKSAmJiBoYXModGhpc1tISURERU5dLCB0YWcpKXRoaXNbSElEREVOXVt0YWddID0gZmFsc2U7XG4gICAgICBzZXRTeW1ib2xEZXNjKHRoaXMsIHRhZywgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xuICAgIH07XG4gICAgaWYoREVTQ1JJUFRPUlMgJiYgc2V0dGVyKXNldFN5bWJvbERlc2MoT2JqZWN0UHJvdG8sIHRhZywge2NvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiAkc2V0fSk7XG4gICAgcmV0dXJuIHdyYXAodGFnKTtcbiAgfTtcbiAgcmVkZWZpbmUoJFN5bWJvbFtQUk9UT1RZUEVdLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpe1xuICAgIHJldHVybiB0aGlzLl9rO1xuICB9KTtcblxuICAkR09QRC5mID0gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgJERQLmYgICA9ICRkZWZpbmVQcm9wZXJ0eTtcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mID0gZ09QTkV4dC5mID0gJGdldE93blByb3BlcnR5TmFtZXM7XG4gIHJlcXVpcmUoJy4vX29iamVjdC1waWUnKS5mICA9ICRwcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKS5mID0gJGdldE93blByb3BlcnR5U3ltYm9scztcblxuICBpZihERVNDUklQVE9SUyAmJiAhcmVxdWlyZSgnLi9fbGlicmFyeScpKXtcbiAgICByZWRlZmluZShPYmplY3RQcm90bywgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJywgJHByb3BlcnR5SXNFbnVtZXJhYmxlLCB0cnVlKTtcbiAgfVxuXG4gIHdrc0V4dC5mID0gZnVuY3Rpb24obmFtZSl7XG4gICAgcmV0dXJuIHdyYXAod2tzKG5hbWUpKTtcbiAgfVxufVxuXG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCB7U3ltYm9sOiAkU3ltYm9sfSk7XG5cbmZvcih2YXIgc3ltYm9scyA9IChcbiAgLy8gMTkuNC4yLjIsIDE5LjQuMi4zLCAxOS40LjIuNCwgMTkuNC4yLjYsIDE5LjQuMi44LCAxOS40LjIuOSwgMTkuNC4yLjEwLCAxOS40LjIuMTEsIDE5LjQuMi4xMiwgMTkuNC4yLjEzLCAxOS40LjIuMTRcbiAgJ2hhc0luc3RhbmNlLGlzQ29uY2F0U3ByZWFkYWJsZSxpdGVyYXRvcixtYXRjaCxyZXBsYWNlLHNlYXJjaCxzcGVjaWVzLHNwbGl0LHRvUHJpbWl0aXZlLHRvU3RyaW5nVGFnLHVuc2NvcGFibGVzJ1xuKS5zcGxpdCgnLCcpLCBpID0gMDsgc3ltYm9scy5sZW5ndGggPiBpOyApd2tzKHN5bWJvbHNbaSsrXSk7XG5cbmZvcih2YXIgc3ltYm9scyA9ICRrZXlzKHdrcy5zdG9yZSksIGkgPSAwOyBzeW1ib2xzLmxlbmd0aCA+IGk7ICl3a3NEZWZpbmUoc3ltYm9sc1tpKytdKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgJ1N5bWJvbCcsIHtcbiAgLy8gMTkuNC4yLjEgU3ltYm9sLmZvcihrZXkpXG4gICdmb3InOiBmdW5jdGlvbihrZXkpe1xuICAgIHJldHVybiBoYXMoU3ltYm9sUmVnaXN0cnksIGtleSArPSAnJylcbiAgICAgID8gU3ltYm9sUmVnaXN0cnlba2V5XVxuICAgICAgOiBTeW1ib2xSZWdpc3RyeVtrZXldID0gJFN5bWJvbChrZXkpO1xuICB9LFxuICAvLyAxOS40LjIuNSBTeW1ib2wua2V5Rm9yKHN5bSlcbiAga2V5Rm9yOiBmdW5jdGlvbiBrZXlGb3Ioa2V5KXtcbiAgICBpZihpc1N5bWJvbChrZXkpKXJldHVybiBrZXlPZihTeW1ib2xSZWdpc3RyeSwga2V5KTtcbiAgICB0aHJvdyBUeXBlRXJyb3Ioa2V5ICsgJyBpcyBub3QgYSBzeW1ib2whJyk7XG4gIH0sXG4gIHVzZVNldHRlcjogZnVuY3Rpb24oKXsgc2V0dGVyID0gdHJ1ZTsgfSxcbiAgdXNlU2ltcGxlOiBmdW5jdGlvbigpeyBzZXR0ZXIgPSBmYWxzZTsgfVxufSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsICdPYmplY3QnLCB7XG4gIC8vIDE5LjEuMi4yIE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbiAgY3JlYXRlOiAkY3JlYXRlLFxuICAvLyAxOS4xLjIuNCBPYmplY3QuZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcylcbiAgZGVmaW5lUHJvcGVydHk6ICRkZWZpbmVQcm9wZXJ0eSxcbiAgLy8gMTkuMS4yLjMgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcylcbiAgZGVmaW5lUHJvcGVydGllczogJGRlZmluZVByb3BlcnRpZXMsXG4gIC8vIDE5LjEuMi42IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUClcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFxuICAvLyAxOS4xLjIuNyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxuICBnZXRPd25Qcm9wZXJ0eU5hbWVzOiAkZ2V0T3duUHJvcGVydHlOYW1lcyxcbiAgLy8gMTkuMS4yLjggT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhPKVxuICBnZXRPd25Qcm9wZXJ0eVN5bWJvbHM6ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHNcbn0pO1xuXG4vLyAyNC4zLjIgSlNPTi5zdHJpbmdpZnkodmFsdWUgWywgcmVwbGFjZXIgWywgc3BhY2VdXSlcbiRKU09OICYmICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKCFVU0VfTkFUSVZFIHx8ICRmYWlscyhmdW5jdGlvbigpe1xuICB2YXIgUyA9ICRTeW1ib2woKTtcbiAgLy8gTVMgRWRnZSBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMge31cbiAgLy8gV2ViS2l0IGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgdG8gSlNPTiBhcyBudWxsXG4gIC8vIFY4IHRocm93cyBvbiBib3hlZCBzeW1ib2xzXG4gIHJldHVybiBfc3RyaW5naWZ5KFtTXSkgIT0gJ1tudWxsXScgfHwgX3N0cmluZ2lmeSh7YTogU30pICE9ICd7fScgfHwgX3N0cmluZ2lmeShPYmplY3QoUykpICE9ICd7fSc7XG59KSksICdKU09OJywge1xuICBzdHJpbmdpZnk6IGZ1bmN0aW9uIHN0cmluZ2lmeShpdCl7XG4gICAgaWYoaXQgPT09IHVuZGVmaW5lZCB8fCBpc1N5bWJvbChpdCkpcmV0dXJuOyAvLyBJRTggcmV0dXJucyBzdHJpbmcgb24gdW5kZWZpbmVkXG4gICAgdmFyIGFyZ3MgPSBbaXRdXG4gICAgICAsIGkgICAgPSAxXG4gICAgICAsIHJlcGxhY2VyLCAkcmVwbGFjZXI7XG4gICAgd2hpbGUoYXJndW1lbnRzLmxlbmd0aCA+IGkpYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcbiAgICByZXBsYWNlciA9IGFyZ3NbMV07XG4gICAgaWYodHlwZW9mIHJlcGxhY2VyID09ICdmdW5jdGlvbicpJHJlcGxhY2VyID0gcmVwbGFjZXI7XG4gICAgaWYoJHJlcGxhY2VyIHx8ICFpc0FycmF5KHJlcGxhY2VyKSlyZXBsYWNlciA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpe1xuICAgICAgaWYoJHJlcGxhY2VyKXZhbHVlID0gJHJlcGxhY2VyLmNhbGwodGhpcywga2V5LCB2YWx1ZSk7XG4gICAgICBpZighaXNTeW1ib2wodmFsdWUpKXJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIGFyZ3NbMV0gPSByZXBsYWNlcjtcbiAgICByZXR1cm4gX3N0cmluZ2lmeS5hcHBseSgkSlNPTiwgYXJncyk7XG4gIH1cbn0pO1xuXG4vLyAxOS40LjMuNCBTeW1ib2wucHJvdG90eXBlW0BAdG9QcmltaXRpdmVdKGhpbnQpXG4kU3ltYm9sW1BST1RPVFlQRV1bVE9fUFJJTUlUSVZFXSB8fCByZXF1aXJlKCcuL19oaWRlJykoJFN5bWJvbFtQUk9UT1RZUEVdLCBUT19QUklNSVRJVkUsICRTeW1ib2xbUFJPVE9UWVBFXS52YWx1ZU9mKTtcbi8vIDE5LjQuMy41IFN5bWJvbC5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKCRTeW1ib2wsICdTeW1ib2wnKTtcbi8vIDIwLjIuMS45IE1hdGhbQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKE1hdGgsICdNYXRoJywgdHJ1ZSk7XG4vLyAyNC4zLjMgSlNPTltAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoZ2xvYmFsLkpTT04sICdKU09OJywgdHJ1ZSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zeW1ib2wuanNcbiAqKiBtb2R1bGUgaWQgPSAzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxudmFyIGdsb2JhbCA9IG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuTWF0aCA9PSBNYXRoXG4gID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5NYXRoID09IE1hdGggPyBzZWxmIDogRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbmlmKHR5cGVvZiBfX2cgPT0gJ251bWJlcicpX19nID0gZ2xvYmFsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19nbG9iYWwuanNcbiAqKiBtb2R1bGUgaWQgPSA0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgaGFzT3duUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQsIGtleSl7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGl0LCBrZXkpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2hhcy5qc1xuICoqIG1vZHVsZSBpZCA9IDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcbm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7Z2V0OiBmdW5jdGlvbigpeyByZXR1cm4gNzsgfX0pLmEgIT0gNztcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fZGVzY3JpcHRvcnMuanNcbiAqKiBtb2R1bGUgaWQgPSA2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGV4ZWMpe1xuICB0cnkge1xuICAgIHJldHVybiAhIWV4ZWMoKTtcbiAgfSBjYXRjaChlKXtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2ZhaWxzLmpzXG4gKiogbW9kdWxlIGlkID0gN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGdsb2JhbCAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgY29yZSAgICAgID0gcmVxdWlyZSgnLi9fY29yZScpXG4gICwgaGlkZSAgICAgID0gcmVxdWlyZSgnLi9faGlkZScpXG4gICwgcmVkZWZpbmUgID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKVxuICAsIGN0eCAgICAgICA9IHJlcXVpcmUoJy4vX2N0eCcpXG4gICwgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG5cbnZhciAkZXhwb3J0ID0gZnVuY3Rpb24odHlwZSwgbmFtZSwgc291cmNlKXtcbiAgdmFyIElTX0ZPUkNFRCA9IHR5cGUgJiAkZXhwb3J0LkZcbiAgICAsIElTX0dMT0JBTCA9IHR5cGUgJiAkZXhwb3J0LkdcbiAgICAsIElTX1NUQVRJQyA9IHR5cGUgJiAkZXhwb3J0LlNcbiAgICAsIElTX1BST1RPICA9IHR5cGUgJiAkZXhwb3J0LlBcbiAgICAsIElTX0JJTkQgICA9IHR5cGUgJiAkZXhwb3J0LkJcbiAgICAsIHRhcmdldCAgICA9IElTX0dMT0JBTCA/IGdsb2JhbCA6IElTX1NUQVRJQyA/IGdsb2JhbFtuYW1lXSB8fCAoZ2xvYmFsW25hbWVdID0ge30pIDogKGdsb2JhbFtuYW1lXSB8fCB7fSlbUFJPVE9UWVBFXVxuICAgICwgZXhwb3J0cyAgID0gSVNfR0xPQkFMID8gY29yZSA6IGNvcmVbbmFtZV0gfHwgKGNvcmVbbmFtZV0gPSB7fSlcbiAgICAsIGV4cFByb3RvICA9IGV4cG9ydHNbUFJPVE9UWVBFXSB8fCAoZXhwb3J0c1tQUk9UT1RZUEVdID0ge30pXG4gICAgLCBrZXksIG93biwgb3V0LCBleHA7XG4gIGlmKElTX0dMT0JBTClzb3VyY2UgPSBuYW1lO1xuICBmb3Ioa2V5IGluIHNvdXJjZSl7XG4gICAgLy8gY29udGFpbnMgaW4gbmF0aXZlXG4gICAgb3duID0gIUlTX0ZPUkNFRCAmJiB0YXJnZXQgJiYgdGFyZ2V0W2tleV0gIT09IHVuZGVmaW5lZDtcbiAgICAvLyBleHBvcnQgbmF0aXZlIG9yIHBhc3NlZFxuICAgIG91dCA9IChvd24gPyB0YXJnZXQgOiBzb3VyY2UpW2tleV07XG4gICAgLy8gYmluZCB0aW1lcnMgdG8gZ2xvYmFsIGZvciBjYWxsIGZyb20gZXhwb3J0IGNvbnRleHRcbiAgICBleHAgPSBJU19CSU5EICYmIG93biA/IGN0eChvdXQsIGdsb2JhbCkgOiBJU19QUk9UTyAmJiB0eXBlb2Ygb3V0ID09ICdmdW5jdGlvbicgPyBjdHgoRnVuY3Rpb24uY2FsbCwgb3V0KSA6IG91dDtcbiAgICAvLyBleHRlbmQgZ2xvYmFsXG4gICAgaWYodGFyZ2V0KXJlZGVmaW5lKHRhcmdldCwga2V5LCBvdXQsIHR5cGUgJiAkZXhwb3J0LlUpO1xuICAgIC8vIGV4cG9ydFxuICAgIGlmKGV4cG9ydHNba2V5XSAhPSBvdXQpaGlkZShleHBvcnRzLCBrZXksIGV4cCk7XG4gICAgaWYoSVNfUFJPVE8gJiYgZXhwUHJvdG9ba2V5XSAhPSBvdXQpZXhwUHJvdG9ba2V5XSA9IG91dDtcbiAgfVxufTtcbmdsb2JhbC5jb3JlID0gY29yZTtcbi8vIHR5cGUgYml0bWFwXG4kZXhwb3J0LkYgPSAxOyAgIC8vIGZvcmNlZFxuJGV4cG9ydC5HID0gMjsgICAvLyBnbG9iYWxcbiRleHBvcnQuUyA9IDQ7ICAgLy8gc3RhdGljXG4kZXhwb3J0LlAgPSA4OyAgIC8vIHByb3RvXG4kZXhwb3J0LkIgPSAxNjsgIC8vIGJpbmRcbiRleHBvcnQuVyA9IDMyOyAgLy8gd3JhcFxuJGV4cG9ydC5VID0gNjQ7ICAvLyBzYWZlXG4kZXhwb3J0LlIgPSAxMjg7IC8vIHJlYWwgcHJvdG8gbWV0aG9kIGZvciBgbGlicmFyeWAgXG5tb2R1bGUuZXhwb3J0cyA9ICRleHBvcnQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19leHBvcnQuanNcbiAqKiBtb2R1bGUgaWQgPSA4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgY29yZSA9IG1vZHVsZS5leHBvcnRzID0ge3ZlcnNpb246ICcyLjQuMCd9O1xuaWYodHlwZW9mIF9fZSA9PSAnbnVtYmVyJylfX2UgPSBjb3JlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19jb3JlLmpzXG4gKiogbW9kdWxlIGlkID0gOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGRQICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKVxuICAsIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBmdW5jdGlvbihvYmplY3QsIGtleSwgdmFsdWUpe1xuICByZXR1cm4gZFAuZihvYmplY3QsIGtleSwgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xufSA6IGZ1bmN0aW9uKG9iamVjdCwga2V5LCB2YWx1ZSl7XG4gIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIHJldHVybiBvYmplY3Q7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9faGlkZS5qc1xuICoqIG1vZHVsZSBpZCA9IDEwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgYW5PYmplY3QgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIElFOF9ET01fREVGSU5FID0gcmVxdWlyZSgnLi9faWU4LWRvbS1kZWZpbmUnKVxuICAsIHRvUHJpbWl0aXZlICAgID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJylcbiAgLCBkUCAgICAgICAgICAgICA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxuZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpe1xuICBhbk9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBhbk9iamVjdChBdHRyaWJ1dGVzKTtcbiAgaWYoSUU4X0RPTV9ERUZJTkUpdHJ5IHtcbiAgICByZXR1cm4gZFAoTywgUCwgQXR0cmlidXRlcyk7XG4gIH0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cbiAgaWYoJ2dldCcgaW4gQXR0cmlidXRlcyB8fCAnc2V0JyBpbiBBdHRyaWJ1dGVzKXRocm93IFR5cGVFcnJvcignQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQhJyk7XG4gIGlmKCd2YWx1ZScgaW4gQXR0cmlidXRlcylPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgcmV0dXJuIE87XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWRwLmpzXG4gKiogbW9kdWxlIGlkID0gMTFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIGlmKCFpc09iamVjdChpdCkpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYW4gb2JqZWN0IScpO1xuICByZXR1cm4gaXQ7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fYW4tb2JqZWN0LmpzXG4gKiogbW9kdWxlIGlkID0gMTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gdHlwZW9mIGl0ID09PSAnb2JqZWN0JyA/IGl0ICE9PSBudWxsIDogdHlwZW9mIGl0ID09PSAnZnVuY3Rpb24nO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2lzLW9iamVjdC5qc1xuICoqIG1vZHVsZSBpZCA9IDEzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9ICFyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XHJcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2RpdicpLCAnYScsIHtnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiA3OyB9fSkuYSAhPSA3O1xyXG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2llOC1kb20tZGVmaW5lLmpzXG4gKiogbW9kdWxlIGlkID0gMTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgZG9jdW1lbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudFxuICAvLyBpbiBvbGQgSUUgdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgJ29iamVjdCdcbiAgLCBpcyA9IGlzT2JqZWN0KGRvY3VtZW50KSAmJiBpc09iamVjdChkb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXMgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2RvbS1jcmVhdGUuanNcbiAqKiBtb2R1bGUgaWQgPSAxNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gNy4xLjEgVG9QcmltaXRpdmUoaW5wdXQgWywgUHJlZmVycmVkVHlwZV0pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbi8vIGluc3RlYWQgb2YgdGhlIEVTNiBzcGVjIHZlcnNpb24sIHdlIGRpZG4ndCBpbXBsZW1lbnQgQEB0b1ByaW1pdGl2ZSBjYXNlXG4vLyBhbmQgdGhlIHNlY29uZCBhcmd1bWVudCAtIGZsYWcgLSBwcmVmZXJyZWQgdHlwZSBpcyBhIHN0cmluZ1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwgUyl7XG4gIGlmKCFpc09iamVjdChpdCkpcmV0dXJuIGl0O1xuICB2YXIgZm4sIHZhbDtcbiAgaWYoUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSlyZXR1cm4gdmFsO1xuICBpZih0eXBlb2YgKGZuID0gaXQudmFsdWVPZikgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKXJldHVybiB2YWw7XG4gIGlmKCFTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKXJldHVybiB2YWw7XG4gIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL190by1wcmltaXRpdmUuanNcbiAqKiBtb2R1bGUgaWQgPSAxNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihiaXRtYXAsIHZhbHVlKXtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlICA6ICEoYml0bWFwICYgMSksXG4gICAgY29uZmlndXJhYmxlOiAhKGJpdG1hcCAmIDIpLFxuICAgIHdyaXRhYmxlICAgIDogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZSAgICAgICA6IHZhbHVlXG4gIH07XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fcHJvcGVydHktZGVzYy5qc1xuICoqIG1vZHVsZSBpZCA9IDE3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgZ2xvYmFsICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBoaWRlICAgICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgLCBoYXMgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIFNSQyAgICAgICA9IHJlcXVpcmUoJy4vX3VpZCcpKCdzcmMnKVxuICAsIFRPX1NUUklORyA9ICd0b1N0cmluZydcbiAgLCAkdG9TdHJpbmcgPSBGdW5jdGlvbltUT19TVFJJTkddXG4gICwgVFBMICAgICAgID0gKCcnICsgJHRvU3RyaW5nKS5zcGxpdChUT19TVFJJTkcpO1xuXG5yZXF1aXJlKCcuL19jb3JlJykuaW5zcGVjdFNvdXJjZSA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuICR0b1N0cmluZy5jYWxsKGl0KTtcbn07XG5cbihtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKE8sIGtleSwgdmFsLCBzYWZlKXtcbiAgdmFyIGlzRnVuY3Rpb24gPSB0eXBlb2YgdmFsID09ICdmdW5jdGlvbic7XG4gIGlmKGlzRnVuY3Rpb24paGFzKHZhbCwgJ25hbWUnKSB8fCBoaWRlKHZhbCwgJ25hbWUnLCBrZXkpO1xuICBpZihPW2tleV0gPT09IHZhbClyZXR1cm47XG4gIGlmKGlzRnVuY3Rpb24paGFzKHZhbCwgU1JDKSB8fCBoaWRlKHZhbCwgU1JDLCBPW2tleV0gPyAnJyArIE9ba2V5XSA6IFRQTC5qb2luKFN0cmluZyhrZXkpKSk7XG4gIGlmKE8gPT09IGdsb2JhbCl7XG4gICAgT1trZXldID0gdmFsO1xuICB9IGVsc2Uge1xuICAgIGlmKCFzYWZlKXtcbiAgICAgIGRlbGV0ZSBPW2tleV07XG4gICAgICBoaWRlKE8sIGtleSwgdmFsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYoT1trZXldKU9ba2V5XSA9IHZhbDtcbiAgICAgIGVsc2UgaGlkZShPLCBrZXksIHZhbCk7XG4gICAgfVxuICB9XG4vLyBhZGQgZmFrZSBGdW5jdGlvbiN0b1N0cmluZyBmb3IgY29ycmVjdCB3b3JrIHdyYXBwZWQgbWV0aG9kcyAvIGNvbnN0cnVjdG9ycyB3aXRoIG1ldGhvZHMgbGlrZSBMb0Rhc2ggaXNOYXRpdmVcbn0pKEZ1bmN0aW9uLnByb3RvdHlwZSwgVE9fU1RSSU5HLCBmdW5jdGlvbiB0b1N0cmluZygpe1xuICByZXR1cm4gdHlwZW9mIHRoaXMgPT0gJ2Z1bmN0aW9uJyAmJiB0aGlzW1NSQ10gfHwgJHRvU3RyaW5nLmNhbGwodGhpcyk7XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX3JlZGVmaW5lLmpzXG4gKiogbW9kdWxlIGlkID0gMThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBpZCA9IDBcbiAgLCBweCA9IE1hdGgucmFuZG9tKCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGtleSl7XG4gIHJldHVybiAnU3ltYm9sKCcuY29uY2F0KGtleSA9PT0gdW5kZWZpbmVkID8gJycgOiBrZXksICcpXycsICgrK2lkICsgcHgpLnRvU3RyaW5nKDM2KSk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fdWlkLmpzXG4gKiogbW9kdWxlIGlkID0gMTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIG9wdGlvbmFsIC8gc2ltcGxlIGNvbnRleHQgYmluZGluZ1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZm4sIHRoYXQsIGxlbmd0aCl7XG4gIGFGdW5jdGlvbihmbik7XG4gIGlmKHRoYXQgPT09IHVuZGVmaW5lZClyZXR1cm4gZm47XG4gIHN3aXRjaChsZW5ndGgpe1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uKGEpe1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSk7XG4gICAgfTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbihhLCBiKXtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIpO1xuICAgIH07XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24oYSwgYiwgYyl7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiLCBjKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBmdW5jdGlvbigvKiAuLi5hcmdzICovKXtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgfTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19jdHguanNcbiAqKiBtb2R1bGUgaWQgPSAyMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIGlmKHR5cGVvZiBpdCAhPSAnZnVuY3Rpb24nKXRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGEgZnVuY3Rpb24hJyk7XG4gIHJldHVybiBpdDtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19hLWZ1bmN0aW9uLmpzXG4gKiogbW9kdWxlIGlkID0gMjFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBNRVRBICAgICA9IHJlcXVpcmUoJy4vX3VpZCcpKCdtZXRhJylcbiAgLCBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgaGFzICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIHNldERlc2MgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZlxuICAsIGlkICAgICAgID0gMDtcbnZhciBpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlIHx8IGZ1bmN0aW9uKCl7XG4gIHJldHVybiB0cnVlO1xufTtcbnZhciBGUkVFWkUgPSAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICByZXR1cm4gaXNFeHRlbnNpYmxlKE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSkpO1xufSk7XG52YXIgc2V0TWV0YSA9IGZ1bmN0aW9uKGl0KXtcbiAgc2V0RGVzYyhpdCwgTUVUQSwge3ZhbHVlOiB7XG4gICAgaTogJ08nICsgKytpZCwgLy8gb2JqZWN0IElEXG4gICAgdzoge30gICAgICAgICAgLy8gd2VhayBjb2xsZWN0aW9ucyBJRHNcbiAgfX0pO1xufTtcbnZhciBmYXN0S2V5ID0gZnVuY3Rpb24oaXQsIGNyZWF0ZSl7XG4gIC8vIHJldHVybiBwcmltaXRpdmUgd2l0aCBwcmVmaXhcbiAgaWYoIWlzT2JqZWN0KGl0KSlyZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnID8gaXQgOiAodHlwZW9mIGl0ID09ICdzdHJpbmcnID8gJ1MnIDogJ1AnKSArIGl0O1xuICBpZighaGFzKGl0LCBNRVRBKSl7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZighaXNFeHRlbnNpYmxlKGl0KSlyZXR1cm4gJ0YnO1xuICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXG4gICAgaWYoIWNyZWF0ZSlyZXR1cm4gJ0UnO1xuICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG4gICAgc2V0TWV0YShpdCk7XG4gIC8vIHJldHVybiBvYmplY3QgSURcbiAgfSByZXR1cm4gaXRbTUVUQV0uaTtcbn07XG52YXIgZ2V0V2VhayA9IGZ1bmN0aW9uKGl0LCBjcmVhdGUpe1xuICBpZighaGFzKGl0LCBNRVRBKSl7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZighaXNFeHRlbnNpYmxlKGl0KSlyZXR1cm4gdHJ1ZTtcbiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuICAgIGlmKCFjcmVhdGUpcmV0dXJuIGZhbHNlO1xuICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG4gICAgc2V0TWV0YShpdCk7XG4gIC8vIHJldHVybiBoYXNoIHdlYWsgY29sbGVjdGlvbnMgSURzXG4gIH0gcmV0dXJuIGl0W01FVEFdLnc7XG59O1xuLy8gYWRkIG1ldGFkYXRhIG9uIGZyZWV6ZS1mYW1pbHkgbWV0aG9kcyBjYWxsaW5nXG52YXIgb25GcmVlemUgPSBmdW5jdGlvbihpdCl7XG4gIGlmKEZSRUVaRSAmJiBtZXRhLk5FRUQgJiYgaXNFeHRlbnNpYmxlKGl0KSAmJiAhaGFzKGl0LCBNRVRBKSlzZXRNZXRhKGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcbnZhciBtZXRhID0gbW9kdWxlLmV4cG9ydHMgPSB7XG4gIEtFWTogICAgICBNRVRBLFxuICBORUVEOiAgICAgZmFsc2UsXG4gIGZhc3RLZXk6ICBmYXN0S2V5LFxuICBnZXRXZWFrOiAgZ2V0V2VhayxcbiAgb25GcmVlemU6IG9uRnJlZXplXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fbWV0YS5qc1xuICoqIG1vZHVsZSBpZCA9IDIyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBTSEFSRUQgPSAnX19jb3JlLWpzX3NoYXJlZF9fJ1xuICAsIHN0b3JlICA9IGdsb2JhbFtTSEFSRURdIHx8IChnbG9iYWxbU0hBUkVEXSA9IHt9KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oa2V5KXtcbiAgcmV0dXJuIHN0b3JlW2tleV0gfHwgKHN0b3JlW2tleV0gPSB7fSk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fc2hhcmVkLmpzXG4gKiogbW9kdWxlIGlkID0gMjNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBkZWYgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mXG4gICwgaGFzID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCBUQUcgPSByZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwgdGFnLCBzdGF0KXtcbiAgaWYoaXQgJiYgIWhhcyhpdCA9IHN0YXQgPyBpdCA6IGl0LnByb3RvdHlwZSwgVEFHKSlkZWYoaXQsIFRBRywge2NvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IHRhZ30pO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX3NldC10by1zdHJpbmctdGFnLmpzXG4gKiogbW9kdWxlIGlkID0gMjRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBzdG9yZSAgICAgID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ3drcycpXG4gICwgdWlkICAgICAgICA9IHJlcXVpcmUoJy4vX3VpZCcpXG4gICwgU3ltYm9sICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLlN5bWJvbFxuICAsIFVTRV9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09ICdmdW5jdGlvbic7XG5cbnZhciAkZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obmFtZSl7XG4gIHJldHVybiBzdG9yZVtuYW1lXSB8fCAoc3RvcmVbbmFtZV0gPVxuICAgIFVTRV9TWU1CT0wgJiYgU3ltYm9sW25hbWVdIHx8IChVU0VfU1lNQk9MID8gU3ltYm9sIDogdWlkKSgnU3ltYm9sLicgKyBuYW1lKSk7XG59O1xuXG4kZXhwb3J0cy5zdG9yZSA9IHN0b3JlO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fd2tzLmpzXG4gKiogbW9kdWxlIGlkID0gMjVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX3drcycpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fd2tzLWV4dC5qc1xuICoqIG1vZHVsZSBpZCA9IDI2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgZ2xvYmFsICAgICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxyXG4gICwgY29yZSAgICAgICAgICAgPSByZXF1aXJlKCcuL19jb3JlJylcclxuICAsIExJQlJBUlkgICAgICAgID0gcmVxdWlyZSgnLi9fbGlicmFyeScpXHJcbiAgLCB3a3NFeHQgICAgICAgICA9IHJlcXVpcmUoJy4vX3drcy1leHQnKVxyXG4gICwgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG5hbWUpe1xyXG4gIHZhciAkU3ltYm9sID0gY29yZS5TeW1ib2wgfHwgKGNvcmUuU3ltYm9sID0gTElCUkFSWSA/IHt9IDogZ2xvYmFsLlN5bWJvbCB8fCB7fSk7XHJcbiAgaWYobmFtZS5jaGFyQXQoMCkgIT0gJ18nICYmICEobmFtZSBpbiAkU3ltYm9sKSlkZWZpbmVQcm9wZXJ0eSgkU3ltYm9sLCBuYW1lLCB7dmFsdWU6IHdrc0V4dC5mKG5hbWUpfSk7XHJcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL193a3MtZGVmaW5lLmpzXG4gKiogbW9kdWxlIGlkID0gMjdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gZmFsc2U7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19saWJyYXJ5LmpzXG4gKiogbW9kdWxlIGlkID0gMjhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBnZXRLZXlzICAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpXG4gICwgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmplY3QsIGVsKXtcbiAgdmFyIE8gICAgICA9IHRvSU9iamVjdChvYmplY3QpXG4gICAgLCBrZXlzICAgPSBnZXRLZXlzKE8pXG4gICAgLCBsZW5ndGggPSBrZXlzLmxlbmd0aFxuICAgICwgaW5kZXggID0gMFxuICAgICwga2V5O1xuICB3aGlsZShsZW5ndGggPiBpbmRleClpZihPW2tleSA9IGtleXNbaW5kZXgrK11dID09PSBlbClyZXR1cm4ga2V5O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2tleW9mLmpzXG4gKiogbW9kdWxlIGlkID0gMjlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDE5LjEuMi4xNCAvIDE1LjIuMy4xNCBPYmplY3Qua2V5cyhPKVxyXG52YXIgJGtleXMgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cy1pbnRlcm5hbCcpXHJcbiAgLCBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyhPKXtcclxuICByZXR1cm4gJGtleXMoTywgZW51bUJ1Z0tleXMpO1xyXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWtleXMuanNcbiAqKiBtb2R1bGUgaWQgPSAzMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGhhcyAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXHJcbiAgLCB0b0lPYmplY3QgICAgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcclxuICAsIGFycmF5SW5kZXhPZiA9IHJlcXVpcmUoJy4vX2FycmF5LWluY2x1ZGVzJykoZmFsc2UpXHJcbiAgLCBJRV9QUk9UTyAgICAgPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iamVjdCwgbmFtZXMpe1xyXG4gIHZhciBPICAgICAgPSB0b0lPYmplY3Qob2JqZWN0KVxyXG4gICAgLCBpICAgICAgPSAwXHJcbiAgICAsIHJlc3VsdCA9IFtdXHJcbiAgICAsIGtleTtcclxuICBmb3Ioa2V5IGluIE8paWYoa2V5ICE9IElFX1BST1RPKWhhcyhPLCBrZXkpICYmIHJlc3VsdC5wdXNoKGtleSk7XHJcbiAgLy8gRG9uJ3QgZW51bSBidWcgJiBoaWRkZW4ga2V5c1xyXG4gIHdoaWxlKG5hbWVzLmxlbmd0aCA+IGkpaWYoaGFzKE8sIGtleSA9IG5hbWVzW2krK10pKXtcclxuICAgIH5hcnJheUluZGV4T2YocmVzdWx0LCBrZXkpIHx8IHJlc3VsdC5wdXNoKGtleSk7XHJcbiAgfVxyXG4gIHJldHVybiByZXN1bHQ7XHJcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3Qta2V5cy1pbnRlcm5hbC5qc1xuICoqIG1vZHVsZSBpZCA9IDMxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyB0byBpbmRleGVkIG9iamVjdCwgdG9PYmplY3Qgd2l0aCBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIHN0cmluZ3NcbnZhciBJT2JqZWN0ID0gcmVxdWlyZSgnLi9faW9iamVjdCcpXG4gICwgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gSU9iamVjdChkZWZpbmVkKGl0KSk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fdG8taW9iamVjdC5qc1xuICoqIG1vZHVsZSBpZCA9IDMyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIGFuZCBub24tZW51bWVyYWJsZSBvbGQgVjggc3RyaW5nc1xudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QoJ3onKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKSA/IE9iamVjdCA6IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGNvZihpdCkgPT0gJ1N0cmluZycgPyBpdC5zcGxpdCgnJykgOiBPYmplY3QoaXQpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2lvYmplY3QuanNcbiAqKiBtb2R1bGUgaWQgPSAzM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChpdCkuc2xpY2UoOCwgLTEpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2NvZi5qc1xuICoqIG1vZHVsZSBpZCA9IDM0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyA3LjIuMSBSZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGFyZ3VtZW50KVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIGlmKGl0ID09IHVuZGVmaW5lZCl0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjYWxsIG1ldGhvZCBvbiAgXCIgKyBpdCk7XG4gIHJldHVybiBpdDtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19kZWZpbmVkLmpzXG4gKiogbW9kdWxlIGlkID0gMzVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIGZhbHNlIC0+IEFycmF5I2luZGV4T2Zcbi8vIHRydWUgIC0+IEFycmF5I2luY2x1ZGVzXG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgdG9MZW5ndGggID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCB0b0luZGV4ICAgPSByZXF1aXJlKCcuL190by1pbmRleCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihJU19JTkNMVURFUyl7XG4gIHJldHVybiBmdW5jdGlvbigkdGhpcywgZWwsIGZyb21JbmRleCl7XG4gICAgdmFyIE8gICAgICA9IHRvSU9iamVjdCgkdGhpcylcbiAgICAgICwgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpXG4gICAgICAsIGluZGV4ICA9IHRvSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpXG4gICAgICAsIHZhbHVlO1xuICAgIC8vIEFycmF5I2luY2x1ZGVzIHVzZXMgU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG1cbiAgICBpZihJU19JTkNMVURFUyAmJiBlbCAhPSBlbCl3aGlsZShsZW5ndGggPiBpbmRleCl7XG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XG4gICAgICBpZih2YWx1ZSAhPSB2YWx1ZSlyZXR1cm4gdHJ1ZTtcbiAgICAvLyBBcnJheSN0b0luZGV4IGlnbm9yZXMgaG9sZXMsIEFycmF5I2luY2x1ZGVzIC0gbm90XG4gICAgfSBlbHNlIGZvcig7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspaWYoSVNfSU5DTFVERVMgfHwgaW5kZXggaW4gTyl7XG4gICAgICBpZihPW2luZGV4XSA9PT0gZWwpcmV0dXJuIElTX0lOQ0xVREVTIHx8IGluZGV4IHx8IDA7XG4gICAgfSByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xuICB9O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2FycmF5LWluY2x1ZGVzLmpzXG4gKiogbW9kdWxlIGlkID0gMzZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDcuMS4xNSBUb0xlbmd0aFxudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKVxuICAsIG1pbiAgICAgICA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpdCA+IDAgPyBtaW4odG9JbnRlZ2VyKGl0KSwgMHgxZmZmZmZmZmZmZmZmZikgOiAwOyAvLyBwb3coMiwgNTMpIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fdG8tbGVuZ3RoLmpzXG4gKiogbW9kdWxlIGlkID0gMzdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDcuMS40IFRvSW50ZWdlclxudmFyIGNlaWwgID0gTWF0aC5jZWlsXG4gICwgZmxvb3IgPSBNYXRoLmZsb29yO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpc05hTihpdCA9ICtpdCkgPyAwIDogKGl0ID4gMCA/IGZsb29yIDogY2VpbCkoaXQpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX3RvLWludGVnZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAzOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKVxuICAsIG1heCAgICAgICA9IE1hdGgubWF4XG4gICwgbWluICAgICAgID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGluZGV4LCBsZW5ndGgpe1xuICBpbmRleCA9IHRvSW50ZWdlcihpbmRleCk7XG4gIHJldHVybiBpbmRleCA8IDAgPyBtYXgoaW5kZXggKyBsZW5ndGgsIDApIDogbWluKGluZGV4LCBsZW5ndGgpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX3RvLWluZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMzlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBzaGFyZWQgPSByZXF1aXJlKCcuL19zaGFyZWQnKSgna2V5cycpXHJcbiAgLCB1aWQgICAgPSByZXF1aXJlKCcuL191aWQnKTtcclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihrZXkpe1xyXG4gIHJldHVybiBzaGFyZWRba2V5XSB8fCAoc2hhcmVkW2tleV0gPSB1aWQoa2V5KSk7XHJcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19zaGFyZWQta2V5LmpzXG4gKiogbW9kdWxlIGlkID0gNDBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIElFIDgtIGRvbid0IGVudW0gYnVnIGtleXNcclxubW9kdWxlLmV4cG9ydHMgPSAoXHJcbiAgJ2NvbnN0cnVjdG9yLGhhc093blByb3BlcnR5LGlzUHJvdG90eXBlT2YscHJvcGVydHlJc0VudW1lcmFibGUsdG9Mb2NhbGVTdHJpbmcsdG9TdHJpbmcsdmFsdWVPZidcclxuKS5zcGxpdCgnLCcpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fZW51bS1idWcta2V5cy5qc1xuICoqIG1vZHVsZSBpZCA9IDQxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBhbGwgZW51bWVyYWJsZSBvYmplY3Qga2V5cywgaW5jbHVkZXMgc3ltYm9sc1xudmFyIGdldEtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpXG4gICwgZ09QUyAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJylcbiAgLCBwSUUgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHZhciByZXN1bHQgICAgID0gZ2V0S2V5cyhpdClcbiAgICAsIGdldFN5bWJvbHMgPSBnT1BTLmY7XG4gIGlmKGdldFN5bWJvbHMpe1xuICAgIHZhciBzeW1ib2xzID0gZ2V0U3ltYm9scyhpdClcbiAgICAgICwgaXNFbnVtICA9IHBJRS5mXG4gICAgICAsIGkgICAgICAgPSAwXG4gICAgICAsIGtleTtcbiAgICB3aGlsZShzeW1ib2xzLmxlbmd0aCA+IGkpaWYoaXNFbnVtLmNhbGwoaXQsIGtleSA9IHN5bWJvbHNbaSsrXSkpcmVzdWx0LnB1c2goa2V5KTtcbiAgfSByZXR1cm4gcmVzdWx0O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2VudW0ta2V5cy5qc1xuICoqIG1vZHVsZSBpZCA9IDQyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJleHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcHMuanNcbiAqKiBtb2R1bGUgaWQgPSA0M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0cy5mID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtcGllLmpzXG4gKiogbW9kdWxlIGlkID0gNDRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDcuMi4yIElzQXJyYXkoYXJndW1lbnQpXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gaXNBcnJheShhcmcpe1xuICByZXR1cm4gY29mKGFyZykgPT0gJ0FycmF5Jztcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19pcy1hcnJheS5qc1xuICoqIG1vZHVsZSBpZCA9IDQ1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAxOS4xLjIuMiAvIDE1LjIuMy41IE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcclxudmFyIGFuT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcclxuICAsIGRQcyAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwcycpXHJcbiAgLCBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKVxyXG4gICwgSUVfUFJPVE8gICAgPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJylcclxuICAsIEVtcHR5ICAgICAgID0gZnVuY3Rpb24oKXsgLyogZW1wdHkgKi8gfVxyXG4gICwgUFJPVE9UWVBFICAgPSAncHJvdG90eXBlJztcclxuXHJcbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBpZnJhbWUgT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcclxudmFyIGNyZWF0ZURpY3QgPSBmdW5jdGlvbigpe1xyXG4gIC8vIFRocmFzaCwgd2FzdGUgYW5kIHNvZG9teTogSUUgR0MgYnVnXHJcbiAgdmFyIGlmcmFtZSA9IHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKSgnaWZyYW1lJylcclxuICAgICwgaSAgICAgID0gZW51bUJ1Z0tleXMubGVuZ3RoXHJcbiAgICAsIGd0ICAgICA9ICc+J1xyXG4gICAgLCBpZnJhbWVEb2N1bWVudDtcclxuICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuICByZXF1aXJlKCcuL19odG1sJykuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcclxuICBpZnJhbWUuc3JjID0gJ2phdmFzY3JpcHQ6JzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zY3JpcHQtdXJsXHJcbiAgLy8gY3JlYXRlRGljdCA9IGlmcmFtZS5jb250ZW50V2luZG93Lk9iamVjdDtcclxuICAvLyBodG1sLnJlbW92ZUNoaWxkKGlmcmFtZSk7XHJcbiAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcclxuICBpZnJhbWVEb2N1bWVudC5vcGVuKCk7XHJcbiAgaWZyYW1lRG9jdW1lbnQud3JpdGUoJzxzY3JpcHQ+ZG9jdW1lbnQuRj1PYmplY3Q8L3NjcmlwdCcgKyBndCk7XHJcbiAgaWZyYW1lRG9jdW1lbnQuY2xvc2UoKTtcclxuICBjcmVhdGVEaWN0ID0gaWZyYW1lRG9jdW1lbnQuRjtcclxuICB3aGlsZShpLS0pZGVsZXRlIGNyZWF0ZURpY3RbUFJPVE9UWVBFXVtlbnVtQnVnS2V5c1tpXV07XHJcbiAgcmV0dXJuIGNyZWF0ZURpY3QoKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcyl7XHJcbiAgdmFyIHJlc3VsdDtcclxuICBpZihPICE9PSBudWxsKXtcclxuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBhbk9iamVjdChPKTtcclxuICAgIHJlc3VsdCA9IG5ldyBFbXB0eTtcclxuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBudWxsO1xyXG4gICAgLy8gYWRkIFwiX19wcm90b19fXCIgZm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZiBwb2x5ZmlsbFxyXG4gICAgcmVzdWx0W0lFX1BST1RPXSA9IE87XHJcbiAgfSBlbHNlIHJlc3VsdCA9IGNyZWF0ZURpY3QoKTtcclxuICByZXR1cm4gUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogZFBzKHJlc3VsdCwgUHJvcGVydGllcyk7XHJcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtY3JlYXRlLmpzXG4gKiogbW9kdWxlIGlkID0gNDZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBkUCAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpXHJcbiAgLCBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXHJcbiAgLCBnZXRLZXlzICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcyl7XHJcbiAgYW5PYmplY3QoTyk7XHJcbiAgdmFyIGtleXMgICA9IGdldEtleXMoUHJvcGVydGllcylcclxuICAgICwgbGVuZ3RoID0ga2V5cy5sZW5ndGhcclxuICAgICwgaSA9IDBcclxuICAgICwgUDtcclxuICB3aGlsZShsZW5ndGggPiBpKWRQLmYoTywgUCA9IGtleXNbaSsrXSwgUHJvcGVydGllc1tQXSk7XHJcbiAgcmV0dXJuIE87XHJcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZHBzLmpzXG4gKiogbW9kdWxlIGlkID0gNDdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9faHRtbC5qc1xuICoqIG1vZHVsZSBpZCA9IDQ4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBmYWxsYmFjayBmb3IgSUUxMSBidWdneSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB3aXRoIGlmcmFtZSBhbmQgd2luZG93XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgZ09QTiAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mXG4gICwgdG9TdHJpbmcgID0ge30udG9TdHJpbmc7XG5cbnZhciB3aW5kb3dOYW1lcyA9IHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzXG4gID8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMod2luZG93KSA6IFtdO1xuXG52YXIgZ2V0V2luZG93TmFtZXMgPSBmdW5jdGlvbihpdCl7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGdPUE4oaXQpO1xuICB9IGNhdGNoKGUpe1xuICAgIHJldHVybiB3aW5kb3dOYW1lcy5zbGljZSgpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5mID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCl7XG4gIHJldHVybiB3aW5kb3dOYW1lcyAmJiB0b1N0cmluZy5jYWxsKGl0KSA9PSAnW29iamVjdCBXaW5kb3ddJyA/IGdldFdpbmRvd05hbWVzKGl0KSA6IGdPUE4odG9JT2JqZWN0KGl0KSk7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wbi1leHQuanNcbiAqKiBtb2R1bGUgaWQgPSA0OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMTkuMS4yLjcgLyAxNS4yLjMuNCBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxyXG52YXIgJGtleXMgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzLWludGVybmFsJylcclxuICAsIGhpZGRlbktleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJykuY29uY2F0KCdsZW5ndGgnLCAncHJvdG90eXBlJyk7XHJcblxyXG5leHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKE8pe1xyXG4gIHJldHVybiAka2V5cyhPLCBoaWRkZW5LZXlzKTtcclxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1nb3BuLmpzXG4gKiogbW9kdWxlIGlkID0gNTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBwSUUgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKVxyXG4gICwgY3JlYXRlRGVzYyAgICAgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJylcclxuICAsIHRvSU9iamVjdCAgICAgID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXHJcbiAgLCB0b1ByaW1pdGl2ZSAgICA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpXHJcbiAgLCBoYXMgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXHJcbiAgLCBJRThfRE9NX0RFRklORSA9IHJlcXVpcmUoJy4vX2llOC1kb20tZGVmaW5lJylcclxuICAsIGdPUEQgICAgICAgICAgID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcclxuXHJcbmV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBnT1BEIDogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApe1xyXG4gIE8gPSB0b0lPYmplY3QoTyk7XHJcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xyXG4gIGlmKElFOF9ET01fREVGSU5FKXRyeSB7XHJcbiAgICByZXR1cm4gZ09QRChPLCBQKTtcclxuICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XHJcbiAgaWYoaGFzKE8sIFApKXJldHVybiBjcmVhdGVEZXNjKCFwSUUuZi5jYWxsKE8sIFApLCBPW1BdKTtcclxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1nb3BkLmpzXG4gKiogbW9kdWxlIGlkID0gNTFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcclxuLy8gMTkuMS4yLjIgLyAxNS4yLjMuNSBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXHJcbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0Jywge2NyZWF0ZTogcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpfSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuY3JlYXRlLmpzXG4gKiogbW9kdWxlIGlkID0gNTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XHJcbi8vIDE5LjEuMi40IC8gMTUuMi4zLjYgT2JqZWN0LmRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpXHJcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyksICdPYmplY3QnLCB7ZGVmaW5lUHJvcGVydHk6IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmZ9KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydHkuanNcbiAqKiBtb2R1bGUgaWQgPSA1M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcclxuLy8gMTkuMS4yLjMgLyAxNS4yLjMuNyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKVxyXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpLCAnT2JqZWN0Jywge2RlZmluZVByb3BlcnRpZXM6IHJlcXVpcmUoJy4vX29iamVjdC1kcHMnKX0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmRlZmluZS1wcm9wZXJ0aWVzLmpzXG4gKiogbW9kdWxlIGlkID0gNTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDE5LjEuMi42IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUClcbnZhciB0b0lPYmplY3QgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJykuZjtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3InLCBmdW5jdGlvbigpe1xuICByZXR1cm4gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGl0LCBrZXkpe1xuICAgIHJldHVybiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRvSU9iamVjdChpdCksIGtleSk7XG4gIH07XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanNcbiAqKiBtb2R1bGUgaWQgPSA1NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gbW9zdCBPYmplY3QgbWV0aG9kcyBieSBFUzYgc2hvdWxkIGFjY2VwdCBwcmltaXRpdmVzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgY29yZSAgICA9IHJlcXVpcmUoJy4vX2NvcmUnKVxuICAsIGZhaWxzICAgPSByZXF1aXJlKCcuL19mYWlscycpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihLRVksIGV4ZWMpe1xuICB2YXIgZm4gID0gKGNvcmUuT2JqZWN0IHx8IHt9KVtLRVldIHx8IE9iamVjdFtLRVldXG4gICAgLCBleHAgPSB7fTtcbiAgZXhwW0tFWV0gPSBleGVjKGZuKTtcbiAgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiBmYWlscyhmdW5jdGlvbigpeyBmbigxKTsgfSksICdPYmplY3QnLCBleHApO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1zYXAuanNcbiAqKiBtb2R1bGUgaWQgPSA1NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMTkuMS4yLjkgT2JqZWN0LmdldFByb3RvdHlwZU9mKE8pXG52YXIgdG9PYmplY3QgICAgICAgID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCAkZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnZ2V0UHJvdG90eXBlT2YnLCBmdW5jdGlvbigpe1xuICByZXR1cm4gZnVuY3Rpb24gZ2V0UHJvdG90eXBlT2YoaXQpe1xuICAgIHJldHVybiAkZ2V0UHJvdG90eXBlT2YodG9PYmplY3QoaXQpKTtcbiAgfTtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmdldC1wcm90b3R5cGUtb2YuanNcbiAqKiBtb2R1bGUgaWQgPSA1N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gNy4xLjEzIFRvT2JqZWN0KGFyZ3VtZW50KVxudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIE9iamVjdChkZWZpbmVkKGl0KSk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fdG8tb2JqZWN0LmpzXG4gKiogbW9kdWxlIGlkID0gNThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDE5LjEuMi45IC8gMTUuMi4zLjIgT2JqZWN0LmdldFByb3RvdHlwZU9mKE8pXHJcbnZhciBoYXMgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXHJcbiAgLCB0b09iamVjdCAgICA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXHJcbiAgLCBJRV9QUk9UTyAgICA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKVxyXG4gICwgT2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24oTyl7XHJcbiAgTyA9IHRvT2JqZWN0KE8pO1xyXG4gIGlmKGhhcyhPLCBJRV9QUk9UTykpcmV0dXJuIE9bSUVfUFJPVE9dO1xyXG4gIGlmKHR5cGVvZiBPLmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgTyBpbnN0YW5jZW9mIE8uY29uc3RydWN0b3Ipe1xyXG4gICAgcmV0dXJuIE8uY29uc3RydWN0b3IucHJvdG90eXBlO1xyXG4gIH0gcmV0dXJuIE8gaW5zdGFuY2VvZiBPYmplY3QgPyBPYmplY3RQcm90byA6IG51bGw7XHJcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ3BvLmpzXG4gKiogbW9kdWxlIGlkID0gNTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDE5LjEuMi4xNCBPYmplY3Qua2V5cyhPKVxudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCAka2V5cyAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgna2V5cycsIGZ1bmN0aW9uKCl7XG4gIHJldHVybiBmdW5jdGlvbiBrZXlzKGl0KXtcbiAgICByZXR1cm4gJGtleXModG9PYmplY3QoaXQpKTtcbiAgfTtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmtleXMuanNcbiAqKiBtb2R1bGUgaWQgPSA2MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMTkuMS4yLjcgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnZ2V0T3duUHJvcGVydHlOYW1lcycsIGZ1bmN0aW9uKCl7XG4gIHJldHVybiByZXF1aXJlKCcuL19vYmplY3QtZ29wbi1leHQnKS5mO1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcy5qc1xuICoqIG1vZHVsZSBpZCA9IDYxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAxOS4xLjIuNSBPYmplY3QuZnJlZXplKE8pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIG1ldGEgICAgID0gcmVxdWlyZSgnLi9fbWV0YScpLm9uRnJlZXplO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2ZyZWV6ZScsIGZ1bmN0aW9uKCRmcmVlemUpe1xuICByZXR1cm4gZnVuY3Rpb24gZnJlZXplKGl0KXtcbiAgICByZXR1cm4gJGZyZWV6ZSAmJiBpc09iamVjdChpdCkgPyAkZnJlZXplKG1ldGEoaXQpKSA6IGl0O1xuICB9O1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuZnJlZXplLmpzXG4gKiogbW9kdWxlIGlkID0gNjJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDE5LjEuMi4xNyBPYmplY3Quc2VhbChPKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBtZXRhICAgICA9IHJlcXVpcmUoJy4vX21ldGEnKS5vbkZyZWV6ZTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdzZWFsJywgZnVuY3Rpb24oJHNlYWwpe1xuICByZXR1cm4gZnVuY3Rpb24gc2VhbChpdCl7XG4gICAgcmV0dXJuICRzZWFsICYmIGlzT2JqZWN0KGl0KSA/ICRzZWFsKG1ldGEoaXQpKSA6IGl0O1xuICB9O1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3Quc2VhbC5qc1xuICoqIG1vZHVsZSBpZCA9IDYzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAxOS4xLjIuMTUgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKE8pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIG1ldGEgICAgID0gcmVxdWlyZSgnLi9fbWV0YScpLm9uRnJlZXplO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ3ByZXZlbnRFeHRlbnNpb25zJywgZnVuY3Rpb24oJHByZXZlbnRFeHRlbnNpb25zKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIHByZXZlbnRFeHRlbnNpb25zKGl0KXtcbiAgICByZXR1cm4gJHByZXZlbnRFeHRlbnNpb25zICYmIGlzT2JqZWN0KGl0KSA/ICRwcmV2ZW50RXh0ZW5zaW9ucyhtZXRhKGl0KSkgOiBpdDtcbiAgfTtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnByZXZlbnQtZXh0ZW5zaW9ucy5qc1xuICoqIG1vZHVsZSBpZCA9IDY0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAxOS4xLjIuMTIgT2JqZWN0LmlzRnJvemVuKE8pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdpc0Zyb3plbicsIGZ1bmN0aW9uKCRpc0Zyb3plbil7XG4gIHJldHVybiBmdW5jdGlvbiBpc0Zyb3plbihpdCl7XG4gICAgcmV0dXJuIGlzT2JqZWN0KGl0KSA/ICRpc0Zyb3plbiA/ICRpc0Zyb3plbihpdCkgOiBmYWxzZSA6IHRydWU7XG4gIH07XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5pcy1mcm96ZW4uanNcbiAqKiBtb2R1bGUgaWQgPSA2NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMTkuMS4yLjEzIE9iamVjdC5pc1NlYWxlZChPKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnaXNTZWFsZWQnLCBmdW5jdGlvbigkaXNTZWFsZWQpe1xuICByZXR1cm4gZnVuY3Rpb24gaXNTZWFsZWQoaXQpe1xuICAgIHJldHVybiBpc09iamVjdChpdCkgPyAkaXNTZWFsZWQgPyAkaXNTZWFsZWQoaXQpIDogZmFsc2UgOiB0cnVlO1xuICB9O1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuaXMtc2VhbGVkLmpzXG4gKiogbW9kdWxlIGlkID0gNjZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDE5LjEuMi4xMSBPYmplY3QuaXNFeHRlbnNpYmxlKE8pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdpc0V4dGVuc2libGUnLCBmdW5jdGlvbigkaXNFeHRlbnNpYmxlKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGlzRXh0ZW5zaWJsZShpdCl7XG4gICAgcmV0dXJuIGlzT2JqZWN0KGl0KSA/ICRpc0V4dGVuc2libGUgPyAkaXNFeHRlbnNpYmxlKGl0KSA6IHRydWUgOiBmYWxzZTtcbiAgfTtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmlzLWV4dGVuc2libGUuanNcbiAqKiBtb2R1bGUgaWQgPSA2N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMTkuMS4zLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSlcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GLCAnT2JqZWN0Jywge2Fzc2lnbjogcmVxdWlyZSgnLi9fb2JqZWN0LWFzc2lnbicpfSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuYXNzaWduLmpzXG4gKiogbW9kdWxlIGlkID0gNjhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0Jztcbi8vIDE5LjEuMi4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UsIC4uLilcbnZhciBnZXRLZXlzICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJylcbiAgLCBnT1BTICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJylcbiAgLCBwSUUgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKVxuICAsIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCBJT2JqZWN0ICA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKVxuICAsICRhc3NpZ24gID0gT2JqZWN0LmFzc2lnbjtcblxuLy8gc2hvdWxkIHdvcmsgd2l0aCBzeW1ib2xzIGFuZCBzaG91bGQgaGF2ZSBkZXRlcm1pbmlzdGljIHByb3BlcnR5IG9yZGVyIChWOCBidWcpXG5tb2R1bGUuZXhwb3J0cyA9ICEkYXNzaWduIHx8IHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgdmFyIEEgPSB7fVxuICAgICwgQiA9IHt9XG4gICAgLCBTID0gU3ltYm9sKClcbiAgICAsIEsgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3QnO1xuICBBW1NdID0gNztcbiAgSy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbihrKXsgQltrXSA9IGs7IH0pO1xuICByZXR1cm4gJGFzc2lnbih7fSwgQSlbU10gIT0gNyB8fCBPYmplY3Qua2V5cygkYXNzaWduKHt9LCBCKSkuam9pbignJykgIT0gSztcbn0pID8gZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlKXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICB2YXIgVCAgICAgPSB0b09iamVjdCh0YXJnZXQpXG4gICAgLCBhTGVuICA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAsIGluZGV4ID0gMVxuICAgICwgZ2V0U3ltYm9scyA9IGdPUFMuZlxuICAgICwgaXNFbnVtICAgICA9IHBJRS5mO1xuICB3aGlsZShhTGVuID4gaW5kZXgpe1xuICAgIHZhciBTICAgICAgPSBJT2JqZWN0KGFyZ3VtZW50c1tpbmRleCsrXSlcbiAgICAgICwga2V5cyAgID0gZ2V0U3ltYm9scyA/IGdldEtleXMoUykuY29uY2F0KGdldFN5bWJvbHMoUykpIDogZ2V0S2V5cyhTKVxuICAgICAgLCBsZW5ndGggPSBrZXlzLmxlbmd0aFxuICAgICAgLCBqICAgICAgPSAwXG4gICAgICAsIGtleTtcbiAgICB3aGlsZShsZW5ndGggPiBqKWlmKGlzRW51bS5jYWxsKFMsIGtleSA9IGtleXNbaisrXSkpVFtrZXldID0gU1trZXldO1xuICB9IHJldHVybiBUO1xufSA6ICRhc3NpZ247XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtYXNzaWduLmpzXG4gKiogbW9kdWxlIGlkID0gNjlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDE5LjEuMy4xMCBPYmplY3QuaXModmFsdWUxLCB2YWx1ZTIpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7aXM6IHJlcXVpcmUoJy4vX3NhbWUtdmFsdWUnKX0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmlzLmpzXG4gKiogbW9kdWxlIGlkID0gNzBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDcuMi45IFNhbWVWYWx1ZSh4LCB5KVxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuaXMgfHwgZnVuY3Rpb24gaXMoeCwgeSl7XG4gIHJldHVybiB4ID09PSB5ID8geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHkgOiB4ICE9IHggJiYgeSAhPSB5O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX3NhbWUtdmFsdWUuanNcbiAqKiBtb2R1bGUgaWQgPSA3MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMTkuMS4zLjE5IE9iamVjdC5zZXRQcm90b3R5cGVPZihPLCBwcm90bylcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHtzZXRQcm90b3R5cGVPZjogcmVxdWlyZSgnLi9fc2V0LXByb3RvJykuc2V0fSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3Quc2V0LXByb3RvdHlwZS1vZi5qc1xuICoqIG1vZHVsZSBpZCA9IDcyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBXb3JrcyB3aXRoIF9fcHJvdG9fXyBvbmx5LiBPbGQgdjggY2FuJ3Qgd29yayB3aXRoIG51bGwgcHJvdG8gb2JqZWN0cy5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgY2hlY2sgPSBmdW5jdGlvbihPLCBwcm90byl7XG4gIGFuT2JqZWN0KE8pO1xuICBpZighaXNPYmplY3QocHJvdG8pICYmIHByb3RvICE9PSBudWxsKXRocm93IFR5cGVFcnJvcihwcm90byArIFwiOiBjYW4ndCBzZXQgYXMgcHJvdG90eXBlIVwiKTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgKCdfX3Byb3RvX18nIGluIHt9ID8gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIGZ1bmN0aW9uKHRlc3QsIGJ1Z2d5LCBzZXQpe1xuICAgICAgdHJ5IHtcbiAgICAgICAgc2V0ID0gcmVxdWlyZSgnLi9fY3R4JykoRnVuY3Rpb24uY2FsbCwgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mKE9iamVjdC5wcm90b3R5cGUsICdfX3Byb3RvX18nKS5zZXQsIDIpO1xuICAgICAgICBzZXQodGVzdCwgW10pO1xuICAgICAgICBidWdneSA9ICEodGVzdCBpbnN0YW5jZW9mIEFycmF5KTtcbiAgICAgIH0gY2F0Y2goZSl7IGJ1Z2d5ID0gdHJ1ZTsgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNldFByb3RvdHlwZU9mKE8sIHByb3RvKXtcbiAgICAgICAgY2hlY2soTywgcHJvdG8pO1xuICAgICAgICBpZihidWdneSlPLl9fcHJvdG9fXyA9IHByb3RvO1xuICAgICAgICBlbHNlIHNldChPLCBwcm90byk7XG4gICAgICAgIHJldHVybiBPO1xuICAgICAgfTtcbiAgICB9KHt9LCBmYWxzZSkgOiB1bmRlZmluZWQpLFxuICBjaGVjazogY2hlY2tcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19zZXQtcHJvdG8uanNcbiAqKiBtb2R1bGUgaWQgPSA3M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMTkuMS4zLjYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZygpXG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKVxuICAsIHRlc3QgICAgPSB7fTtcbnRlc3RbcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyldID0gJ3onO1xuaWYodGVzdCArICcnICE9ICdbb2JqZWN0IHpdJyl7XG4gIHJlcXVpcmUoJy4vX3JlZGVmaW5lJykoT2JqZWN0LnByb3RvdHlwZSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24gdG9TdHJpbmcoKXtcbiAgICByZXR1cm4gJ1tvYmplY3QgJyArIGNsYXNzb2YodGhpcykgKyAnXSc7XG4gIH0sIHRydWUpO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZy5qc1xuICoqIG1vZHVsZSBpZCA9IDc0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBnZXR0aW5nIHRhZyBmcm9tIDE5LjEuMy42IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcoKVxudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpXG4gICwgVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJylcbiAgLy8gRVMzIHdyb25nIGhlcmVcbiAgLCBBUkcgPSBjb2YoZnVuY3Rpb24oKXsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA9PSAnQXJndW1lbnRzJztcblxuLy8gZmFsbGJhY2sgZm9yIElFMTEgU2NyaXB0IEFjY2VzcyBEZW5pZWQgZXJyb3JcbnZhciB0cnlHZXQgPSBmdW5jdGlvbihpdCwga2V5KXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gaXRba2V5XTtcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHZhciBPLCBULCBCO1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/ICdVbmRlZmluZWQnIDogaXQgPT09IG51bGwgPyAnTnVsbCdcbiAgICAvLyBAQHRvU3RyaW5nVGFnIGNhc2VcbiAgICA6IHR5cGVvZiAoVCA9IHRyeUdldChPID0gT2JqZWN0KGl0KSwgVEFHKSkgPT0gJ3N0cmluZycgPyBUXG4gICAgLy8gYnVpbHRpblRhZyBjYXNlXG4gICAgOiBBUkcgPyBjb2YoTylcbiAgICAvLyBFUzMgYXJndW1lbnRzIGZhbGxiYWNrXG4gICAgOiAoQiA9IGNvZihPKSkgPT0gJ09iamVjdCcgJiYgdHlwZW9mIE8uY2FsbGVlID09ICdmdW5jdGlvbicgPyAnQXJndW1lbnRzJyA6IEI7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fY2xhc3NvZi5qc1xuICoqIG1vZHVsZSBpZCA9IDc1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAxOS4yLjMuMiAvIDE1LjMuNC41IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kKHRoaXNBcmcsIGFyZ3MuLi4pXHJcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XHJcblxyXG4kZXhwb3J0KCRleHBvcnQuUCwgJ0Z1bmN0aW9uJywge2JpbmQ6IHJlcXVpcmUoJy4vX2JpbmQnKX0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuZnVuY3Rpb24uYmluZC5qc1xuICoqIG1vZHVsZSBpZCA9IDc2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgYUZ1bmN0aW9uICA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKVxuICAsIGlzT2JqZWN0ICAgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGludm9rZSAgICAgPSByZXF1aXJlKCcuL19pbnZva2UnKVxuICAsIGFycmF5U2xpY2UgPSBbXS5zbGljZVxuICAsIGZhY3RvcmllcyAgPSB7fTtcblxudmFyIGNvbnN0cnVjdCA9IGZ1bmN0aW9uKEYsIGxlbiwgYXJncyl7XG4gIGlmKCEobGVuIGluIGZhY3Rvcmllcykpe1xuICAgIGZvcih2YXIgbiA9IFtdLCBpID0gMDsgaSA8IGxlbjsgaSsrKW5baV0gPSAnYVsnICsgaSArICddJztcbiAgICBmYWN0b3JpZXNbbGVuXSA9IEZ1bmN0aW9uKCdGLGEnLCAncmV0dXJuIG5ldyBGKCcgKyBuLmpvaW4oJywnKSArICcpJyk7XG4gIH0gcmV0dXJuIGZhY3Rvcmllc1tsZW5dKEYsIGFyZ3MpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBGdW5jdGlvbi5iaW5kIHx8IGZ1bmN0aW9uIGJpbmQodGhhdCAvKiwgYXJncy4uLiAqLyl7XG4gIHZhciBmbiAgICAgICA9IGFGdW5jdGlvbih0aGlzKVxuICAgICwgcGFydEFyZ3MgPSBhcnJheVNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgdmFyIGJvdW5kID0gZnVuY3Rpb24oLyogYXJncy4uLiAqLyl7XG4gICAgdmFyIGFyZ3MgPSBwYXJ0QXJncy5jb25jYXQoYXJyYXlTbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgYm91bmQgPyBjb25zdHJ1Y3QoZm4sIGFyZ3MubGVuZ3RoLCBhcmdzKSA6IGludm9rZShmbiwgYXJncywgdGhhdCk7XG4gIH07XG4gIGlmKGlzT2JqZWN0KGZuLnByb3RvdHlwZSkpYm91bmQucHJvdG90eXBlID0gZm4ucHJvdG90eXBlO1xuICByZXR1cm4gYm91bmQ7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fYmluZC5qc1xuICoqIG1vZHVsZSBpZCA9IDc3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBmYXN0IGFwcGx5LCBodHRwOi8vanNwZXJmLmxua2l0LmNvbS9mYXN0LWFwcGx5LzVcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZm4sIGFyZ3MsIHRoYXQpe1xuICB2YXIgdW4gPSB0aGF0ID09PSB1bmRlZmluZWQ7XG4gIHN3aXRjaChhcmdzLmxlbmd0aCl7XG4gICAgY2FzZSAwOiByZXR1cm4gdW4gPyBmbigpXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQpO1xuICAgIGNhc2UgMTogcmV0dXJuIHVuID8gZm4oYXJnc1swXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSk7XG4gICAgY2FzZSAyOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICBjYXNlIDM6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgIGNhc2UgNDogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSk7XG4gIH0gcmV0dXJuICAgICAgICAgICAgICBmbi5hcHBseSh0aGF0LCBhcmdzKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19pbnZva2UuanNcbiAqKiBtb2R1bGUgaWQgPSA3OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGRQICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mXG4gICwgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKVxuICAsIGhhcyAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIEZQcm90byAgICAgPSBGdW5jdGlvbi5wcm90b3R5cGVcbiAgLCBuYW1lUkUgICAgID0gL15cXHMqZnVuY3Rpb24gKFteIChdKikvXG4gICwgTkFNRSAgICAgICA9ICduYW1lJztcblxudmFyIGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGUgfHwgZnVuY3Rpb24oKXtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vLyAxOS4yLjQuMiBuYW1lXG5OQU1FIGluIEZQcm90byB8fCByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmIGRQKEZQcm90bywgTkFNRSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24oKXtcbiAgICB0cnkge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzXG4gICAgICAgICwgbmFtZSA9ICgnJyArIHRoYXQpLm1hdGNoKG5hbWVSRSlbMV07XG4gICAgICBoYXModGhhdCwgTkFNRSkgfHwgIWlzRXh0ZW5zaWJsZSh0aGF0KSB8fCBkUCh0aGF0LCBOQU1FLCBjcmVhdGVEZXNjKDUsIG5hbWUpKTtcbiAgICAgIHJldHVybiBuYW1lO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmZ1bmN0aW9uLm5hbWUuanNcbiAqKiBtb2R1bGUgaWQgPSA3OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGlzT2JqZWN0ICAgICAgID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKVxuICAsIEhBU19JTlNUQU5DRSAgID0gcmVxdWlyZSgnLi9fd2tzJykoJ2hhc0luc3RhbmNlJylcbiAgLCBGdW5jdGlvblByb3RvICA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbi8vIDE5LjIuMy42IEZ1bmN0aW9uLnByb3RvdHlwZVtAQGhhc0luc3RhbmNlXShWKVxuaWYoIShIQVNfSU5TVEFOQ0UgaW4gRnVuY3Rpb25Qcm90bykpcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZihGdW5jdGlvblByb3RvLCBIQVNfSU5TVEFOQ0UsIHt2YWx1ZTogZnVuY3Rpb24oTyl7XG4gIGlmKHR5cGVvZiB0aGlzICE9ICdmdW5jdGlvbicgfHwgIWlzT2JqZWN0KE8pKXJldHVybiBmYWxzZTtcbiAgaWYoIWlzT2JqZWN0KHRoaXMucHJvdG90eXBlKSlyZXR1cm4gTyBpbnN0YW5jZW9mIHRoaXM7XG4gIC8vIGZvciBlbnZpcm9ubWVudCB3L28gbmF0aXZlIGBAQGhhc0luc3RhbmNlYCBsb2dpYyBlbm91Z2ggYGluc3RhbmNlb2ZgLCBidXQgYWRkIHRoaXM6XG4gIHdoaWxlKE8gPSBnZXRQcm90b3R5cGVPZihPKSlpZih0aGlzLnByb3RvdHlwZSA9PT0gTylyZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIGZhbHNlO1xufX0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuZnVuY3Rpb24uaGFzLWluc3RhbmNlLmpzXG4gKiogbW9kdWxlIGlkID0gODBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciAkZXhwb3J0ICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxyXG4gICwgJHBhcnNlSW50ID0gcmVxdWlyZSgnLi9fcGFyc2UtaW50Jyk7XHJcbi8vIDE4LjIuNSBwYXJzZUludChzdHJpbmcsIHJhZGl4KVxyXG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuRiAqIChwYXJzZUludCAhPSAkcGFyc2VJbnQpLCB7cGFyc2VJbnQ6ICRwYXJzZUludH0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucGFyc2UtaW50LmpzXG4gKiogbW9kdWxlIGlkID0gODFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciAkcGFyc2VJbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5wYXJzZUludFxuICAsICR0cmltICAgICA9IHJlcXVpcmUoJy4vX3N0cmluZy10cmltJykudHJpbVxuICAsIHdzICAgICAgICA9IHJlcXVpcmUoJy4vX3N0cmluZy13cycpXG4gICwgaGV4ICAgICAgID0gL15bXFwtK10/MFt4WF0vO1xuXG5tb2R1bGUuZXhwb3J0cyA9ICRwYXJzZUludCh3cyArICcwOCcpICE9PSA4IHx8ICRwYXJzZUludCh3cyArICcweDE2JykgIT09IDIyID8gZnVuY3Rpb24gcGFyc2VJbnQoc3RyLCByYWRpeCl7XG4gIHZhciBzdHJpbmcgPSAkdHJpbShTdHJpbmcoc3RyKSwgMyk7XG4gIHJldHVybiAkcGFyc2VJbnQoc3RyaW5nLCAocmFkaXggPj4+IDApIHx8IChoZXgudGVzdChzdHJpbmcpID8gMTYgOiAxMCkpO1xufSA6ICRwYXJzZUludDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX3BhcnNlLWludC5qc1xuICoqIG1vZHVsZSBpZCA9IDgyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKVxuICAsIGZhaWxzICAgPSByZXF1aXJlKCcuL19mYWlscycpXG4gICwgc3BhY2VzICA9IHJlcXVpcmUoJy4vX3N0cmluZy13cycpXG4gICwgc3BhY2UgICA9ICdbJyArIHNwYWNlcyArICddJ1xuICAsIG5vbiAgICAgPSAnXFx1MjAwYlxcdTAwODUnXG4gICwgbHRyaW0gICA9IFJlZ0V4cCgnXicgKyBzcGFjZSArIHNwYWNlICsgJyonKVxuICAsIHJ0cmltICAgPSBSZWdFeHAoc3BhY2UgKyBzcGFjZSArICcqJCcpO1xuXG52YXIgZXhwb3J0ZXIgPSBmdW5jdGlvbihLRVksIGV4ZWMsIEFMSUFTKXtcbiAgdmFyIGV4cCAgID0ge307XG4gIHZhciBGT1JDRSA9IGZhaWxzKGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuICEhc3BhY2VzW0tFWV0oKSB8fCBub25bS0VZXSgpICE9IG5vbjtcbiAgfSk7XG4gIHZhciBmbiA9IGV4cFtLRVldID0gRk9SQ0UgPyBleGVjKHRyaW0pIDogc3BhY2VzW0tFWV07XG4gIGlmKEFMSUFTKWV4cFtBTElBU10gPSBmbjtcbiAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBGT1JDRSwgJ1N0cmluZycsIGV4cCk7XG59O1xuXG4vLyAxIC0+IFN0cmluZyN0cmltTGVmdFxuLy8gMiAtPiBTdHJpbmcjdHJpbVJpZ2h0XG4vLyAzIC0+IFN0cmluZyN0cmltXG52YXIgdHJpbSA9IGV4cG9ydGVyLnRyaW0gPSBmdW5jdGlvbihzdHJpbmcsIFRZUEUpe1xuICBzdHJpbmcgPSBTdHJpbmcoZGVmaW5lZChzdHJpbmcpKTtcbiAgaWYoVFlQRSAmIDEpc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UobHRyaW0sICcnKTtcbiAgaWYoVFlQRSAmIDIpc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocnRyaW0sICcnKTtcbiAgcmV0dXJuIHN0cmluZztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0ZXI7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19zdHJpbmctdHJpbS5qc1xuICoqIG1vZHVsZSBpZCA9IDgzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9ICdcXHgwOVxceDBBXFx4MEJcXHgwQ1xceDBEXFx4MjBcXHhBMFxcdTE2ODBcXHUxODBFXFx1MjAwMFxcdTIwMDFcXHUyMDAyXFx1MjAwMycgK1xyXG4gICdcXHUyMDA0XFx1MjAwNVxcdTIwMDZcXHUyMDA3XFx1MjAwOFxcdTIwMDlcXHUyMDBBXFx1MjAyRlxcdTIwNUZcXHUzMDAwXFx1MjAyOFxcdTIwMjlcXHVGRUZGJztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy13cy5qc1xuICoqIG1vZHVsZSBpZCA9IDg0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgJGV4cG9ydCAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxyXG4gICwgJHBhcnNlRmxvYXQgPSByZXF1aXJlKCcuL19wYXJzZS1mbG9hdCcpO1xyXG4vLyAxOC4yLjQgcGFyc2VGbG9hdChzdHJpbmcpXHJcbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5GICogKHBhcnNlRmxvYXQgIT0gJHBhcnNlRmxvYXQpLCB7cGFyc2VGbG9hdDogJHBhcnNlRmxvYXR9KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnBhcnNlLWZsb2F0LmpzXG4gKiogbW9kdWxlIGlkID0gODVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciAkcGFyc2VGbG9hdCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLnBhcnNlRmxvYXRcbiAgLCAkdHJpbSAgICAgICA9IHJlcXVpcmUoJy4vX3N0cmluZy10cmltJykudHJpbTtcblxubW9kdWxlLmV4cG9ydHMgPSAxIC8gJHBhcnNlRmxvYXQocmVxdWlyZSgnLi9fc3RyaW5nLXdzJykgKyAnLTAnKSAhPT0gLUluZmluaXR5ID8gZnVuY3Rpb24gcGFyc2VGbG9hdChzdHIpe1xuICB2YXIgc3RyaW5nID0gJHRyaW0oU3RyaW5nKHN0ciksIDMpXG4gICAgLCByZXN1bHQgPSAkcGFyc2VGbG9hdChzdHJpbmcpO1xuICByZXR1cm4gcmVzdWx0ID09PSAwICYmIHN0cmluZy5jaGFyQXQoMCkgPT0gJy0nID8gLTAgOiByZXN1bHQ7XG59IDogJHBhcnNlRmxvYXQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19wYXJzZS1mbG9hdC5qc1xuICoqIG1vZHVsZSBpZCA9IDg2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsICAgICAgICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGhhcyAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCBjb2YgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2NvZicpXG4gICwgaW5oZXJpdElmUmVxdWlyZWQgPSByZXF1aXJlKCcuL19pbmhlcml0LWlmLXJlcXVpcmVkJylcbiAgLCB0b1ByaW1pdGl2ZSAgICAgICA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpXG4gICwgZmFpbHMgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19mYWlscycpXG4gICwgZ09QTiAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmZcbiAgLCBnT1BEICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJykuZlxuICAsIGRQICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZlxuICAsICR0cmltICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fc3RyaW5nLXRyaW0nKS50cmltXG4gICwgTlVNQkVSICAgICAgICAgICAgPSAnTnVtYmVyJ1xuICAsICROdW1iZXIgICAgICAgICAgID0gZ2xvYmFsW05VTUJFUl1cbiAgLCBCYXNlICAgICAgICAgICAgICA9ICROdW1iZXJcbiAgLCBwcm90byAgICAgICAgICAgICA9ICROdW1iZXIucHJvdG90eXBlXG4gIC8vIE9wZXJhIH4xMiBoYXMgYnJva2VuIE9iamVjdCN0b1N0cmluZ1xuICAsIEJST0tFTl9DT0YgICAgICAgID0gY29mKHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKShwcm90bykpID09IE5VTUJFUlxuICAsIFRSSU0gICAgICAgICAgICAgID0gJ3RyaW0nIGluIFN0cmluZy5wcm90b3R5cGU7XG5cbi8vIDcuMS4zIFRvTnVtYmVyKGFyZ3VtZW50KVxudmFyIHRvTnVtYmVyID0gZnVuY3Rpb24oYXJndW1lbnQpe1xuICB2YXIgaXQgPSB0b1ByaW1pdGl2ZShhcmd1bWVudCwgZmFsc2UpO1xuICBpZih0eXBlb2YgaXQgPT0gJ3N0cmluZycgJiYgaXQubGVuZ3RoID4gMil7XG4gICAgaXQgPSBUUklNID8gaXQudHJpbSgpIDogJHRyaW0oaXQsIDMpO1xuICAgIHZhciBmaXJzdCA9IGl0LmNoYXJDb2RlQXQoMClcbiAgICAgICwgdGhpcmQsIHJhZGl4LCBtYXhDb2RlO1xuICAgIGlmKGZpcnN0ID09PSA0MyB8fCBmaXJzdCA9PT0gNDUpe1xuICAgICAgdGhpcmQgPSBpdC5jaGFyQ29kZUF0KDIpO1xuICAgICAgaWYodGhpcmQgPT09IDg4IHx8IHRoaXJkID09PSAxMjApcmV0dXJuIE5hTjsgLy8gTnVtYmVyKCcrMHgxJykgc2hvdWxkIGJlIE5hTiwgb2xkIFY4IGZpeFxuICAgIH0gZWxzZSBpZihmaXJzdCA9PT0gNDgpe1xuICAgICAgc3dpdGNoKGl0LmNoYXJDb2RlQXQoMSkpe1xuICAgICAgICBjYXNlIDY2IDogY2FzZSA5OCAgOiByYWRpeCA9IDI7IG1heENvZGUgPSA0OTsgYnJlYWs7IC8vIGZhc3QgZXF1YWwgL14wYlswMV0rJC9pXG4gICAgICAgIGNhc2UgNzkgOiBjYXNlIDExMSA6IHJhZGl4ID0gODsgbWF4Q29kZSA9IDU1OyBicmVhazsgLy8gZmFzdCBlcXVhbCAvXjBvWzAtN10rJC9pXG4gICAgICAgIGRlZmF1bHQgOiByZXR1cm4gK2l0O1xuICAgICAgfVxuICAgICAgZm9yKHZhciBkaWdpdHMgPSBpdC5zbGljZSgyKSwgaSA9IDAsIGwgPSBkaWdpdHMubGVuZ3RoLCBjb2RlOyBpIDwgbDsgaSsrKXtcbiAgICAgICAgY29kZSA9IGRpZ2l0cy5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAvLyBwYXJzZUludCBwYXJzZXMgYSBzdHJpbmcgdG8gYSBmaXJzdCB1bmF2YWlsYWJsZSBzeW1ib2xcbiAgICAgICAgLy8gYnV0IFRvTnVtYmVyIHNob3VsZCByZXR1cm4gTmFOIGlmIGEgc3RyaW5nIGNvbnRhaW5zIHVuYXZhaWxhYmxlIHN5bWJvbHNcbiAgICAgICAgaWYoY29kZSA8IDQ4IHx8IGNvZGUgPiBtYXhDb2RlKXJldHVybiBOYU47XG4gICAgICB9IHJldHVybiBwYXJzZUludChkaWdpdHMsIHJhZGl4KTtcbiAgICB9XG4gIH0gcmV0dXJuICtpdDtcbn07XG5cbmlmKCEkTnVtYmVyKCcgMG8xJykgfHwgISROdW1iZXIoJzBiMScpIHx8ICROdW1iZXIoJysweDEnKSl7XG4gICROdW1iZXIgPSBmdW5jdGlvbiBOdW1iZXIodmFsdWUpe1xuICAgIHZhciBpdCA9IGFyZ3VtZW50cy5sZW5ndGggPCAxID8gMCA6IHZhbHVlXG4gICAgICAsIHRoYXQgPSB0aGlzO1xuICAgIHJldHVybiB0aGF0IGluc3RhbmNlb2YgJE51bWJlclxuICAgICAgLy8gY2hlY2sgb24gMS4uY29uc3RydWN0b3IoZm9vKSBjYXNlXG4gICAgICAmJiAoQlJPS0VOX0NPRiA/IGZhaWxzKGZ1bmN0aW9uKCl7IHByb3RvLnZhbHVlT2YuY2FsbCh0aGF0KTsgfSkgOiBjb2YodGhhdCkgIT0gTlVNQkVSKVxuICAgICAgICA/IGluaGVyaXRJZlJlcXVpcmVkKG5ldyBCYXNlKHRvTnVtYmVyKGl0KSksIHRoYXQsICROdW1iZXIpIDogdG9OdW1iZXIoaXQpO1xuICB9O1xuICBmb3IodmFyIGtleXMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZ09QTihCYXNlKSA6IChcbiAgICAvLyBFUzM6XG4gICAgJ01BWF9WQUxVRSxNSU5fVkFMVUUsTmFOLE5FR0FUSVZFX0lORklOSVRZLFBPU0lUSVZFX0lORklOSVRZLCcgK1xuICAgIC8vIEVTNiAoaW4gY2FzZSwgaWYgbW9kdWxlcyB3aXRoIEVTNiBOdW1iZXIgc3RhdGljcyByZXF1aXJlZCBiZWZvcmUpOlxuICAgICdFUFNJTE9OLGlzRmluaXRlLGlzSW50ZWdlcixpc05hTixpc1NhZmVJbnRlZ2VyLE1BWF9TQUZFX0lOVEVHRVIsJyArXG4gICAgJ01JTl9TQUZFX0lOVEVHRVIscGFyc2VGbG9hdCxwYXJzZUludCxpc0ludGVnZXInXG4gICkuc3BsaXQoJywnKSwgaiA9IDAsIGtleTsga2V5cy5sZW5ndGggPiBqOyBqKyspe1xuICAgIGlmKGhhcyhCYXNlLCBrZXkgPSBrZXlzW2pdKSAmJiAhaGFzKCROdW1iZXIsIGtleSkpe1xuICAgICAgZFAoJE51bWJlciwga2V5LCBnT1BEKEJhc2UsIGtleSkpO1xuICAgIH1cbiAgfVxuICAkTnVtYmVyLnByb3RvdHlwZSA9IHByb3RvO1xuICBwcm90by5jb25zdHJ1Y3RvciA9ICROdW1iZXI7XG4gIHJlcXVpcmUoJy4vX3JlZGVmaW5lJykoZ2xvYmFsLCBOVU1CRVIsICROdW1iZXIpO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmNvbnN0cnVjdG9yLmpzXG4gKiogbW9kdWxlIGlkID0gODdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBpc09iamVjdCAgICAgICA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXHJcbiAgLCBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX3NldC1wcm90bycpLnNldDtcclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih0aGF0LCB0YXJnZXQsIEMpe1xyXG4gIHZhciBQLCBTID0gdGFyZ2V0LmNvbnN0cnVjdG9yO1xyXG4gIGlmKFMgIT09IEMgJiYgdHlwZW9mIFMgPT0gJ2Z1bmN0aW9uJyAmJiAoUCA9IFMucHJvdG90eXBlKSAhPT0gQy5wcm90b3R5cGUgJiYgaXNPYmplY3QoUCkgJiYgc2V0UHJvdG90eXBlT2Ype1xyXG4gICAgc2V0UHJvdG90eXBlT2YodGhhdCwgUCk7XHJcbiAgfSByZXR1cm4gdGhhdDtcclxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2luaGVyaXQtaWYtcmVxdWlyZWQuanNcbiAqKiBtb2R1bGUgaWQgPSA4OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIgJGV4cG9ydCAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcclxuICAsIGFuSW5zdGFuY2UgICA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJylcclxuICAsIHRvSW50ZWdlciAgICA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKVxyXG4gICwgYU51bWJlclZhbHVlID0gcmVxdWlyZSgnLi9fYS1udW1iZXItdmFsdWUnKVxyXG4gICwgcmVwZWF0ICAgICAgID0gcmVxdWlyZSgnLi9fc3RyaW5nLXJlcGVhdCcpXHJcbiAgLCAkdG9GaXhlZCAgICAgPSAxLi50b0ZpeGVkXHJcbiAgLCBmbG9vciAgICAgICAgPSBNYXRoLmZsb29yXHJcbiAgLCBkYXRhICAgICAgICAgPSBbMCwgMCwgMCwgMCwgMCwgMF1cclxuICAsIEVSUk9SICAgICAgICA9ICdOdW1iZXIudG9GaXhlZDogaW5jb3JyZWN0IGludm9jYXRpb24hJ1xyXG4gICwgWkVSTyAgICAgICAgID0gJzAnO1xyXG5cclxudmFyIG11bHRpcGx5ID0gZnVuY3Rpb24obiwgYyl7XHJcbiAgdmFyIGkgID0gLTFcclxuICAgICwgYzIgPSBjO1xyXG4gIHdoaWxlKCsraSA8IDYpe1xyXG4gICAgYzIgKz0gbiAqIGRhdGFbaV07XHJcbiAgICBkYXRhW2ldID0gYzIgJSAxZTc7XHJcbiAgICBjMiA9IGZsb29yKGMyIC8gMWU3KTtcclxuICB9XHJcbn07XHJcbnZhciBkaXZpZGUgPSBmdW5jdGlvbihuKXtcclxuICB2YXIgaSA9IDZcclxuICAgICwgYyA9IDA7XHJcbiAgd2hpbGUoLS1pID49IDApe1xyXG4gICAgYyArPSBkYXRhW2ldO1xyXG4gICAgZGF0YVtpXSA9IGZsb29yKGMgLyBuKTtcclxuICAgIGMgPSAoYyAlIG4pICogMWU3O1xyXG4gIH1cclxufTtcclxudmFyIG51bVRvU3RyaW5nID0gZnVuY3Rpb24oKXtcclxuICB2YXIgaSA9IDZcclxuICAgICwgcyA9ICcnO1xyXG4gIHdoaWxlKC0taSA+PSAwKXtcclxuICAgIGlmKHMgIT09ICcnIHx8IGkgPT09IDAgfHwgZGF0YVtpXSAhPT0gMCl7XHJcbiAgICAgIHZhciB0ID0gU3RyaW5nKGRhdGFbaV0pO1xyXG4gICAgICBzID0gcyA9PT0gJycgPyB0IDogcyArIHJlcGVhdC5jYWxsKFpFUk8sIDcgLSB0Lmxlbmd0aCkgKyB0O1xyXG4gICAgfVxyXG4gIH0gcmV0dXJuIHM7XHJcbn07XHJcbnZhciBwb3cgPSBmdW5jdGlvbih4LCBuLCBhY2Mpe1xyXG4gIHJldHVybiBuID09PSAwID8gYWNjIDogbiAlIDIgPT09IDEgPyBwb3coeCwgbiAtIDEsIGFjYyAqIHgpIDogcG93KHggKiB4LCBuIC8gMiwgYWNjKTtcclxufTtcclxudmFyIGxvZyA9IGZ1bmN0aW9uKHgpe1xyXG4gIHZhciBuICA9IDBcclxuICAgICwgeDIgPSB4O1xyXG4gIHdoaWxlKHgyID49IDQwOTYpe1xyXG4gICAgbiArPSAxMjtcclxuICAgIHgyIC89IDQwOTY7XHJcbiAgfVxyXG4gIHdoaWxlKHgyID49IDIpe1xyXG4gICAgbiAgKz0gMTtcclxuICAgIHgyIC89IDI7XHJcbiAgfSByZXR1cm4gbjtcclxufTtcclxuXHJcbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKCEhJHRvRml4ZWQgJiYgKFxyXG4gIDAuMDAwMDgudG9GaXhlZCgzKSAhPT0gJzAuMDAwJyB8fFxyXG4gIDAuOS50b0ZpeGVkKDApICE9PSAnMScgfHxcclxuICAxLjI1NS50b0ZpeGVkKDIpICE9PSAnMS4yNScgfHxcclxuICAxMDAwMDAwMDAwMDAwMDAwMTI4Li50b0ZpeGVkKDApICE9PSAnMTAwMDAwMDAwMDAwMDAwMDEyOCdcclxuKSB8fCAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xyXG4gIC8vIFY4IH4gQW5kcm9pZCA0LjMtXHJcbiAgJHRvRml4ZWQuY2FsbCh7fSk7XHJcbn0pKSwgJ051bWJlcicsIHtcclxuICB0b0ZpeGVkOiBmdW5jdGlvbiB0b0ZpeGVkKGZyYWN0aW9uRGlnaXRzKXtcclxuICAgIHZhciB4ID0gYU51bWJlclZhbHVlKHRoaXMsIEVSUk9SKVxyXG4gICAgICAsIGYgPSB0b0ludGVnZXIoZnJhY3Rpb25EaWdpdHMpXHJcbiAgICAgICwgcyA9ICcnXHJcbiAgICAgICwgbSA9IFpFUk9cclxuICAgICAgLCBlLCB6LCBqLCBrO1xyXG4gICAgaWYoZiA8IDAgfHwgZiA+IDIwKXRocm93IFJhbmdlRXJyb3IoRVJST1IpO1xyXG4gICAgaWYoeCAhPSB4KXJldHVybiAnTmFOJztcclxuICAgIGlmKHggPD0gLTFlMjEgfHwgeCA+PSAxZTIxKXJldHVybiBTdHJpbmcoeCk7XHJcbiAgICBpZih4IDwgMCl7XHJcbiAgICAgIHMgPSAnLSc7XHJcbiAgICAgIHggPSAteDtcclxuICAgIH1cclxuICAgIGlmKHggPiAxZS0yMSl7XHJcbiAgICAgIGUgPSBsb2coeCAqIHBvdygyLCA2OSwgMSkpIC0gNjk7XHJcbiAgICAgIHogPSBlIDwgMCA/IHggKiBwb3coMiwgLWUsIDEpIDogeCAvIHBvdygyLCBlLCAxKTtcclxuICAgICAgeiAqPSAweDEwMDAwMDAwMDAwMDAwO1xyXG4gICAgICBlID0gNTIgLSBlO1xyXG4gICAgICBpZihlID4gMCl7XHJcbiAgICAgICAgbXVsdGlwbHkoMCwgeik7XHJcbiAgICAgICAgaiA9IGY7XHJcbiAgICAgICAgd2hpbGUoaiA+PSA3KXtcclxuICAgICAgICAgIG11bHRpcGx5KDFlNywgMCk7XHJcbiAgICAgICAgICBqIC09IDc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG11bHRpcGx5KHBvdygxMCwgaiwgMSksIDApO1xyXG4gICAgICAgIGogPSBlIC0gMTtcclxuICAgICAgICB3aGlsZShqID49IDIzKXtcclxuICAgICAgICAgIGRpdmlkZSgxIDw8IDIzKTtcclxuICAgICAgICAgIGogLT0gMjM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRpdmlkZSgxIDw8IGopO1xyXG4gICAgICAgIG11bHRpcGx5KDEsIDEpO1xyXG4gICAgICAgIGRpdmlkZSgyKTtcclxuICAgICAgICBtID0gbnVtVG9TdHJpbmcoKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBtdWx0aXBseSgwLCB6KTtcclxuICAgICAgICBtdWx0aXBseSgxIDw8IC1lLCAwKTtcclxuICAgICAgICBtID0gbnVtVG9TdHJpbmcoKSArIHJlcGVhdC5jYWxsKFpFUk8sIGYpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZihmID4gMCl7XHJcbiAgICAgIGsgPSBtLmxlbmd0aDtcclxuICAgICAgbSA9IHMgKyAoayA8PSBmID8gJzAuJyArIHJlcGVhdC5jYWxsKFpFUk8sIGYgLSBrKSArIG0gOiBtLnNsaWNlKDAsIGsgLSBmKSArICcuJyArIG0uc2xpY2UoayAtIGYpKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIG0gPSBzICsgbTtcclxuICAgIH0gcmV0dXJuIG07XHJcbiAgfVxyXG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci50by1maXhlZC5qc1xuICoqIG1vZHVsZSBpZCA9IDg5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCBDb25zdHJ1Y3RvciwgbmFtZSwgZm9yYmlkZGVuRmllbGQpe1xuICBpZighKGl0IGluc3RhbmNlb2YgQ29uc3RydWN0b3IpIHx8IChmb3JiaWRkZW5GaWVsZCAhPT0gdW5kZWZpbmVkICYmIGZvcmJpZGRlbkZpZWxkIGluIGl0KSl7XG4gICAgdGhyb3cgVHlwZUVycm9yKG5hbWUgKyAnOiBpbmNvcnJlY3QgaW52b2NhdGlvbiEnKTtcbiAgfSByZXR1cm4gaXQ7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fYW4taW5zdGFuY2UuanNcbiAqKiBtb2R1bGUgaWQgPSA5MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCBtc2cpe1xyXG4gIGlmKHR5cGVvZiBpdCAhPSAnbnVtYmVyJyAmJiBjb2YoaXQpICE9ICdOdW1iZXInKXRocm93IFR5cGVFcnJvcihtc2cpO1xyXG4gIHJldHVybiAraXQ7XHJcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19hLW51bWJlci12YWx1ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDkxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpXG4gICwgZGVmaW5lZCAgID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJlcGVhdChjb3VudCl7XG4gIHZhciBzdHIgPSBTdHJpbmcoZGVmaW5lZCh0aGlzKSlcbiAgICAsIHJlcyA9ICcnXG4gICAgLCBuICAgPSB0b0ludGVnZXIoY291bnQpO1xuICBpZihuIDwgMCB8fCBuID09IEluZmluaXR5KXRocm93IFJhbmdlRXJyb3IoXCJDb3VudCBjYW4ndCBiZSBuZWdhdGl2ZVwiKTtcbiAgZm9yKDtuID4gMDsgKG4gPj4+PSAxKSAmJiAoc3RyICs9IHN0cikpaWYobiAmIDEpcmVzICs9IHN0cjtcbiAgcmV0dXJuIHJlcztcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19zdHJpbmctcmVwZWF0LmpzXG4gKiogbW9kdWxlIGlkID0gOTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxudmFyICRleHBvcnQgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXHJcbiAgLCAkZmFpbHMgICAgICAgPSByZXF1aXJlKCcuL19mYWlscycpXHJcbiAgLCBhTnVtYmVyVmFsdWUgPSByZXF1aXJlKCcuL19hLW51bWJlci12YWx1ZScpXHJcbiAgLCAkdG9QcmVjaXNpb24gPSAxLi50b1ByZWNpc2lvbjtcclxuXHJcbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKCRmYWlscyhmdW5jdGlvbigpe1xyXG4gIC8vIElFNy1cclxuICByZXR1cm4gJHRvUHJlY2lzaW9uLmNhbGwoMSwgdW5kZWZpbmVkKSAhPT0gJzEnO1xyXG59KSB8fCAhJGZhaWxzKGZ1bmN0aW9uKCl7XHJcbiAgLy8gVjggfiBBbmRyb2lkIDQuMy1cclxuICAkdG9QcmVjaXNpb24uY2FsbCh7fSk7XHJcbn0pKSwgJ051bWJlcicsIHtcclxuICB0b1ByZWNpc2lvbjogZnVuY3Rpb24gdG9QcmVjaXNpb24ocHJlY2lzaW9uKXtcclxuICAgIHZhciB0aGF0ID0gYU51bWJlclZhbHVlKHRoaXMsICdOdW1iZXIjdG9QcmVjaXNpb246IGluY29ycmVjdCBpbnZvY2F0aW9uIScpO1xyXG4gICAgcmV0dXJuIHByZWNpc2lvbiA9PT0gdW5kZWZpbmVkID8gJHRvUHJlY2lzaW9uLmNhbGwodGhhdCkgOiAkdG9QcmVjaXNpb24uY2FsbCh0aGF0LCBwcmVjaXNpb24pOyBcclxuICB9XHJcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLnRvLXByZWNpc2lvbi5qc1xuICoqIG1vZHVsZSBpZCA9IDkzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAyMC4xLjIuMSBOdW1iZXIuRVBTSUxPTlxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdOdW1iZXInLCB7RVBTSUxPTjogTWF0aC5wb3coMiwgLTUyKX0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmVwc2lsb24uanNcbiAqKiBtb2R1bGUgaWQgPSA5NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMjAuMS4yLjIgTnVtYmVyLmlzRmluaXRlKG51bWJlcilcbnZhciAkZXhwb3J0ICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIF9pc0Zpbml0ZSA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmlzRmluaXRlO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ051bWJlcicsIHtcbiAgaXNGaW5pdGU6IGZ1bmN0aW9uIGlzRmluaXRlKGl0KXtcbiAgICByZXR1cm4gdHlwZW9mIGl0ID09ICdudW1iZXInICYmIF9pc0Zpbml0ZShpdCk7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmlzLWZpbml0ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDk1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAyMC4xLjIuMyBOdW1iZXIuaXNJbnRlZ2VyKG51bWJlcilcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywge2lzSW50ZWdlcjogcmVxdWlyZSgnLi9faXMtaW50ZWdlcicpfSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuaXMtaW50ZWdlci5qc1xuICoqIG1vZHVsZSBpZCA9IDk2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAyMC4xLjIuMyBOdW1iZXIuaXNJbnRlZ2VyKG51bWJlcilcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgZmxvb3IgICAgPSBNYXRoLmZsb29yO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0ludGVnZXIoaXQpe1xuICByZXR1cm4gIWlzT2JqZWN0KGl0KSAmJiBpc0Zpbml0ZShpdCkgJiYgZmxvb3IoaXQpID09PSBpdDtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19pcy1pbnRlZ2VyLmpzXG4gKiogbW9kdWxlIGlkID0gOTdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDIwLjEuMi40IE51bWJlci5pc05hTihudW1iZXIpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ051bWJlcicsIHtcbiAgaXNOYU46IGZ1bmN0aW9uIGlzTmFOKG51bWJlcil7XG4gICAgcmV0dXJuIG51bWJlciAhPSBudW1iZXI7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmlzLW5hbi5qc1xuICoqIG1vZHVsZSBpZCA9IDk4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAyMC4xLjIuNSBOdW1iZXIuaXNTYWZlSW50ZWdlcihudW1iZXIpXG52YXIgJGV4cG9ydCAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBpc0ludGVnZXIgPSByZXF1aXJlKCcuL19pcy1pbnRlZ2VyJylcbiAgLCBhYnMgICAgICAgPSBNYXRoLmFicztcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdOdW1iZXInLCB7XG4gIGlzU2FmZUludGVnZXI6IGZ1bmN0aW9uIGlzU2FmZUludGVnZXIobnVtYmVyKXtcbiAgICByZXR1cm4gaXNJbnRlZ2VyKG51bWJlcikgJiYgYWJzKG51bWJlcikgPD0gMHgxZmZmZmZmZmZmZmZmZjtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuaXMtc2FmZS1pbnRlZ2VyLmpzXG4gKiogbW9kdWxlIGlkID0gOTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDIwLjEuMi42IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ051bWJlcicsIHtNQVhfU0FGRV9JTlRFR0VSOiAweDFmZmZmZmZmZmZmZmZmfSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIubWF4LXNhZmUtaW50ZWdlci5qc1xuICoqIG1vZHVsZSBpZCA9IDEwMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMjAuMS4yLjEwIE51bWJlci5NSU5fU0FGRV9JTlRFR0VSXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ051bWJlcicsIHtNSU5fU0FGRV9JTlRFR0VSOiAtMHgxZmZmZmZmZmZmZmZmZn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLm1pbi1zYWZlLWludGVnZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciAkZXhwb3J0ICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJHBhcnNlRmxvYXQgPSByZXF1aXJlKCcuL19wYXJzZS1mbG9hdCcpO1xuLy8gMjAuMS4yLjEyIE51bWJlci5wYXJzZUZsb2F0KHN0cmluZylcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKE51bWJlci5wYXJzZUZsb2F0ICE9ICRwYXJzZUZsb2F0KSwgJ051bWJlcicsIHtwYXJzZUZsb2F0OiAkcGFyc2VGbG9hdH0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLnBhcnNlLWZsb2F0LmpzXG4gKiogbW9kdWxlIGlkID0gMTAyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgJGV4cG9ydCAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkcGFyc2VJbnQgPSByZXF1aXJlKCcuL19wYXJzZS1pbnQnKTtcbi8vIDIwLjEuMi4xMyBOdW1iZXIucGFyc2VJbnQoc3RyaW5nLCByYWRpeClcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKE51bWJlci5wYXJzZUludCAhPSAkcGFyc2VJbnQpLCAnTnVtYmVyJywge3BhcnNlSW50OiAkcGFyc2VJbnR9KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5wYXJzZS1pbnQuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDIwLjIuMi4zIE1hdGguYWNvc2goeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBsb2cxcCAgID0gcmVxdWlyZSgnLi9fbWF0aC1sb2cxcCcpXG4gICwgc3FydCAgICA9IE1hdGguc3FydFxuICAsICRhY29zaCAgPSBNYXRoLmFjb3NoO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICEoJGFjb3NoXG4gIC8vIFY4IGJ1ZzogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTM1MDlcbiAgJiYgTWF0aC5mbG9vcigkYWNvc2goTnVtYmVyLk1BWF9WQUxVRSkpID09IDcxMFxuICAvLyBUb3IgQnJvd3NlciBidWc6IE1hdGguYWNvc2goSW5maW5pdHkpIC0+IE5hTiBcbiAgJiYgJGFjb3NoKEluZmluaXR5KSA9PSBJbmZpbml0eVxuKSwgJ01hdGgnLCB7XG4gIGFjb3NoOiBmdW5jdGlvbiBhY29zaCh4KXtcbiAgICByZXR1cm4gKHggPSAreCkgPCAxID8gTmFOIDogeCA+IDk0OTA2MjY1LjYyNDI1MTU2XG4gICAgICA/IE1hdGgubG9nKHgpICsgTWF0aC5MTjJcbiAgICAgIDogbG9nMXAoeCAtIDEgKyBzcXJ0KHggLSAxKSAqIHNxcnQoeCArIDEpKTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmFjb3NoLmpzXG4gKiogbW9kdWxlIGlkID0gMTA0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAyMC4yLjIuMjAgTWF0aC5sb2cxcCh4KVxubW9kdWxlLmV4cG9ydHMgPSBNYXRoLmxvZzFwIHx8IGZ1bmN0aW9uIGxvZzFwKHgpe1xuICByZXR1cm4gKHggPSAreCkgPiAtMWUtOCAmJiB4IDwgMWUtOCA/IHggLSB4ICogeCAvIDIgOiBNYXRoLmxvZygxICsgeCk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fbWF0aC1sb2cxcC5qc1xuICoqIG1vZHVsZSBpZCA9IDEwNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMjAuMi4yLjUgTWF0aC5hc2luaCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRhc2luaCAgPSBNYXRoLmFzaW5oO1xuXG5mdW5jdGlvbiBhc2luaCh4KXtcbiAgcmV0dXJuICFpc0Zpbml0ZSh4ID0gK3gpIHx8IHggPT0gMCA/IHggOiB4IDwgMCA/IC1hc2luaCgteCkgOiBNYXRoLmxvZyh4ICsgTWF0aC5zcXJ0KHggKiB4ICsgMSkpO1xufVxuXG4vLyBUb3IgQnJvd3NlciBidWc6IE1hdGguYXNpbmgoMCkgLT4gLTAgXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICEoJGFzaW5oICYmIDEgLyAkYXNpbmgoMCkgPiAwKSwgJ01hdGgnLCB7YXNpbmg6IGFzaW5ofSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmFzaW5oLmpzXG4gKiogbW9kdWxlIGlkID0gMTA2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAyMC4yLjIuNyBNYXRoLmF0YW5oKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJGF0YW5oICA9IE1hdGguYXRhbmg7XG5cbi8vIFRvciBCcm93c2VyIGJ1ZzogTWF0aC5hdGFuaCgtMCkgLT4gMCBcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogISgkYXRhbmggJiYgMSAvICRhdGFuaCgtMCkgPCAwKSwgJ01hdGgnLCB7XG4gIGF0YW5oOiBmdW5jdGlvbiBhdGFuaCh4KXtcbiAgICByZXR1cm4gKHggPSAreCkgPT0gMCA/IHggOiBNYXRoLmxvZygoMSArIHgpIC8gKDEgLSB4KSkgLyAyO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguYXRhbmguanNcbiAqKiBtb2R1bGUgaWQgPSAxMDdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDIwLjIuMi45IE1hdGguY2JydCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHNpZ24gICAgPSByZXF1aXJlKCcuL19tYXRoLXNpZ24nKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBjYnJ0OiBmdW5jdGlvbiBjYnJ0KHgpe1xuICAgIHJldHVybiBzaWduKHggPSAreCkgKiBNYXRoLnBvdyhNYXRoLmFicyh4KSwgMSAvIDMpO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguY2JydC5qc1xuICoqIG1vZHVsZSBpZCA9IDEwOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMjAuMi4yLjI4IE1hdGguc2lnbih4KVxubW9kdWxlLmV4cG9ydHMgPSBNYXRoLnNpZ24gfHwgZnVuY3Rpb24gc2lnbih4KXtcbiAgcmV0dXJuICh4ID0gK3gpID09IDAgfHwgeCAhPSB4ID8geCA6IHggPCAwID8gLTEgOiAxO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX21hdGgtc2lnbi5qc1xuICoqIG1vZHVsZSBpZCA9IDEwOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMjAuMi4yLjExIE1hdGguY2x6MzIoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgY2x6MzI6IGZ1bmN0aW9uIGNsejMyKHgpe1xuICAgIHJldHVybiAoeCA+Pj49IDApID8gMzEgLSBNYXRoLmZsb29yKE1hdGgubG9nKHggKyAwLjUpICogTWF0aC5MT0cyRSkgOiAzMjtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmNsejMyLmpzXG4gKiogbW9kdWxlIGlkID0gMTEwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAyMC4yLjIuMTIgTWF0aC5jb3NoKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgZXhwICAgICA9IE1hdGguZXhwO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGNvc2g6IGZ1bmN0aW9uIGNvc2goeCl7XG4gICAgcmV0dXJuIChleHAoeCA9ICt4KSArIGV4cCgteCkpIC8gMjtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmNvc2guanNcbiAqKiBtb2R1bGUgaWQgPSAxMTFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDIwLjIuMi4xNCBNYXRoLmV4cG0xKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJGV4cG0xICA9IHJlcXVpcmUoJy4vX21hdGgtZXhwbTEnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoJGV4cG0xICE9IE1hdGguZXhwbTEpLCAnTWF0aCcsIHtleHBtMTogJGV4cG0xfSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmV4cG0xLmpzXG4gKiogbW9kdWxlIGlkID0gMTEyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAyMC4yLjIuMTQgTWF0aC5leHBtMSh4KVxudmFyICRleHBtMSA9IE1hdGguZXhwbTE7XG5tb2R1bGUuZXhwb3J0cyA9ICghJGV4cG0xXG4gIC8vIE9sZCBGRiBidWdcbiAgfHwgJGV4cG0xKDEwKSA+IDIyMDI1LjQ2NTc5NDgwNjcxOSB8fCAkZXhwbTEoMTApIDwgMjIwMjUuNDY1Nzk0ODA2NzE2NTE2OFxuICAvLyBUb3IgQnJvd3NlciBidWdcbiAgfHwgJGV4cG0xKC0yZS0xNykgIT0gLTJlLTE3XG4pID8gZnVuY3Rpb24gZXhwbTEoeCl7XG4gIHJldHVybiAoeCA9ICt4KSA9PSAwID8geCA6IHggPiAtMWUtNiAmJiB4IDwgMWUtNiA/IHggKyB4ICogeCAvIDIgOiBNYXRoLmV4cCh4KSAtIDE7XG59IDogJGV4cG0xO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fbWF0aC1leHBtMS5qc1xuICoqIG1vZHVsZSBpZCA9IDExM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMjAuMi4yLjE2IE1hdGguZnJvdW5kKHgpXG52YXIgJGV4cG9ydCAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBzaWduICAgICAgPSByZXF1aXJlKCcuL19tYXRoLXNpZ24nKVxuICAsIHBvdyAgICAgICA9IE1hdGgucG93XG4gICwgRVBTSUxPTiAgID0gcG93KDIsIC01MilcbiAgLCBFUFNJTE9OMzIgPSBwb3coMiwgLTIzKVxuICAsIE1BWDMyICAgICA9IHBvdygyLCAxMjcpICogKDIgLSBFUFNJTE9OMzIpXG4gICwgTUlOMzIgICAgID0gcG93KDIsIC0xMjYpO1xuXG52YXIgcm91bmRUaWVzVG9FdmVuID0gZnVuY3Rpb24obil7XG4gIHJldHVybiBuICsgMSAvIEVQU0lMT04gLSAxIC8gRVBTSUxPTjtcbn07XG5cblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBmcm91bmQ6IGZ1bmN0aW9uIGZyb3VuZCh4KXtcbiAgICB2YXIgJGFicyAgPSBNYXRoLmFicyh4KVxuICAgICAgLCAkc2lnbiA9IHNpZ24oeClcbiAgICAgICwgYSwgcmVzdWx0O1xuICAgIGlmKCRhYnMgPCBNSU4zMilyZXR1cm4gJHNpZ24gKiByb3VuZFRpZXNUb0V2ZW4oJGFicyAvIE1JTjMyIC8gRVBTSUxPTjMyKSAqIE1JTjMyICogRVBTSUxPTjMyO1xuICAgIGEgPSAoMSArIEVQU0lMT04zMiAvIEVQU0lMT04pICogJGFicztcbiAgICByZXN1bHQgPSBhIC0gKGEgLSAkYWJzKTtcbiAgICBpZihyZXN1bHQgPiBNQVgzMiB8fCByZXN1bHQgIT0gcmVzdWx0KXJldHVybiAkc2lnbiAqIEluZmluaXR5O1xuICAgIHJldHVybiAkc2lnbiAqIHJlc3VsdDtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmZyb3VuZC5qc1xuICoqIG1vZHVsZSBpZCA9IDExNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMjAuMi4yLjE3IE1hdGguaHlwb3QoW3ZhbHVlMVssIHZhbHVlMlssIOKApiBdXV0pXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgYWJzICAgICA9IE1hdGguYWJzO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGh5cG90OiBmdW5jdGlvbiBoeXBvdCh2YWx1ZTEsIHZhbHVlMil7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICB2YXIgc3VtICA9IDBcbiAgICAgICwgaSAgICA9IDBcbiAgICAgICwgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgICwgbGFyZyA9IDBcbiAgICAgICwgYXJnLCBkaXY7XG4gICAgd2hpbGUoaSA8IGFMZW4pe1xuICAgICAgYXJnID0gYWJzKGFyZ3VtZW50c1tpKytdKTtcbiAgICAgIGlmKGxhcmcgPCBhcmcpe1xuICAgICAgICBkaXYgID0gbGFyZyAvIGFyZztcbiAgICAgICAgc3VtICA9IHN1bSAqIGRpdiAqIGRpdiArIDE7XG4gICAgICAgIGxhcmcgPSBhcmc7XG4gICAgICB9IGVsc2UgaWYoYXJnID4gMCl7XG4gICAgICAgIGRpdiAgPSBhcmcgLyBsYXJnO1xuICAgICAgICBzdW0gKz0gZGl2ICogZGl2O1xuICAgICAgfSBlbHNlIHN1bSArPSBhcmc7XG4gICAgfVxuICAgIHJldHVybiBsYXJnID09PSBJbmZpbml0eSA/IEluZmluaXR5IDogbGFyZyAqIE1hdGguc3FydChzdW0pO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguaHlwb3QuanNcbiAqKiBtb2R1bGUgaWQgPSAxMTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDIwLjIuMi4xOCBNYXRoLmltdWwoeCwgeSlcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkaW11bCAgID0gTWF0aC5pbXVsO1xuXG4vLyBzb21lIFdlYktpdCB2ZXJzaW9ucyBmYWlscyB3aXRoIGJpZyBudW1iZXJzLCBzb21lIGhhcyB3cm9uZyBhcml0eVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHJldHVybiAkaW11bCgweGZmZmZmZmZmLCA1KSAhPSAtNSB8fCAkaW11bC5sZW5ndGggIT0gMjtcbn0pLCAnTWF0aCcsIHtcbiAgaW11bDogZnVuY3Rpb24gaW11bCh4LCB5KXtcbiAgICB2YXIgVUlOVDE2ID0gMHhmZmZmXG4gICAgICAsIHhuID0gK3hcbiAgICAgICwgeW4gPSAreVxuICAgICAgLCB4bCA9IFVJTlQxNiAmIHhuXG4gICAgICAsIHlsID0gVUlOVDE2ICYgeW47XG4gICAgcmV0dXJuIDAgfCB4bCAqIHlsICsgKChVSU5UMTYgJiB4biA+Pj4gMTYpICogeWwgKyB4bCAqIChVSU5UMTYgJiB5biA+Pj4gMTYpIDw8IDE2ID4+PiAwKTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmltdWwuanNcbiAqKiBtb2R1bGUgaWQgPSAxMTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDIwLjIuMi4yMSBNYXRoLmxvZzEwKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGxvZzEwOiBmdW5jdGlvbiBsb2cxMCh4KXtcbiAgICByZXR1cm4gTWF0aC5sb2coeCkgLyBNYXRoLkxOMTA7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5sb2cxMC5qc1xuICoqIG1vZHVsZSBpZCA9IDExN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMjAuMi4yLjIwIE1hdGgubG9nMXAoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtsb2cxcDogcmVxdWlyZSgnLi9fbWF0aC1sb2cxcCcpfSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmxvZzFwLmpzXG4gKiogbW9kdWxlIGlkID0gMTE4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAyMC4yLjIuMjIgTWF0aC5sb2cyKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGxvZzI6IGZ1bmN0aW9uIGxvZzIoeCl7XG4gICAgcmV0dXJuIE1hdGgubG9nKHgpIC8gTWF0aC5MTjI7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5sb2cyLmpzXG4gKiogbW9kdWxlIGlkID0gMTE5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAyMC4yLjIuMjggTWF0aC5zaWduKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7c2lnbjogcmVxdWlyZSgnLi9fbWF0aC1zaWduJyl9KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguc2lnbi5qc1xuICoqIG1vZHVsZSBpZCA9IDEyMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMjAuMi4yLjMwIE1hdGguc2luaCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGV4cG0xICAgPSByZXF1aXJlKCcuL19tYXRoLWV4cG0xJylcbiAgLCBleHAgICAgID0gTWF0aC5leHA7XG5cbi8vIFY4IG5lYXIgQ2hyb21pdW0gMzggaGFzIGEgcHJvYmxlbSB3aXRoIHZlcnkgc21hbGwgbnVtYmVyc1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHJldHVybiAhTWF0aC5zaW5oKC0yZS0xNykgIT0gLTJlLTE3O1xufSksICdNYXRoJywge1xuICBzaW5oOiBmdW5jdGlvbiBzaW5oKHgpe1xuICAgIHJldHVybiBNYXRoLmFicyh4ID0gK3gpIDwgMVxuICAgICAgPyAoZXhwbTEoeCkgLSBleHBtMSgteCkpIC8gMlxuICAgICAgOiAoZXhwKHggLSAxKSAtIGV4cCgteCAtIDEpKSAqIChNYXRoLkUgLyAyKTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLnNpbmguanNcbiAqKiBtb2R1bGUgaWQgPSAxMjFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDIwLjIuMi4zMyBNYXRoLnRhbmgoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBleHBtMSAgID0gcmVxdWlyZSgnLi9fbWF0aC1leHBtMScpXG4gICwgZXhwICAgICA9IE1hdGguZXhwO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIHRhbmg6IGZ1bmN0aW9uIHRhbmgoeCl7XG4gICAgdmFyIGEgPSBleHBtMSh4ID0gK3gpXG4gICAgICAsIGIgPSBleHBtMSgteCk7XG4gICAgcmV0dXJuIGEgPT0gSW5maW5pdHkgPyAxIDogYiA9PSBJbmZpbml0eSA/IC0xIDogKGEgLSBiKSAvIChleHAoeCkgKyBleHAoLXgpKTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLnRhbmguanNcbiAqKiBtb2R1bGUgaWQgPSAxMjJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDIwLjIuMi4zNCBNYXRoLnRydW5jKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIHRydW5jOiBmdW5jdGlvbiB0cnVuYyhpdCl7XG4gICAgcmV0dXJuIChpdCA+IDAgPyBNYXRoLmZsb29yIDogTWF0aC5jZWlsKShpdCk7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC50cnVuYy5qc1xuICoqIG1vZHVsZSBpZCA9IDEyM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyICRleHBvcnQgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCB0b0luZGV4ICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLWluZGV4JylcbiAgLCBmcm9tQ2hhckNvZGUgICA9IFN0cmluZy5mcm9tQ2hhckNvZGVcbiAgLCAkZnJvbUNvZGVQb2ludCA9IFN0cmluZy5mcm9tQ29kZVBvaW50O1xuXG4vLyBsZW5ndGggc2hvdWxkIGJlIDEsIG9sZCBGRiBwcm9ibGVtXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICghISRmcm9tQ29kZVBvaW50ICYmICRmcm9tQ29kZVBvaW50Lmxlbmd0aCAhPSAxKSwgJ1N0cmluZycsIHtcbiAgLy8gMjEuMS4yLjIgU3RyaW5nLmZyb21Db2RlUG9pbnQoLi4uY29kZVBvaW50cylcbiAgZnJvbUNvZGVQb2ludDogZnVuY3Rpb24gZnJvbUNvZGVQb2ludCh4KXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIHZhciByZXMgID0gW11cbiAgICAgICwgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgICwgaSAgICA9IDBcbiAgICAgICwgY29kZTtcbiAgICB3aGlsZShhTGVuID4gaSl7XG4gICAgICBjb2RlID0gK2FyZ3VtZW50c1tpKytdO1xuICAgICAgaWYodG9JbmRleChjb2RlLCAweDEwZmZmZikgIT09IGNvZGUpdGhyb3cgUmFuZ2VFcnJvcihjb2RlICsgJyBpcyBub3QgYSB2YWxpZCBjb2RlIHBvaW50Jyk7XG4gICAgICByZXMucHVzaChjb2RlIDwgMHgxMDAwMFxuICAgICAgICA/IGZyb21DaGFyQ29kZShjb2RlKVxuICAgICAgICA6IGZyb21DaGFyQ29kZSgoKGNvZGUgLT0gMHgxMDAwMCkgPj4gMTApICsgMHhkODAwLCBjb2RlICUgMHg0MDAgKyAweGRjMDApXG4gICAgICApO1xuICAgIH0gcmV0dXJuIHJlcy5qb2luKCcnKTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuZnJvbS1jb2RlLXBvaW50LmpzXG4gKiogbW9kdWxlIGlkID0gMTI0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgJGV4cG9ydCAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCB0b0xlbmd0aCAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdTdHJpbmcnLCB7XG4gIC8vIDIxLjEuMi40IFN0cmluZy5yYXcoY2FsbFNpdGUsIC4uLnN1YnN0aXR1dGlvbnMpXG4gIHJhdzogZnVuY3Rpb24gcmF3KGNhbGxTaXRlKXtcbiAgICB2YXIgdHBsICA9IHRvSU9iamVjdChjYWxsU2l0ZS5yYXcpXG4gICAgICAsIGxlbiAgPSB0b0xlbmd0aCh0cGwubGVuZ3RoKVxuICAgICAgLCBhTGVuID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgLCByZXMgID0gW11cbiAgICAgICwgaSAgICA9IDA7XG4gICAgd2hpbGUobGVuID4gaSl7XG4gICAgICByZXMucHVzaChTdHJpbmcodHBsW2krK10pKTtcbiAgICAgIGlmKGkgPCBhTGVuKXJlcy5wdXNoKFN0cmluZyhhcmd1bWVudHNbaV0pKTtcbiAgICB9IHJldHVybiByZXMuam9pbignJyk7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnJhdy5qc1xuICoqIG1vZHVsZSBpZCA9IDEyNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMjEuMS4zLjI1IFN0cmluZy5wcm90b3R5cGUudHJpbSgpXG5yZXF1aXJlKCcuL19zdHJpbmctdHJpbScpKCd0cmltJywgZnVuY3Rpb24oJHRyaW0pe1xuICByZXR1cm4gZnVuY3Rpb24gdHJpbSgpe1xuICAgIHJldHVybiAkdHJpbSh0aGlzLCAzKTtcbiAgfTtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnRyaW0uanNcbiAqKiBtb2R1bGUgaWQgPSAxMjZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciAkYXQgID0gcmVxdWlyZSgnLi9fc3RyaW5nLWF0JykodHJ1ZSk7XG5cbi8vIDIxLjEuMy4yNyBTdHJpbmcucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcbnJlcXVpcmUoJy4vX2l0ZXItZGVmaW5lJykoU3RyaW5nLCAnU3RyaW5nJywgZnVuY3Rpb24oaXRlcmF0ZWQpe1xuICB0aGlzLl90ID0gU3RyaW5nKGl0ZXJhdGVkKTsgLy8gdGFyZ2V0XG4gIHRoaXMuX2kgPSAwOyAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4vLyAyMS4xLjUuMi4xICVTdHJpbmdJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXG59LCBmdW5jdGlvbigpe1xuICB2YXIgTyAgICAgPSB0aGlzLl90XG4gICAgLCBpbmRleCA9IHRoaXMuX2lcbiAgICAsIHBvaW50O1xuICBpZihpbmRleCA+PSBPLmxlbmd0aClyZXR1cm4ge3ZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWV9O1xuICBwb2ludCA9ICRhdChPLCBpbmRleCk7XG4gIHRoaXMuX2kgKz0gcG9pbnQubGVuZ3RoO1xuICByZXR1cm4ge3ZhbHVlOiBwb2ludCwgZG9uZTogZmFsc2V9O1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3IuanNcbiAqKiBtb2R1bGUgaWQgPSAxMjdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJylcbiAgLCBkZWZpbmVkICAgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG4vLyB0cnVlICAtPiBTdHJpbmcjYXRcbi8vIGZhbHNlIC0+IFN0cmluZyNjb2RlUG9pbnRBdFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihUT19TVFJJTkcpe1xuICByZXR1cm4gZnVuY3Rpb24odGhhdCwgcG9zKXtcbiAgICB2YXIgcyA9IFN0cmluZyhkZWZpbmVkKHRoYXQpKVxuICAgICAgLCBpID0gdG9JbnRlZ2VyKHBvcylcbiAgICAgICwgbCA9IHMubGVuZ3RoXG4gICAgICAsIGEsIGI7XG4gICAgaWYoaSA8IDAgfHwgaSA+PSBsKXJldHVybiBUT19TVFJJTkcgPyAnJyA6IHVuZGVmaW5lZDtcbiAgICBhID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgIHJldHVybiBhIDwgMHhkODAwIHx8IGEgPiAweGRiZmYgfHwgaSArIDEgPT09IGwgfHwgKGIgPSBzLmNoYXJDb2RlQXQoaSArIDEpKSA8IDB4ZGMwMCB8fCBiID4gMHhkZmZmXG4gICAgICA/IFRPX1NUUklORyA/IHMuY2hhckF0KGkpIDogYVxuICAgICAgOiBUT19TVFJJTkcgPyBzLnNsaWNlKGksIGkgKyAyKSA6IChhIC0gMHhkODAwIDw8IDEwKSArIChiIC0gMHhkYzAwKSArIDB4MTAwMDA7XG4gIH07XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLWF0LmpzXG4gKiogbW9kdWxlIGlkID0gMTI4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgTElCUkFSWSAgICAgICAgPSByZXF1aXJlKCcuL19saWJyYXJ5JylcbiAgLCAkZXhwb3J0ICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgcmVkZWZpbmUgICAgICAgPSByZXF1aXJlKCcuL19yZWRlZmluZScpXG4gICwgaGlkZSAgICAgICAgICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgLCBoYXMgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgSXRlcmF0b3JzICAgICAgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKVxuICAsICRpdGVyQ3JlYXRlICAgID0gcmVxdWlyZSgnLi9faXRlci1jcmVhdGUnKVxuICAsIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKVxuICAsIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpXG4gICwgSVRFUkFUT1IgICAgICAgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKVxuICAsIEJVR0dZICAgICAgICAgID0gIShbXS5rZXlzICYmICduZXh0JyBpbiBbXS5rZXlzKCkpIC8vIFNhZmFyaSBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcbiAgLCBGRl9JVEVSQVRPUiAgICA9ICdAQGl0ZXJhdG9yJ1xuICAsIEtFWVMgICAgICAgICAgID0gJ2tleXMnXG4gICwgVkFMVUVTICAgICAgICAgPSAndmFsdWVzJztcblxudmFyIHJldHVyblRoaXMgPSBmdW5jdGlvbigpeyByZXR1cm4gdGhpczsgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihCYXNlLCBOQU1FLCBDb25zdHJ1Y3RvciwgbmV4dCwgREVGQVVMVCwgSVNfU0VULCBGT1JDRUQpe1xuICAkaXRlckNyZWF0ZShDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG4gIHZhciBnZXRNZXRob2QgPSBmdW5jdGlvbihraW5kKXtcbiAgICBpZighQlVHR1kgJiYga2luZCBpbiBwcm90bylyZXR1cm4gcHJvdG9ba2luZF07XG4gICAgc3dpdGNoKGtpbmQpe1xuICAgICAgY2FzZSBLRVlTOiByZXR1cm4gZnVuY3Rpb24ga2V5cygpeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgICAgY2FzZSBWQUxVRVM6IHJldHVybiBmdW5jdGlvbiB2YWx1ZXMoKXsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICB9IHJldHVybiBmdW5jdGlvbiBlbnRyaWVzKCl7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gIH07XG4gIHZhciBUQUcgICAgICAgID0gTkFNRSArICcgSXRlcmF0b3InXG4gICAgLCBERUZfVkFMVUVTID0gREVGQVVMVCA9PSBWQUxVRVNcbiAgICAsIFZBTFVFU19CVUcgPSBmYWxzZVxuICAgICwgcHJvdG8gICAgICA9IEJhc2UucHJvdG90eXBlXG4gICAgLCAkbmF0aXZlICAgID0gcHJvdG9bSVRFUkFUT1JdIHx8IHByb3RvW0ZGX0lURVJBVE9SXSB8fCBERUZBVUxUICYmIHByb3RvW0RFRkFVTFRdXG4gICAgLCAkZGVmYXVsdCAgID0gJG5hdGl2ZSB8fCBnZXRNZXRob2QoREVGQVVMVClcbiAgICAsICRlbnRyaWVzICAgPSBERUZBVUxUID8gIURFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZCgnZW50cmllcycpIDogdW5kZWZpbmVkXG4gICAgLCAkYW55TmF0aXZlID0gTkFNRSA9PSAnQXJyYXknID8gcHJvdG8uZW50cmllcyB8fCAkbmF0aXZlIDogJG5hdGl2ZVxuICAgICwgbWV0aG9kcywga2V5LCBJdGVyYXRvclByb3RvdHlwZTtcbiAgLy8gRml4IG5hdGl2ZVxuICBpZigkYW55TmF0aXZlKXtcbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKCRhbnlOYXRpdmUuY2FsbChuZXcgQmFzZSkpO1xuICAgIGlmKEl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlKXtcbiAgICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcbiAgICAgIHNldFRvU3RyaW5nVGFnKEl0ZXJhdG9yUHJvdG90eXBlLCBUQUcsIHRydWUpO1xuICAgICAgLy8gZml4IGZvciBzb21lIG9sZCBlbmdpbmVzXG4gICAgICBpZighTElCUkFSWSAmJiAhaGFzKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUikpaGlkZShJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IsIHJldHVyblRoaXMpO1xuICAgIH1cbiAgfVxuICAvLyBmaXggQXJyYXkje3ZhbHVlcywgQEBpdGVyYXRvcn0ubmFtZSBpbiBWOCAvIEZGXG4gIGlmKERFRl9WQUxVRVMgJiYgJG5hdGl2ZSAmJiAkbmF0aXZlLm5hbWUgIT09IFZBTFVFUyl7XG4gICAgVkFMVUVTX0JVRyA9IHRydWU7XG4gICAgJGRlZmF1bHQgPSBmdW5jdGlvbiB2YWx1ZXMoKXsgcmV0dXJuICRuYXRpdmUuY2FsbCh0aGlzKTsgfTtcbiAgfVxuICAvLyBEZWZpbmUgaXRlcmF0b3JcbiAgaWYoKCFMSUJSQVJZIHx8IEZPUkNFRCkgJiYgKEJVR0dZIHx8IFZBTFVFU19CVUcgfHwgIXByb3RvW0lURVJBVE9SXSkpe1xuICAgIGhpZGUocHJvdG8sIElURVJBVE9SLCAkZGVmYXVsdCk7XG4gIH1cbiAgLy8gUGx1ZyBmb3IgbGlicmFyeVxuICBJdGVyYXRvcnNbTkFNRV0gPSAkZGVmYXVsdDtcbiAgSXRlcmF0b3JzW1RBR10gID0gcmV0dXJuVGhpcztcbiAgaWYoREVGQVVMVCl7XG4gICAgbWV0aG9kcyA9IHtcbiAgICAgIHZhbHVlczogIERFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChWQUxVRVMpLFxuICAgICAga2V5czogICAgSVNfU0VUICAgICA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKEtFWVMpLFxuICAgICAgZW50cmllczogJGVudHJpZXNcbiAgICB9O1xuICAgIGlmKEZPUkNFRClmb3Ioa2V5IGluIG1ldGhvZHMpe1xuICAgICAgaWYoIShrZXkgaW4gcHJvdG8pKXJlZGVmaW5lKHByb3RvLCBrZXksIG1ldGhvZHNba2V5XSk7XG4gICAgfSBlbHNlICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKEJVR0dZIHx8IFZBTFVFU19CVUcpLCBOQU1FLCBtZXRob2RzKTtcbiAgfVxuICByZXR1cm4gbWV0aG9kcztcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19pdGVyLWRlZmluZS5qc1xuICoqIG1vZHVsZSBpZCA9IDEyOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2l0ZXJhdG9ycy5qc1xuICoqIG1vZHVsZSBpZCA9IDEzMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGNyZWF0ZSAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpXG4gICwgZGVzY3JpcHRvciAgICAgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJylcbiAgLCBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJylcbiAgLCBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuXG4vLyAyNS4xLjIuMS4xICVJdGVyYXRvclByb3RvdHlwZSVbQEBpdGVyYXRvcl0oKVxucmVxdWlyZSgnLi9faGlkZScpKEl0ZXJhdG9yUHJvdG90eXBlLCByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKSwgZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXM7IH0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KXtcbiAgQ29uc3RydWN0b3IucHJvdG90eXBlID0gY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlLCB7bmV4dDogZGVzY3JpcHRvcigxLCBuZXh0KX0pO1xuICBzZXRUb1N0cmluZ1RhZyhDb25zdHJ1Y3RvciwgTkFNRSArICcgSXRlcmF0b3InKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19pdGVyLWNyZWF0ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDEzMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRhdCAgICAgPSByZXF1aXJlKCcuL19zdHJpbmctYXQnKShmYWxzZSk7XG4kZXhwb3J0KCRleHBvcnQuUCwgJ1N0cmluZycsIHtcbiAgLy8gMjEuMS4zLjMgU3RyaW5nLnByb3RvdHlwZS5jb2RlUG9pbnRBdChwb3MpXG4gIGNvZGVQb2ludEF0OiBmdW5jdGlvbiBjb2RlUG9pbnRBdChwb3Mpe1xuICAgIHJldHVybiAkYXQodGhpcywgcG9zKTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuY29kZS1wb2ludC1hdC5qc1xuICoqIG1vZHVsZSBpZCA9IDEzMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMjEuMS4zLjYgU3RyaW5nLnByb3RvdHlwZS5lbmRzV2l0aChzZWFyY2hTdHJpbmcgWywgZW5kUG9zaXRpb25dKVxuJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgdG9MZW5ndGggID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCBjb250ZXh0ICAgPSByZXF1aXJlKCcuL19zdHJpbmctY29udGV4dCcpXG4gICwgRU5EU19XSVRIID0gJ2VuZHNXaXRoJ1xuICAsICRlbmRzV2l0aCA9ICcnW0VORFNfV0lUSF07XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMtaXMtcmVnZXhwJykoRU5EU19XSVRIKSwgJ1N0cmluZycsIHtcbiAgZW5kc1dpdGg6IGZ1bmN0aW9uIGVuZHNXaXRoKHNlYXJjaFN0cmluZyAvKiwgZW5kUG9zaXRpb24gPSBAbGVuZ3RoICovKXtcbiAgICB2YXIgdGhhdCA9IGNvbnRleHQodGhpcywgc2VhcmNoU3RyaW5nLCBFTkRTX1dJVEgpXG4gICAgICAsIGVuZFBvc2l0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWRcbiAgICAgICwgbGVuICAgID0gdG9MZW5ndGgodGhhdC5sZW5ndGgpXG4gICAgICAsIGVuZCAgICA9IGVuZFBvc2l0aW9uID09PSB1bmRlZmluZWQgPyBsZW4gOiBNYXRoLm1pbih0b0xlbmd0aChlbmRQb3NpdGlvbiksIGxlbilcbiAgICAgICwgc2VhcmNoID0gU3RyaW5nKHNlYXJjaFN0cmluZyk7XG4gICAgcmV0dXJuICRlbmRzV2l0aFxuICAgICAgPyAkZW5kc1dpdGguY2FsbCh0aGF0LCBzZWFyY2gsIGVuZClcbiAgICAgIDogdGhhdC5zbGljZShlbmQgLSBzZWFyY2gubGVuZ3RoLCBlbmQpID09PSBzZWFyY2g7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmVuZHMtd2l0aC5qc1xuICoqIG1vZHVsZSBpZCA9IDEzM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gaGVscGVyIGZvciBTdHJpbmcje3N0YXJ0c1dpdGgsIGVuZHNXaXRoLCBpbmNsdWRlc31cbnZhciBpc1JlZ0V4cCA9IHJlcXVpcmUoJy4vX2lzLXJlZ2V4cCcpXG4gICwgZGVmaW5lZCAgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odGhhdCwgc2VhcmNoU3RyaW5nLCBOQU1FKXtcbiAgaWYoaXNSZWdFeHAoc2VhcmNoU3RyaW5nKSl0aHJvdyBUeXBlRXJyb3IoJ1N0cmluZyMnICsgTkFNRSArIFwiIGRvZXNuJ3QgYWNjZXB0IHJlZ2V4IVwiKTtcbiAgcmV0dXJuIFN0cmluZyhkZWZpbmVkKHRoYXQpKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19zdHJpbmctY29udGV4dC5qc1xuICoqIG1vZHVsZSBpZCA9IDEzNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gNy4yLjggSXNSZWdFeHAoYXJndW1lbnQpXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGNvZiAgICAgID0gcmVxdWlyZSgnLi9fY29mJylcbiAgLCBNQVRDSCAgICA9IHJlcXVpcmUoJy4vX3drcycpKCdtYXRjaCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHZhciBpc1JlZ0V4cDtcbiAgcmV0dXJuIGlzT2JqZWN0KGl0KSAmJiAoKGlzUmVnRXhwID0gaXRbTUFUQ0hdKSAhPT0gdW5kZWZpbmVkID8gISFpc1JlZ0V4cCA6IGNvZihpdCkgPT0gJ1JlZ0V4cCcpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2lzLXJlZ2V4cC5qc1xuICoqIG1vZHVsZSBpZCA9IDEzNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIE1BVENIID0gcmVxdWlyZSgnLi9fd2tzJykoJ21hdGNoJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKEtFWSl7XG4gIHZhciByZSA9IC8uLztcbiAgdHJ5IHtcbiAgICAnLy4vJ1tLRVldKHJlKTtcbiAgfSBjYXRjaChlKXtcbiAgICB0cnkge1xuICAgICAgcmVbTUFUQ0hdID0gZmFsc2U7XG4gICAgICByZXR1cm4gIScvLi8nW0tFWV0ocmUpO1xuICAgIH0gY2F0Y2goZil7IC8qIGVtcHR5ICovIH1cbiAgfSByZXR1cm4gdHJ1ZTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19mYWlscy1pcy1yZWdleHAuanNcbiAqKiBtb2R1bGUgaWQgPSAxMzZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDIxLjEuMy43IFN0cmluZy5wcm90b3R5cGUuaW5jbHVkZXMoc2VhcmNoU3RyaW5nLCBwb3NpdGlvbiA9IDApXG4ndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGNvbnRleHQgID0gcmVxdWlyZSgnLi9fc3RyaW5nLWNvbnRleHQnKVxuICAsIElOQ0xVREVTID0gJ2luY2x1ZGVzJztcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscy1pcy1yZWdleHAnKShJTkNMVURFUyksICdTdHJpbmcnLCB7XG4gIGluY2x1ZGVzOiBmdW5jdGlvbiBpbmNsdWRlcyhzZWFyY2hTdHJpbmcgLyosIHBvc2l0aW9uID0gMCAqLyl7XG4gICAgcmV0dXJuICEhfmNvbnRleHQodGhpcywgc2VhcmNoU3RyaW5nLCBJTkNMVURFUylcbiAgICAgIC5pbmRleE9mKHNlYXJjaFN0cmluZywgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5pbmNsdWRlcy5qc1xuICoqIG1vZHVsZSBpZCA9IDEzN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdTdHJpbmcnLCB7XG4gIC8vIDIxLjEuMy4xMyBTdHJpbmcucHJvdG90eXBlLnJlcGVhdChjb3VudClcbiAgcmVwZWF0OiByZXF1aXJlKCcuL19zdHJpbmctcmVwZWF0Jylcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnJlcGVhdC5qc1xuICoqIG1vZHVsZSBpZCA9IDEzOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMjEuMS4zLjE4IFN0cmluZy5wcm90b3R5cGUuc3RhcnRzV2l0aChzZWFyY2hTdHJpbmcgWywgcG9zaXRpb24gXSlcbid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgdG9MZW5ndGggICAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKVxuICAsIGNvbnRleHQgICAgID0gcmVxdWlyZSgnLi9fc3RyaW5nLWNvbnRleHQnKVxuICAsIFNUQVJUU19XSVRIID0gJ3N0YXJ0c1dpdGgnXG4gICwgJHN0YXJ0c1dpdGggPSAnJ1tTVEFSVFNfV0lUSF07XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMtaXMtcmVnZXhwJykoU1RBUlRTX1dJVEgpLCAnU3RyaW5nJywge1xuICBzdGFydHNXaXRoOiBmdW5jdGlvbiBzdGFydHNXaXRoKHNlYXJjaFN0cmluZyAvKiwgcG9zaXRpb24gPSAwICovKXtcbiAgICB2YXIgdGhhdCAgID0gY29udGV4dCh0aGlzLCBzZWFyY2hTdHJpbmcsIFNUQVJUU19XSVRIKVxuICAgICAgLCBpbmRleCAgPSB0b0xlbmd0aChNYXRoLm1pbihhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgdGhhdC5sZW5ndGgpKVxuICAgICAgLCBzZWFyY2ggPSBTdHJpbmcoc2VhcmNoU3RyaW5nKTtcbiAgICByZXR1cm4gJHN0YXJ0c1dpdGhcbiAgICAgID8gJHN0YXJ0c1dpdGguY2FsbCh0aGF0LCBzZWFyY2gsIGluZGV4KVxuICAgICAgOiB0aGF0LnNsaWNlKGluZGV4LCBpbmRleCArIHNlYXJjaC5sZW5ndGgpID09PSBzZWFyY2g7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnN0YXJ0cy13aXRoLmpzXG4gKiogbW9kdWxlIGlkID0gMTM5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy4yIFN0cmluZy5wcm90b3R5cGUuYW5jaG9yKG5hbWUpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdhbmNob3InLCBmdW5jdGlvbihjcmVhdGVIVE1MKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGFuY2hvcihuYW1lKXtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnYScsICduYW1lJywgbmFtZSk7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmFuY2hvci5qc1xuICoqIG1vZHVsZSBpZCA9IDE0MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGZhaWxzICAgPSByZXF1aXJlKCcuL19mYWlscycpXG4gICwgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKVxuICAsIHF1b3QgICAgPSAvXCIvZztcbi8vIEIuMi4zLjIuMSBDcmVhdGVIVE1MKHN0cmluZywgdGFnLCBhdHRyaWJ1dGUsIHZhbHVlKVxudmFyIGNyZWF0ZUhUTUwgPSBmdW5jdGlvbihzdHJpbmcsIHRhZywgYXR0cmlidXRlLCB2YWx1ZSkge1xuICB2YXIgUyAgPSBTdHJpbmcoZGVmaW5lZChzdHJpbmcpKVxuICAgICwgcDEgPSAnPCcgKyB0YWc7XG4gIGlmKGF0dHJpYnV0ZSAhPT0gJycpcDEgKz0gJyAnICsgYXR0cmlidXRlICsgJz1cIicgKyBTdHJpbmcodmFsdWUpLnJlcGxhY2UocXVvdCwgJyZxdW90OycpICsgJ1wiJztcbiAgcmV0dXJuIHAxICsgJz4nICsgUyArICc8LycgKyB0YWcgKyAnPic7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihOQU1FLCBleGVjKXtcbiAgdmFyIE8gPSB7fTtcbiAgT1tOQU1FXSA9IGV4ZWMoY3JlYXRlSFRNTCk7XG4gICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogZmFpbHMoZnVuY3Rpb24oKXtcbiAgICB2YXIgdGVzdCA9ICcnW05BTUVdKCdcIicpO1xuICAgIHJldHVybiB0ZXN0ICE9PSB0ZXN0LnRvTG93ZXJDYXNlKCkgfHwgdGVzdC5zcGxpdCgnXCInKS5sZW5ndGggPiAzO1xuICB9KSwgJ1N0cmluZycsIE8pO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1odG1sLmpzXG4gKiogbW9kdWxlIGlkID0gMTQxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy4zIFN0cmluZy5wcm90b3R5cGUuYmlnKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2JpZycsIGZ1bmN0aW9uKGNyZWF0ZUhUTUwpe1xuICByZXR1cm4gZnVuY3Rpb24gYmlnKCl7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ2JpZycsICcnLCAnJyk7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmJpZy5qc1xuICoqIG1vZHVsZSBpZCA9IDE0MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuNCBTdHJpbmcucHJvdG90eXBlLmJsaW5rKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2JsaW5rJywgZnVuY3Rpb24oY3JlYXRlSFRNTCl7XG4gIHJldHVybiBmdW5jdGlvbiBibGluaygpe1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdibGluaycsICcnLCAnJyk7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmJsaW5rLmpzXG4gKiogbW9kdWxlIGlkID0gMTQzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy41IFN0cmluZy5wcm90b3R5cGUuYm9sZCgpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdib2xkJywgZnVuY3Rpb24oY3JlYXRlSFRNTCl7XG4gIHJldHVybiBmdW5jdGlvbiBib2xkKCl7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ2InLCAnJywgJycpO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5ib2xkLmpzXG4gKiogbW9kdWxlIGlkID0gMTQ0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy42IFN0cmluZy5wcm90b3R5cGUuZml4ZWQoKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnZml4ZWQnLCBmdW5jdGlvbihjcmVhdGVIVE1MKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGZpeGVkKCl7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ3R0JywgJycsICcnKTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuZml4ZWQuanNcbiAqKiBtb2R1bGUgaWQgPSAxNDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjcgU3RyaW5nLnByb3RvdHlwZS5mb250Y29sb3IoY29sb3IpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdmb250Y29sb3InLCBmdW5jdGlvbihjcmVhdGVIVE1MKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGZvbnRjb2xvcihjb2xvcil7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ2ZvbnQnLCAnY29sb3InLCBjb2xvcik7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmZvbnRjb2xvci5qc1xuICoqIG1vZHVsZSBpZCA9IDE0NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuOCBTdHJpbmcucHJvdG90eXBlLmZvbnRzaXplKHNpemUpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdmb250c2l6ZScsIGZ1bmN0aW9uKGNyZWF0ZUhUTUwpe1xuICByZXR1cm4gZnVuY3Rpb24gZm9udHNpemUoc2l6ZSl7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ2ZvbnQnLCAnc2l6ZScsIHNpemUpO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5mb250c2l6ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDE0N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuOSBTdHJpbmcucHJvdG90eXBlLml0YWxpY3MoKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnaXRhbGljcycsIGZ1bmN0aW9uKGNyZWF0ZUhUTUwpe1xuICByZXR1cm4gZnVuY3Rpb24gaXRhbGljcygpe1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdpJywgJycsICcnKTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuaXRhbGljcy5qc1xuICoqIG1vZHVsZSBpZCA9IDE0OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuMTAgU3RyaW5nLnByb3RvdHlwZS5saW5rKHVybClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2xpbmsnLCBmdW5jdGlvbihjcmVhdGVIVE1MKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGxpbmsodXJsKXtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnYScsICdocmVmJywgdXJsKTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcubGluay5qc1xuICoqIG1vZHVsZSBpZCA9IDE0OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuMTEgU3RyaW5nLnByb3RvdHlwZS5zbWFsbCgpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdzbWFsbCcsIGZ1bmN0aW9uKGNyZWF0ZUhUTUwpe1xuICByZXR1cm4gZnVuY3Rpb24gc21hbGwoKXtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnc21hbGwnLCAnJywgJycpO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5zbWFsbC5qc1xuICoqIG1vZHVsZSBpZCA9IDE1MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuMTIgU3RyaW5nLnByb3RvdHlwZS5zdHJpa2UoKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnc3RyaWtlJywgZnVuY3Rpb24oY3JlYXRlSFRNTCl7XG4gIHJldHVybiBmdW5jdGlvbiBzdHJpa2UoKXtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnc3RyaWtlJywgJycsICcnKTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuc3RyaWtlLmpzXG4gKiogbW9kdWxlIGlkID0gMTUxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy4xMyBTdHJpbmcucHJvdG90eXBlLnN1YigpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdzdWInLCBmdW5jdGlvbihjcmVhdGVIVE1MKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIHN1Yigpe1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdzdWInLCAnJywgJycpO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5zdWIuanNcbiAqKiBtb2R1bGUgaWQgPSAxNTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjE0IFN0cmluZy5wcm90b3R5cGUuc3VwKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ3N1cCcsIGZ1bmN0aW9uKGNyZWF0ZUhUTUwpe1xuICByZXR1cm4gZnVuY3Rpb24gc3VwKCl7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ3N1cCcsICcnLCAnJyk7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnN1cC5qc1xuICoqIG1vZHVsZSBpZCA9IDE1M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMjAuMy4zLjEgLyAxNS45LjQuNCBEYXRlLm5vdygpXHJcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XHJcblxyXG4kZXhwb3J0KCRleHBvcnQuUywgJ0RhdGUnLCB7bm93OiBmdW5jdGlvbigpeyByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7IH19KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmRhdGUubm93LmpzXG4gKiogbW9kdWxlIGlkID0gMTU0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHRvT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIG5ldyBEYXRlKE5hTikudG9KU09OKCkgIT09IG51bGwgfHwgRGF0ZS5wcm90b3R5cGUudG9KU09OLmNhbGwoe3RvSVNPU3RyaW5nOiBmdW5jdGlvbigpeyByZXR1cm4gMTsgfX0pICE9PSAxO1xufSksICdEYXRlJywge1xuICB0b0pTT046IGZ1bmN0aW9uIHRvSlNPTihrZXkpe1xuICAgIHZhciBPICA9IHRvT2JqZWN0KHRoaXMpXG4gICAgICAsIHB2ID0gdG9QcmltaXRpdmUoTyk7XG4gICAgcmV0dXJuIHR5cGVvZiBwdiA9PSAnbnVtYmVyJyAmJiAhaXNGaW5pdGUocHYpID8gbnVsbCA6IE8udG9JU09TdHJpbmcoKTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5kYXRlLnRvLWpzb24uanNcbiAqKiBtb2R1bGUgaWQgPSAxNTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxuLy8gMjAuMy40LjM2IC8gMTUuOS41LjQzIERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nKClcclxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxyXG4gICwgZmFpbHMgICA9IHJlcXVpcmUoJy4vX2ZhaWxzJylcclxuICAsIGdldFRpbWUgPSBEYXRlLnByb3RvdHlwZS5nZXRUaW1lO1xyXG5cclxudmFyIGx6ID0gZnVuY3Rpb24obnVtKXtcclxuICByZXR1cm4gbnVtID4gOSA/IG51bSA6ICcwJyArIG51bTtcclxufTtcclxuXHJcbi8vIFBoYW50b21KUyAvIG9sZCBXZWJLaXQgaGFzIGEgYnJva2VuIGltcGxlbWVudGF0aW9uc1xyXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChmYWlscyhmdW5jdGlvbigpe1xyXG4gIHJldHVybiBuZXcgRGF0ZSgtNWUxMyAtIDEpLnRvSVNPU3RyaW5nKCkgIT0gJzAzODUtMDctMjVUMDc6MDY6MzkuOTk5Wic7XHJcbn0pIHx8ICFmYWlscyhmdW5jdGlvbigpe1xyXG4gIG5ldyBEYXRlKE5hTikudG9JU09TdHJpbmcoKTtcclxufSkpLCAnRGF0ZScsIHtcclxuICB0b0lTT1N0cmluZzogZnVuY3Rpb24gdG9JU09TdHJpbmcoKXtcclxuICAgIGlmKCFpc0Zpbml0ZShnZXRUaW1lLmNhbGwodGhpcykpKXRocm93IFJhbmdlRXJyb3IoJ0ludmFsaWQgdGltZSB2YWx1ZScpO1xyXG4gICAgdmFyIGQgPSB0aGlzXHJcbiAgICAgICwgeSA9IGQuZ2V0VVRDRnVsbFllYXIoKVxyXG4gICAgICAsIG0gPSBkLmdldFVUQ01pbGxpc2Vjb25kcygpXHJcbiAgICAgICwgcyA9IHkgPCAwID8gJy0nIDogeSA+IDk5OTkgPyAnKycgOiAnJztcclxuICAgIHJldHVybiBzICsgKCcwMDAwMCcgKyBNYXRoLmFicyh5KSkuc2xpY2UocyA/IC02IDogLTQpICtcclxuICAgICAgJy0nICsgbHooZC5nZXRVVENNb250aCgpICsgMSkgKyAnLScgKyBseihkLmdldFVUQ0RhdGUoKSkgK1xyXG4gICAgICAnVCcgKyBseihkLmdldFVUQ0hvdXJzKCkpICsgJzonICsgbHooZC5nZXRVVENNaW51dGVzKCkpICtcclxuICAgICAgJzonICsgbHooZC5nZXRVVENTZWNvbmRzKCkpICsgJy4nICsgKG0gPiA5OSA/IG0gOiAnMCcgKyBseihtKSkgKyAnWic7XHJcbiAgfVxyXG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmRhdGUudG8taXNvLXN0cmluZy5qc1xuICoqIG1vZHVsZSBpZCA9IDE1NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIERhdGVQcm90byAgICA9IERhdGUucHJvdG90eXBlXG4gICwgSU5WQUxJRF9EQVRFID0gJ0ludmFsaWQgRGF0ZSdcbiAgLCBUT19TVFJJTkcgICAgPSAndG9TdHJpbmcnXG4gICwgJHRvU3RyaW5nICAgID0gRGF0ZVByb3RvW1RPX1NUUklOR11cbiAgLCBnZXRUaW1lICAgICAgPSBEYXRlUHJvdG8uZ2V0VGltZTtcbmlmKG5ldyBEYXRlKE5hTikgKyAnJyAhPSBJTlZBTElEX0RBVEUpe1xuICByZXF1aXJlKCcuL19yZWRlZmluZScpKERhdGVQcm90bywgVE9fU1RSSU5HLCBmdW5jdGlvbiB0b1N0cmluZygpe1xuICAgIHZhciB2YWx1ZSA9IGdldFRpbWUuY2FsbCh0aGlzKTtcbiAgICByZXR1cm4gdmFsdWUgPT09IHZhbHVlID8gJHRvU3RyaW5nLmNhbGwodGhpcykgOiBJTlZBTElEX0RBVEU7XG4gIH0pO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuZGF0ZS50by1zdHJpbmcuanNcbiAqKiBtb2R1bGUgaWQgPSAxNTdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBUT19QUklNSVRJVkUgPSByZXF1aXJlKCcuL193a3MnKSgndG9QcmltaXRpdmUnKVxyXG4gICwgcHJvdG8gICAgICAgID0gRGF0ZS5wcm90b3R5cGU7XHJcblxyXG5pZighKFRPX1BSSU1JVElWRSBpbiBwcm90bykpcmVxdWlyZSgnLi9faGlkZScpKHByb3RvLCBUT19QUklNSVRJVkUsIHJlcXVpcmUoJy4vX2RhdGUtdG8tcHJpbWl0aXZlJykpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuZGF0ZS50by1wcmltaXRpdmUuanNcbiAqKiBtb2R1bGUgaWQgPSAxNThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxudmFyIGFuT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcclxuICAsIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJylcclxuICAsIE5VTUJFUiAgICAgID0gJ251bWJlcic7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGhpbnQpe1xyXG4gIGlmKGhpbnQgIT09ICdzdHJpbmcnICYmIGhpbnQgIT09IE5VTUJFUiAmJiBoaW50ICE9PSAnZGVmYXVsdCcpdGhyb3cgVHlwZUVycm9yKCdJbmNvcnJlY3QgaGludCcpO1xyXG4gIHJldHVybiB0b1ByaW1pdGl2ZShhbk9iamVjdCh0aGlzKSwgaGludCAhPSBOVU1CRVIpO1xyXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fZGF0ZS10by1wcmltaXRpdmUuanNcbiAqKiBtb2R1bGUgaWQgPSAxNTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDIyLjEuMi4yIC8gMTUuNC4zLjIgQXJyYXkuaXNBcnJheShhcmcpXHJcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XHJcblxyXG4kZXhwb3J0KCRleHBvcnQuUywgJ0FycmF5Jywge2lzQXJyYXk6IHJlcXVpcmUoJy4vX2lzLWFycmF5Jyl9KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmlzLWFycmF5LmpzXG4gKiogbW9kdWxlIGlkID0gMTYwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgY3R4ICAgICAgICAgICAgPSByZXF1aXJlKCcuL19jdHgnKVxuICAsICRleHBvcnQgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCB0b09iamVjdCAgICAgICA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgY2FsbCAgICAgICAgICAgPSByZXF1aXJlKCcuL19pdGVyLWNhbGwnKVxuICAsIGlzQXJyYXlJdGVyICAgID0gcmVxdWlyZSgnLi9faXMtYXJyYXktaXRlcicpXG4gICwgdG9MZW5ndGggICAgICAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKVxuICAsIGNyZWF0ZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fY3JlYXRlLXByb3BlcnR5JylcbiAgLCBnZXRJdGVyRm4gICAgICA9IHJlcXVpcmUoJy4vY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX2l0ZXItZGV0ZWN0JykoZnVuY3Rpb24oaXRlcil7IEFycmF5LmZyb20oaXRlcik7IH0pLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMi4xIEFycmF5LmZyb20oYXJyYXlMaWtlLCBtYXBmbiA9IHVuZGVmaW5lZCwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbiAgZnJvbTogZnVuY3Rpb24gZnJvbShhcnJheUxpa2UvKiwgbWFwZm4gPSB1bmRlZmluZWQsIHRoaXNBcmcgPSB1bmRlZmluZWQqLyl7XG4gICAgdmFyIE8gICAgICAgPSB0b09iamVjdChhcnJheUxpa2UpXG4gICAgICAsIEMgICAgICAgPSB0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nID8gdGhpcyA6IEFycmF5XG4gICAgICAsIGFMZW4gICAgPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgICAsIG1hcGZuICAgPSBhTGVuID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZFxuICAgICAgLCBtYXBwaW5nID0gbWFwZm4gIT09IHVuZGVmaW5lZFxuICAgICAgLCBpbmRleCAgID0gMFxuICAgICAgLCBpdGVyRm4gID0gZ2V0SXRlckZuKE8pXG4gICAgICAsIGxlbmd0aCwgcmVzdWx0LCBzdGVwLCBpdGVyYXRvcjtcbiAgICBpZihtYXBwaW5nKW1hcGZuID0gY3R4KG1hcGZuLCBhTGVuID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZCwgMik7XG4gICAgLy8gaWYgb2JqZWN0IGlzbid0IGl0ZXJhYmxlIG9yIGl0J3MgYXJyYXkgd2l0aCBkZWZhdWx0IGl0ZXJhdG9yIC0gdXNlIHNpbXBsZSBjYXNlXG4gICAgaWYoaXRlckZuICE9IHVuZGVmaW5lZCAmJiAhKEMgPT0gQXJyYXkgJiYgaXNBcnJheUl0ZXIoaXRlckZuKSkpe1xuICAgICAgZm9yKGl0ZXJhdG9yID0gaXRlckZuLmNhbGwoTyksIHJlc3VsdCA9IG5ldyBDOyAhKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmU7IGluZGV4Kyspe1xuICAgICAgICBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGluZGV4LCBtYXBwaW5nID8gY2FsbChpdGVyYXRvciwgbWFwZm4sIFtzdGVwLnZhbHVlLCBpbmRleF0sIHRydWUpIDogc3RlcC52YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICAgIGZvcihyZXN1bHQgPSBuZXcgQyhsZW5ndGgpOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKyl7XG4gICAgICAgIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgaW5kZXgsIG1hcHBpbmcgPyBtYXBmbihPW2luZGV4XSwgaW5kZXgpIDogT1tpbmRleF0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQubGVuZ3RoID0gaW5kZXg7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZyb20uanNcbiAqKiBtb2R1bGUgaWQgPSAxNjFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIGNhbGwgc29tZXRoaW5nIG9uIGl0ZXJhdG9yIHN0ZXAgd2l0aCBzYWZlIGNsb3Npbmcgb24gZXJyb3JcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdGVyYXRvciwgZm4sIHZhbHVlLCBlbnRyaWVzKXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZW50cmllcyA/IGZuKGFuT2JqZWN0KHZhbHVlKVswXSwgdmFsdWVbMV0pIDogZm4odmFsdWUpO1xuICAvLyA3LjQuNiBJdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCBjb21wbGV0aW9uKVxuICB9IGNhdGNoKGUpe1xuICAgIHZhciByZXQgPSBpdGVyYXRvclsncmV0dXJuJ107XG4gICAgaWYocmV0ICE9PSB1bmRlZmluZWQpYW5PYmplY3QocmV0LmNhbGwoaXRlcmF0b3IpKTtcbiAgICB0aHJvdyBlO1xuICB9XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9faXRlci1jYWxsLmpzXG4gKiogbW9kdWxlIGlkID0gMTYyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBjaGVjayBvbiBkZWZhdWx0IEFycmF5IGl0ZXJhdG9yXG52YXIgSXRlcmF0b3JzICA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpXG4gICwgSVRFUkFUT1IgICA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpXG4gICwgQXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpdCAhPT0gdW5kZWZpbmVkICYmIChJdGVyYXRvcnMuQXJyYXkgPT09IGl0IHx8IEFycmF5UHJvdG9bSVRFUkFUT1JdID09PSBpdCk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9faXMtYXJyYXktaXRlci5qc1xuICoqIG1vZHVsZSBpZCA9IDE2M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIgJGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJylcclxuICAsIGNyZWF0ZURlc2MgICAgICA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqZWN0LCBpbmRleCwgdmFsdWUpe1xyXG4gIGlmKGluZGV4IGluIG9iamVjdCkkZGVmaW5lUHJvcGVydHkuZihvYmplY3QsIGluZGV4LCBjcmVhdGVEZXNjKDAsIHZhbHVlKSk7XHJcbiAgZWxzZSBvYmplY3RbaW5kZXhdID0gdmFsdWU7XHJcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19jcmVhdGUtcHJvcGVydHkuanNcbiAqKiBtb2R1bGUgaWQgPSAxNjRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBjbGFzc29mICAgPSByZXF1aXJlKCcuL19jbGFzc29mJylcbiAgLCBJVEVSQVRPUiAgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKVxuICAsIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb3JlJykuZ2V0SXRlcmF0b3JNZXRob2QgPSBmdW5jdGlvbihpdCl7XG4gIGlmKGl0ICE9IHVuZGVmaW5lZClyZXR1cm4gaXRbSVRFUkFUT1JdXG4gICAgfHwgaXRbJ0BAaXRlcmF0b3InXVxuICAgIHx8IEl0ZXJhdG9yc1tjbGFzc29mKGl0KV07XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QuanNcbiAqKiBtb2R1bGUgaWQgPSAxNjVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBJVEVSQVRPUiAgICAgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKVxuICAsIFNBRkVfQ0xPU0lORyA9IGZhbHNlO1xuXG50cnkge1xuICB2YXIgcml0ZXIgPSBbN11bSVRFUkFUT1JdKCk7XG4gIHJpdGVyWydyZXR1cm4nXSA9IGZ1bmN0aW9uKCl7IFNBRkVfQ0xPU0lORyA9IHRydWU7IH07XG4gIEFycmF5LmZyb20ocml0ZXIsIGZ1bmN0aW9uKCl7IHRocm93IDI7IH0pO1xufSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGV4ZWMsIHNraXBDbG9zaW5nKXtcbiAgaWYoIXNraXBDbG9zaW5nICYmICFTQUZFX0NMT1NJTkcpcmV0dXJuIGZhbHNlO1xuICB2YXIgc2FmZSA9IGZhbHNlO1xuICB0cnkge1xuICAgIHZhciBhcnIgID0gWzddXG4gICAgICAsIGl0ZXIgPSBhcnJbSVRFUkFUT1JdKCk7XG4gICAgaXRlci5uZXh0ID0gZnVuY3Rpb24oKXsgcmV0dXJuIHtkb25lOiBzYWZlID0gdHJ1ZX07IH07XG4gICAgYXJyW0lURVJBVE9SXSA9IGZ1bmN0aW9uKCl7IHJldHVybiBpdGVyOyB9O1xuICAgIGV4ZWMoYXJyKTtcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuICByZXR1cm4gc2FmZTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19pdGVyLWRldGVjdC5qc1xuICoqIG1vZHVsZSBpZCA9IDE2NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBjcmVhdGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2NyZWF0ZS1wcm9wZXJ0eScpO1xuXG4vLyBXZWJLaXQgQXJyYXkub2YgaXNuJ3QgZ2VuZXJpY1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIGZ1bmN0aW9uIEYoKXt9XG4gIHJldHVybiAhKEFycmF5Lm9mLmNhbGwoRikgaW5zdGFuY2VvZiBGKTtcbn0pLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMi4zIEFycmF5Lm9mKCAuLi5pdGVtcylcbiAgb2Y6IGZ1bmN0aW9uIG9mKC8qIC4uLmFyZ3MgKi8pe1xuICAgIHZhciBpbmRleCAgPSAwXG4gICAgICAsIGFMZW4gICA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgICwgcmVzdWx0ID0gbmV3ICh0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nID8gdGhpcyA6IEFycmF5KShhTGVuKTtcbiAgICB3aGlsZShhTGVuID4gaW5kZXgpY3JlYXRlUHJvcGVydHkocmVzdWx0LCBpbmRleCwgYXJndW1lbnRzW2luZGV4KytdKTtcbiAgICByZXN1bHQubGVuZ3RoID0gYUxlbjtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lm9mLmpzXG4gKiogbW9kdWxlIGlkID0gMTY3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbi8vIDIyLjEuMy4xMyBBcnJheS5wcm90b3R5cGUuam9pbihzZXBhcmF0b3IpXHJcbnZhciAkZXhwb3J0ICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxyXG4gICwgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXHJcbiAgLCBhcnJheUpvaW4gPSBbXS5qb2luO1xyXG5cclxuLy8gZmFsbGJhY2sgZm9yIG5vdCBhcnJheS1saWtlIHN0cmluZ3NcclxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAocmVxdWlyZSgnLi9faW9iamVjdCcpICE9IE9iamVjdCB8fCAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKGFycmF5Sm9pbikpLCAnQXJyYXknLCB7XHJcbiAgam9pbjogZnVuY3Rpb24gam9pbihzZXBhcmF0b3Ipe1xyXG4gICAgcmV0dXJuIGFycmF5Sm9pbi5jYWxsKHRvSU9iamVjdCh0aGlzKSwgc2VwYXJhdG9yID09PSB1bmRlZmluZWQgPyAnLCcgOiBzZXBhcmF0b3IpO1xyXG4gIH1cclxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5qb2luLmpzXG4gKiogbW9kdWxlIGlkID0gMTY4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtZXRob2QsIGFyZyl7XHJcbiAgcmV0dXJuICEhbWV0aG9kICYmIGZhaWxzKGZ1bmN0aW9uKCl7XHJcbiAgICBhcmcgPyBtZXRob2QuY2FsbChudWxsLCBmdW5jdGlvbigpe30sIDEpIDogbWV0aG9kLmNhbGwobnVsbCk7XHJcbiAgfSk7XHJcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19zdHJpY3QtbWV0aG9kLmpzXG4gKiogbW9kdWxlIGlkID0gMTY5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbnZhciAkZXhwb3J0ICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcclxuICAsIGh0bWwgICAgICAgPSByZXF1aXJlKCcuL19odG1sJylcclxuICAsIGNvZiAgICAgICAgPSByZXF1aXJlKCcuL19jb2YnKVxyXG4gICwgdG9JbmRleCAgICA9IHJlcXVpcmUoJy4vX3RvLWluZGV4JylcclxuICAsIHRvTGVuZ3RoICAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKVxyXG4gICwgYXJyYXlTbGljZSA9IFtdLnNsaWNlO1xyXG5cclxuLy8gZmFsbGJhY2sgZm9yIG5vdCBhcnJheS1saWtlIEVTMyBzdHJpbmdzIGFuZCBET00gb2JqZWN0c1xyXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcclxuICBpZihodG1sKWFycmF5U2xpY2UuY2FsbChodG1sKTtcclxufSksICdBcnJheScsIHtcclxuICBzbGljZTogZnVuY3Rpb24gc2xpY2UoYmVnaW4sIGVuZCl7XHJcbiAgICB2YXIgbGVuICAgPSB0b0xlbmd0aCh0aGlzLmxlbmd0aClcclxuICAgICAgLCBrbGFzcyA9IGNvZih0aGlzKTtcclxuICAgIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogZW5kO1xyXG4gICAgaWYoa2xhc3MgPT0gJ0FycmF5JylyZXR1cm4gYXJyYXlTbGljZS5jYWxsKHRoaXMsIGJlZ2luLCBlbmQpO1xyXG4gICAgdmFyIHN0YXJ0ICA9IHRvSW5kZXgoYmVnaW4sIGxlbilcclxuICAgICAgLCB1cFRvICAgPSB0b0luZGV4KGVuZCwgbGVuKVxyXG4gICAgICAsIHNpemUgICA9IHRvTGVuZ3RoKHVwVG8gLSBzdGFydClcclxuICAgICAgLCBjbG9uZWQgPSBBcnJheShzaXplKVxyXG4gICAgICAsIGkgICAgICA9IDA7XHJcbiAgICBmb3IoOyBpIDwgc2l6ZTsgaSsrKWNsb25lZFtpXSA9IGtsYXNzID09ICdTdHJpbmcnXHJcbiAgICAgID8gdGhpcy5jaGFyQXQoc3RhcnQgKyBpKVxyXG4gICAgICA6IHRoaXNbc3RhcnQgKyBpXTtcclxuICAgIHJldHVybiBjbG9uZWQ7XHJcbiAgfVxyXG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnNsaWNlLmpzXG4gKiogbW9kdWxlIGlkID0gMTcwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbnZhciAkZXhwb3J0ICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxyXG4gICwgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpXHJcbiAgLCB0b09iamVjdCAgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxyXG4gICwgZmFpbHMgICAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKVxyXG4gICwgJHNvcnQgICAgID0gW10uc29ydFxyXG4gICwgdGVzdCAgICAgID0gWzEsIDIsIDNdO1xyXG5cclxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoZmFpbHMoZnVuY3Rpb24oKXtcclxuICAvLyBJRTgtXHJcbiAgdGVzdC5zb3J0KHVuZGVmaW5lZCk7XHJcbn0pIHx8ICFmYWlscyhmdW5jdGlvbigpe1xyXG4gIC8vIFY4IGJ1Z1xyXG4gIHRlc3Quc29ydChudWxsKTtcclxuICAvLyBPbGQgV2ViS2l0XHJcbn0pIHx8ICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoJHNvcnQpKSwgJ0FycmF5Jywge1xyXG4gIC8vIDIyLjEuMy4yNSBBcnJheS5wcm90b3R5cGUuc29ydChjb21wYXJlZm4pXHJcbiAgc29ydDogZnVuY3Rpb24gc29ydChjb21wYXJlZm4pe1xyXG4gICAgcmV0dXJuIGNvbXBhcmVmbiA9PT0gdW5kZWZpbmVkXHJcbiAgICAgID8gJHNvcnQuY2FsbCh0b09iamVjdCh0aGlzKSlcclxuICAgICAgOiAkc29ydC5jYWxsKHRvT2JqZWN0KHRoaXMpLCBhRnVuY3Rpb24oY29tcGFyZWZuKSk7XHJcbiAgfVxyXG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnNvcnQuanNcbiAqKiBtb2R1bGUgaWQgPSAxNzFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxudmFyICRleHBvcnQgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcclxuICAsICRmb3JFYWNoID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDApXHJcbiAgLCBTVFJJQ1QgICA9IHJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5mb3JFYWNoLCB0cnVlKTtcclxuXHJcbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIVNUUklDVCwgJ0FycmF5Jywge1xyXG4gIC8vIDIyLjEuMy4xMCAvIDE1LjQuNC4xOCBBcnJheS5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuIFssIHRoaXNBcmddKVxyXG4gIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pe1xyXG4gICAgcmV0dXJuICRmb3JFYWNoKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c1sxXSk7XHJcbiAgfVxyXG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZvci1lYWNoLmpzXG4gKiogbW9kdWxlIGlkID0gMTcyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAwIC0+IEFycmF5I2ZvckVhY2hcbi8vIDEgLT4gQXJyYXkjbWFwXG4vLyAyIC0+IEFycmF5I2ZpbHRlclxuLy8gMyAtPiBBcnJheSNzb21lXG4vLyA0IC0+IEFycmF5I2V2ZXJ5XG4vLyA1IC0+IEFycmF5I2ZpbmRcbi8vIDYgLT4gQXJyYXkjZmluZEluZGV4XG52YXIgY3R4ICAgICAgPSByZXF1aXJlKCcuL19jdHgnKVxuICAsIElPYmplY3QgID0gcmVxdWlyZSgnLi9faW9iamVjdCcpXG4gICwgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCBhc2MgICAgICA9IHJlcXVpcmUoJy4vX2FycmF5LXNwZWNpZXMtY3JlYXRlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFRZUEUsICRjcmVhdGUpe1xuICB2YXIgSVNfTUFQICAgICAgICA9IFRZUEUgPT0gMVxuICAgICwgSVNfRklMVEVSICAgICA9IFRZUEUgPT0gMlxuICAgICwgSVNfU09NRSAgICAgICA9IFRZUEUgPT0gM1xuICAgICwgSVNfRVZFUlkgICAgICA9IFRZUEUgPT0gNFxuICAgICwgSVNfRklORF9JTkRFWCA9IFRZUEUgPT0gNlxuICAgICwgTk9fSE9MRVMgICAgICA9IFRZUEUgPT0gNSB8fCBJU19GSU5EX0lOREVYXG4gICAgLCBjcmVhdGUgICAgICAgID0gJGNyZWF0ZSB8fCBhc2M7XG4gIHJldHVybiBmdW5jdGlvbigkdGhpcywgY2FsbGJhY2tmbiwgdGhhdCl7XG4gICAgdmFyIE8gICAgICA9IHRvT2JqZWN0KCR0aGlzKVxuICAgICAgLCBzZWxmICAgPSBJT2JqZWN0KE8pXG4gICAgICAsIGYgICAgICA9IGN0eChjYWxsYmFja2ZuLCB0aGF0LCAzKVxuICAgICAgLCBsZW5ndGggPSB0b0xlbmd0aChzZWxmLmxlbmd0aClcbiAgICAgICwgaW5kZXggID0gMFxuICAgICAgLCByZXN1bHQgPSBJU19NQVAgPyBjcmVhdGUoJHRoaXMsIGxlbmd0aCkgOiBJU19GSUxURVIgPyBjcmVhdGUoJHRoaXMsIDApIDogdW5kZWZpbmVkXG4gICAgICAsIHZhbCwgcmVzO1xuICAgIGZvcig7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspaWYoTk9fSE9MRVMgfHwgaW5kZXggaW4gc2VsZil7XG4gICAgICB2YWwgPSBzZWxmW2luZGV4XTtcbiAgICAgIHJlcyA9IGYodmFsLCBpbmRleCwgTyk7XG4gICAgICBpZihUWVBFKXtcbiAgICAgICAgaWYoSVNfTUFQKXJlc3VsdFtpbmRleF0gPSByZXM7ICAgICAgICAgICAgLy8gbWFwXG4gICAgICAgIGVsc2UgaWYocmVzKXN3aXRjaChUWVBFKXtcbiAgICAgICAgICBjYXNlIDM6IHJldHVybiB0cnVlOyAgICAgICAgICAgICAgICAgICAgLy8gc29tZVxuICAgICAgICAgIGNhc2UgNTogcmV0dXJuIHZhbDsgICAgICAgICAgICAgICAgICAgICAvLyBmaW5kXG4gICAgICAgICAgY2FzZSA2OiByZXR1cm4gaW5kZXg7ICAgICAgICAgICAgICAgICAgIC8vIGZpbmRJbmRleFxuICAgICAgICAgIGNhc2UgMjogcmVzdWx0LnB1c2godmFsKTsgICAgICAgICAgICAgICAvLyBmaWx0ZXJcbiAgICAgICAgfSBlbHNlIGlmKElTX0VWRVJZKXJldHVybiBmYWxzZTsgICAgICAgICAgLy8gZXZlcnlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIElTX0ZJTkRfSU5ERVggPyAtMSA6IElTX1NPTUUgfHwgSVNfRVZFUlkgPyBJU19FVkVSWSA6IHJlc3VsdDtcbiAgfTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19hcnJheS1tZXRob2RzLmpzXG4gKiogbW9kdWxlIGlkID0gMTczXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyA5LjQuMi4zIEFycmF5U3BlY2llc0NyZWF0ZShvcmlnaW5hbEFycmF5LCBsZW5ndGgpXG52YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fYXJyYXktc3BlY2llcy1jb25zdHJ1Y3RvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9yaWdpbmFsLCBsZW5ndGgpe1xuICByZXR1cm4gbmV3IChzcGVjaWVzQ29uc3RydWN0b3Iob3JpZ2luYWwpKShsZW5ndGgpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2FycmF5LXNwZWNpZXMtY3JlYXRlLmpzXG4gKiogbW9kdWxlIGlkID0gMTc0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxyXG4gICwgaXNBcnJheSAgPSByZXF1aXJlKCcuL19pcy1hcnJheScpXHJcbiAgLCBTUEVDSUVTICA9IHJlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9yaWdpbmFsKXtcclxuICB2YXIgQztcclxuICBpZihpc0FycmF5KG9yaWdpbmFsKSl7XHJcbiAgICBDID0gb3JpZ2luYWwuY29uc3RydWN0b3I7XHJcbiAgICAvLyBjcm9zcy1yZWFsbSBmYWxsYmFja1xyXG4gICAgaWYodHlwZW9mIEMgPT0gJ2Z1bmN0aW9uJyAmJiAoQyA9PT0gQXJyYXkgfHwgaXNBcnJheShDLnByb3RvdHlwZSkpKUMgPSB1bmRlZmluZWQ7XHJcbiAgICBpZihpc09iamVjdChDKSl7XHJcbiAgICAgIEMgPSBDW1NQRUNJRVNdO1xyXG4gICAgICBpZihDID09PSBudWxsKUMgPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgfSByZXR1cm4gQyA9PT0gdW5kZWZpbmVkID8gQXJyYXkgOiBDO1xyXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fYXJyYXktc3BlY2llcy1jb25zdHJ1Y3Rvci5qc1xuICoqIG1vZHVsZSBpZCA9IDE3NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXHJcbiAgLCAkbWFwICAgID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDEpO1xyXG5cclxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKFtdLm1hcCwgdHJ1ZSksICdBcnJheScsIHtcclxuICAvLyAyMi4xLjMuMTUgLyAxNS40LjQuMTkgQXJyYXkucHJvdG90eXBlLm1hcChjYWxsYmFja2ZuIFssIHRoaXNBcmddKVxyXG4gIG1hcDogZnVuY3Rpb24gbWFwKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKXtcclxuICAgIHJldHVybiAkbWFwKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c1sxXSk7XHJcbiAgfVxyXG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lm1hcC5qc1xuICoqIG1vZHVsZSBpZCA9IDE3NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRmaWx0ZXIgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoMik7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5maWx0ZXIsIHRydWUpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy43IC8gMTUuNC40LjIwIEFycmF5LnByb3RvdHlwZS5maWx0ZXIoY2FsbGJhY2tmbiBbLCB0aGlzQXJnXSlcbiAgZmlsdGVyOiBmdW5jdGlvbiBmaWx0ZXIoY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pe1xuICAgIHJldHVybiAkZmlsdGVyKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c1sxXSk7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZmlsdGVyLmpzXG4gKiogbW9kdWxlIGlkID0gMTc3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcclxuICAsICRzb21lICAgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoMyk7XHJcblxyXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoW10uc29tZSwgdHJ1ZSksICdBcnJheScsIHtcclxuICAvLyAyMi4xLjMuMjMgLyAxNS40LjQuMTcgQXJyYXkucHJvdG90eXBlLnNvbWUoY2FsbGJhY2tmbiBbLCB0aGlzQXJnXSlcclxuICBzb21lOiBmdW5jdGlvbiBzb21lKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKXtcclxuICAgIHJldHVybiAkc29tZSh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHNbMV0pO1xyXG4gIH1cclxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5zb21lLmpzXG4gKiogbW9kdWxlIGlkID0gMTc4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcclxuICAsICRldmVyeSAgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoNCk7XHJcblxyXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoW10uZXZlcnksIHRydWUpLCAnQXJyYXknLCB7XHJcbiAgLy8gMjIuMS4zLjUgLyAxNS40LjQuMTYgQXJyYXkucHJvdG90eXBlLmV2ZXJ5KGNhbGxiYWNrZm4gWywgdGhpc0FyZ10pXHJcbiAgZXZlcnk6IGZ1bmN0aW9uIGV2ZXJ5KGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKXtcclxuICAgIHJldHVybiAkZXZlcnkodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzWzFdKTtcclxuICB9XHJcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZXZlcnkuanNcbiAqKiBtb2R1bGUgaWQgPSAxNzlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxyXG4gICwgJHJlZHVjZSA9IHJlcXVpcmUoJy4vX2FycmF5LXJlZHVjZScpO1xyXG5cclxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKFtdLnJlZHVjZSwgdHJ1ZSksICdBcnJheScsIHtcclxuICAvLyAyMi4xLjMuMTggLyAxNS40LjQuMjEgQXJyYXkucHJvdG90eXBlLnJlZHVjZShjYWxsYmFja2ZuIFssIGluaXRpYWxWYWx1ZV0pXHJcbiAgcmVkdWNlOiBmdW5jdGlvbiByZWR1Y2UoY2FsbGJhY2tmbiAvKiAsIGluaXRpYWxWYWx1ZSAqLyl7XHJcbiAgICByZXR1cm4gJHJlZHVjZSh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoLCBhcmd1bWVudHNbMV0sIGZhbHNlKTtcclxuICB9XHJcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkucmVkdWNlLmpzXG4gKiogbW9kdWxlIGlkID0gMTgwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpXHJcbiAgLCB0b09iamVjdCAgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxyXG4gICwgSU9iamVjdCAgID0gcmVxdWlyZSgnLi9faW9iamVjdCcpXHJcbiAgLCB0b0xlbmd0aCAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odGhhdCwgY2FsbGJhY2tmbiwgYUxlbiwgbWVtbywgaXNSaWdodCl7XHJcbiAgYUZ1bmN0aW9uKGNhbGxiYWNrZm4pO1xyXG4gIHZhciBPICAgICAgPSB0b09iamVjdCh0aGF0KVxyXG4gICAgLCBzZWxmICAgPSBJT2JqZWN0KE8pXHJcbiAgICAsIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKVxyXG4gICAgLCBpbmRleCAgPSBpc1JpZ2h0ID8gbGVuZ3RoIC0gMSA6IDBcclxuICAgICwgaSAgICAgID0gaXNSaWdodCA/IC0xIDogMTtcclxuICBpZihhTGVuIDwgMilmb3IoOzspe1xyXG4gICAgaWYoaW5kZXggaW4gc2VsZil7XHJcbiAgICAgIG1lbW8gPSBzZWxmW2luZGV4XTtcclxuICAgICAgaW5kZXggKz0gaTtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgICBpbmRleCArPSBpO1xyXG4gICAgaWYoaXNSaWdodCA/IGluZGV4IDwgMCA6IGxlbmd0aCA8PSBpbmRleCl7XHJcbiAgICAgIHRocm93IFR5cGVFcnJvcignUmVkdWNlIG9mIGVtcHR5IGFycmF5IHdpdGggbm8gaW5pdGlhbCB2YWx1ZScpO1xyXG4gICAgfVxyXG4gIH1cclxuICBmb3IoO2lzUmlnaHQgPyBpbmRleCA+PSAwIDogbGVuZ3RoID4gaW5kZXg7IGluZGV4ICs9IGkpaWYoaW5kZXggaW4gc2VsZil7XHJcbiAgICBtZW1vID0gY2FsbGJhY2tmbihtZW1vLCBzZWxmW2luZGV4XSwgaW5kZXgsIE8pO1xyXG4gIH1cclxuICByZXR1cm4gbWVtbztcclxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2FycmF5LXJlZHVjZS5qc1xuICoqIG1vZHVsZSBpZCA9IDE4MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXHJcbiAgLCAkcmVkdWNlID0gcmVxdWlyZSgnLi9fYXJyYXktcmVkdWNlJyk7XHJcblxyXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoW10ucmVkdWNlUmlnaHQsIHRydWUpLCAnQXJyYXknLCB7XHJcbiAgLy8gMjIuMS4zLjE5IC8gMTUuNC40LjIyIEFycmF5LnByb3RvdHlwZS5yZWR1Y2VSaWdodChjYWxsYmFja2ZuIFssIGluaXRpYWxWYWx1ZV0pXHJcbiAgcmVkdWNlUmlnaHQ6IGZ1bmN0aW9uIHJlZHVjZVJpZ2h0KGNhbGxiYWNrZm4gLyogLCBpbml0aWFsVmFsdWUgKi8pe1xyXG4gICAgcmV0dXJuICRyZWR1Y2UodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCwgYXJndW1lbnRzWzFdLCB0cnVlKTtcclxuICB9XHJcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkucmVkdWNlLXJpZ2h0LmpzXG4gKiogbW9kdWxlIGlkID0gMTgyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbnZhciAkZXhwb3J0ICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcclxuICAsICRpbmRleE9mICAgICAgPSByZXF1aXJlKCcuL19hcnJheS1pbmNsdWRlcycpKGZhbHNlKVxyXG4gICwgJG5hdGl2ZSAgICAgICA9IFtdLmluZGV4T2ZcclxuICAsIE5FR0FUSVZFX1pFUk8gPSAhISRuYXRpdmUgJiYgMSAvIFsxXS5pbmRleE9mKDEsIC0wKSA8IDA7XHJcblxyXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChORUdBVElWRV9aRVJPIHx8ICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoJG5hdGl2ZSkpLCAnQXJyYXknLCB7XHJcbiAgLy8gMjIuMS4zLjExIC8gMTUuNC40LjE0IEFycmF5LnByb3RvdHlwZS5pbmRleE9mKHNlYXJjaEVsZW1lbnQgWywgZnJvbUluZGV4XSlcclxuICBpbmRleE9mOiBmdW5jdGlvbiBpbmRleE9mKHNlYXJjaEVsZW1lbnQgLyosIGZyb21JbmRleCA9IDAgKi8pe1xyXG4gICAgcmV0dXJuIE5FR0FUSVZFX1pFUk9cclxuICAgICAgLy8gY29udmVydCAtMCB0byArMFxyXG4gICAgICA/ICRuYXRpdmUuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCAwXHJcbiAgICAgIDogJGluZGV4T2YodGhpcywgc2VhcmNoRWxlbWVudCwgYXJndW1lbnRzWzFdKTtcclxuICB9XHJcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuaW5kZXgtb2YuanNcbiAqKiBtb2R1bGUgaWQgPSAxODNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxudmFyICRleHBvcnQgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxyXG4gICwgdG9JT2JqZWN0ICAgICA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxyXG4gICwgdG9JbnRlZ2VyICAgICA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKVxyXG4gICwgdG9MZW5ndGggICAgICA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpXHJcbiAgLCAkbmF0aXZlICAgICAgID0gW10ubGFzdEluZGV4T2ZcclxuICAsIE5FR0FUSVZFX1pFUk8gPSAhISRuYXRpdmUgJiYgMSAvIFsxXS5sYXN0SW5kZXhPZigxLCAtMCkgPCAwO1xyXG5cclxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoTkVHQVRJVkVfWkVSTyB8fCAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKCRuYXRpdmUpKSwgJ0FycmF5Jywge1xyXG4gIC8vIDIyLjEuMy4xNCAvIDE1LjQuNC4xNSBBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2Yoc2VhcmNoRWxlbWVudCBbLCBmcm9tSW5kZXhdKVxyXG4gIGxhc3RJbmRleE9mOiBmdW5jdGlvbiBsYXN0SW5kZXhPZihzZWFyY2hFbGVtZW50IC8qLCBmcm9tSW5kZXggPSBAWyotMV0gKi8pe1xyXG4gICAgLy8gY29udmVydCAtMCB0byArMFxyXG4gICAgaWYoTkVHQVRJVkVfWkVSTylyZXR1cm4gJG5hdGl2ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IDA7XHJcbiAgICB2YXIgTyAgICAgID0gdG9JT2JqZWN0KHRoaXMpXHJcbiAgICAgICwgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpXHJcbiAgICAgICwgaW5kZXggID0gbGVuZ3RoIC0gMTtcclxuICAgIGlmKGFyZ3VtZW50cy5sZW5ndGggPiAxKWluZGV4ID0gTWF0aC5taW4oaW5kZXgsIHRvSW50ZWdlcihhcmd1bWVudHNbMV0pKTtcclxuICAgIGlmKGluZGV4IDwgMClpbmRleCA9IGxlbmd0aCArIGluZGV4O1xyXG4gICAgZm9yKDtpbmRleCA+PSAwOyBpbmRleC0tKWlmKGluZGV4IGluIE8paWYoT1tpbmRleF0gPT09IHNlYXJjaEVsZW1lbnQpcmV0dXJuIGluZGV4IHx8IDA7XHJcbiAgICByZXR1cm4gLTE7XHJcbiAgfVxyXG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lmxhc3QtaW5kZXgtb2YuanNcbiAqKiBtb2R1bGUgaWQgPSAxODRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDIyLjEuMy4zIEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluKHRhcmdldCwgc3RhcnQsIGVuZCA9IHRoaXMubGVuZ3RoKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdBcnJheScsIHtjb3B5V2l0aGluOiByZXF1aXJlKCcuL19hcnJheS1jb3B5LXdpdGhpbicpfSk7XG5cbnJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpKCdjb3B5V2l0aGluJyk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5jb3B5LXdpdGhpbi5qc1xuICoqIG1vZHVsZSBpZCA9IDE4NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMjIuMS4zLjMgQXJyYXkucHJvdG90eXBlLmNvcHlXaXRoaW4odGFyZ2V0LCBzdGFydCwgZW5kID0gdGhpcy5sZW5ndGgpXG4ndXNlIHN0cmljdCc7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIHRvSW5kZXggID0gcmVxdWlyZSgnLi9fdG8taW5kZXgnKVxuICAsIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gW10uY29weVdpdGhpbiB8fCBmdW5jdGlvbiBjb3B5V2l0aGluKHRhcmdldC8qPSAwKi8sIHN0YXJ0Lyo9IDAsIGVuZCA9IEBsZW5ndGgqLyl7XG4gIHZhciBPICAgICA9IHRvT2JqZWN0KHRoaXMpXG4gICAgLCBsZW4gICA9IHRvTGVuZ3RoKE8ubGVuZ3RoKVxuICAgICwgdG8gICAgPSB0b0luZGV4KHRhcmdldCwgbGVuKVxuICAgICwgZnJvbSAgPSB0b0luZGV4KHN0YXJ0LCBsZW4pXG4gICAgLCBlbmQgICA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkXG4gICAgLCBjb3VudCA9IE1hdGgubWluKChlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IHRvSW5kZXgoZW5kLCBsZW4pKSAtIGZyb20sIGxlbiAtIHRvKVxuICAgICwgaW5jICAgPSAxO1xuICBpZihmcm9tIDwgdG8gJiYgdG8gPCBmcm9tICsgY291bnQpe1xuICAgIGluYyAgPSAtMTtcbiAgICBmcm9tICs9IGNvdW50IC0gMTtcbiAgICB0byAgICs9IGNvdW50IC0gMTtcbiAgfVxuICB3aGlsZShjb3VudC0tID4gMCl7XG4gICAgaWYoZnJvbSBpbiBPKU9bdG9dID0gT1tmcm9tXTtcbiAgICBlbHNlIGRlbGV0ZSBPW3RvXTtcbiAgICB0byAgICs9IGluYztcbiAgICBmcm9tICs9IGluYztcbiAgfSByZXR1cm4gTztcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19hcnJheS1jb3B5LXdpdGhpbi5qc1xuICoqIG1vZHVsZSBpZCA9IDE4NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMjIuMS4zLjMxIEFycmF5LnByb3RvdHlwZVtAQHVuc2NvcGFibGVzXVxudmFyIFVOU0NPUEFCTEVTID0gcmVxdWlyZSgnLi9fd2tzJykoJ3Vuc2NvcGFibGVzJylcbiAgLCBBcnJheVByb3RvICA9IEFycmF5LnByb3RvdHlwZTtcbmlmKEFycmF5UHJvdG9bVU5TQ09QQUJMRVNdID09IHVuZGVmaW5lZClyZXF1aXJlKCcuL19oaWRlJykoQXJyYXlQcm90bywgVU5TQ09QQUJMRVMsIHt9KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oa2V5KXtcbiAgQXJyYXlQcm90b1tVTlNDT1BBQkxFU11ba2V5XSA9IHRydWU7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fYWRkLXRvLXVuc2NvcGFibGVzLmpzXG4gKiogbW9kdWxlIGlkID0gMTg3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAyMi4xLjMuNiBBcnJheS5wcm90b3R5cGUuZmlsbCh2YWx1ZSwgc3RhcnQgPSAwLCBlbmQgPSB0aGlzLmxlbmd0aClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnQXJyYXknLCB7ZmlsbDogcmVxdWlyZSgnLi9fYXJyYXktZmlsbCcpfSk7XG5cbnJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpKCdmaWxsJyk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5maWxsLmpzXG4gKiogbW9kdWxlIGlkID0gMTg4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAyMi4xLjMuNiBBcnJheS5wcm90b3R5cGUuZmlsbCh2YWx1ZSwgc3RhcnQgPSAwLCBlbmQgPSB0aGlzLmxlbmd0aClcbid1c2Ugc3RyaWN0JztcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgdG9JbmRleCAgPSByZXF1aXJlKCcuL190by1pbmRleCcpXG4gICwgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZmlsbCh2YWx1ZSAvKiwgc3RhcnQgPSAwLCBlbmQgPSBAbGVuZ3RoICovKXtcbiAgdmFyIE8gICAgICA9IHRvT2JqZWN0KHRoaXMpXG4gICAgLCBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aClcbiAgICAsIGFMZW4gICA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAsIGluZGV4ICA9IHRvSW5kZXgoYUxlbiA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIGxlbmd0aClcbiAgICAsIGVuZCAgICA9IGFMZW4gPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkXG4gICAgLCBlbmRQb3MgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IHRvSW5kZXgoZW5kLCBsZW5ndGgpO1xuICB3aGlsZShlbmRQb3MgPiBpbmRleClPW2luZGV4KytdID0gdmFsdWU7XG4gIHJldHVybiBPO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2FycmF5LWZpbGwuanNcbiAqKiBtb2R1bGUgaWQgPSAxODlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0Jztcbi8vIDIyLjEuMy44IEFycmF5LnByb3RvdHlwZS5maW5kKHByZWRpY2F0ZSwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkZmluZCAgID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDUpXG4gICwgS0VZICAgICA9ICdmaW5kJ1xuICAsIGZvcmNlZCAgPSB0cnVlO1xuLy8gU2hvdWxkbid0IHNraXAgaG9sZXNcbmlmKEtFWSBpbiBbXSlBcnJheSgxKVtLRVldKGZ1bmN0aW9uKCl7IGZvcmNlZCA9IGZhbHNlOyB9KTtcbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogZm9yY2VkLCAnQXJyYXknLCB7XG4gIGZpbmQ6IGZ1bmN0aW9uIGZpbmQoY2FsbGJhY2tmbi8qLCB0aGF0ID0gdW5kZWZpbmVkICovKXtcbiAgICByZXR1cm4gJGZpbmQodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcbnJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpKEtFWSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5maW5kLmpzXG4gKiogbW9kdWxlIGlkID0gMTkwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG4vLyAyMi4xLjMuOSBBcnJheS5wcm90b3R5cGUuZmluZEluZGV4KHByZWRpY2F0ZSwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkZmluZCAgID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDYpXG4gICwgS0VZICAgICA9ICdmaW5kSW5kZXgnXG4gICwgZm9yY2VkICA9IHRydWU7XG4vLyBTaG91bGRuJ3Qgc2tpcCBob2xlc1xuaWYoS0VZIGluIFtdKUFycmF5KDEpW0tFWV0oZnVuY3Rpb24oKXsgZm9yY2VkID0gZmFsc2U7IH0pO1xuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBmb3JjZWQsICdBcnJheScsIHtcbiAgZmluZEluZGV4OiBmdW5jdGlvbiBmaW5kSW5kZXgoY2FsbGJhY2tmbi8qLCB0aGF0ID0gdW5kZWZpbmVkICovKXtcbiAgICByZXR1cm4gJGZpbmQodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcbnJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpKEtFWSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5maW5kLWluZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTkxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJyZXF1aXJlKCcuL19zZXQtc3BlY2llcycpKCdBcnJheScpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuc3BlY2llcy5qc1xuICoqIG1vZHVsZSBpZCA9IDE5MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBkUCAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpXG4gICwgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpXG4gICwgU1BFQ0lFUyAgICAgPSByZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKEtFWSl7XG4gIHZhciBDID0gZ2xvYmFsW0tFWV07XG4gIGlmKERFU0NSSVBUT1JTICYmIEMgJiYgIUNbU1BFQ0lFU10pZFAuZihDLCBTUEVDSUVTLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXM7IH1cbiAgfSk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fc2V0LXNwZWNpZXMuanNcbiAqKiBtb2R1bGUgaWQgPSAxOTNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciBhZGRUb1Vuc2NvcGFibGVzID0gcmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJylcbiAgLCBzdGVwICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faXRlci1zdGVwJylcbiAgLCBJdGVyYXRvcnMgICAgICAgID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJylcbiAgLCB0b0lPYmplY3QgICAgICAgID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xuXG4vLyAyMi4xLjMuNCBBcnJheS5wcm90b3R5cGUuZW50cmllcygpXG4vLyAyMi4xLjMuMTMgQXJyYXkucHJvdG90eXBlLmtleXMoKVxuLy8gMjIuMS4zLjI5IEFycmF5LnByb3RvdHlwZS52YWx1ZXMoKVxuLy8gMjIuMS4zLjMwIEFycmF5LnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2l0ZXItZGVmaW5lJykoQXJyYXksICdBcnJheScsIGZ1bmN0aW9uKGl0ZXJhdGVkLCBraW5kKXtcbiAgdGhpcy5fdCA9IHRvSU9iamVjdChpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuICB0aGlzLl9rID0ga2luZDsgICAgICAgICAgICAgICAgLy8ga2luZFxuLy8gMjIuMS41LjIuMSAlQXJyYXlJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXG59LCBmdW5jdGlvbigpe1xuICB2YXIgTyAgICAgPSB0aGlzLl90XG4gICAgLCBraW5kICA9IHRoaXMuX2tcbiAgICAsIGluZGV4ID0gdGhpcy5faSsrO1xuICBpZighTyB8fCBpbmRleCA+PSBPLmxlbmd0aCl7XG4gICAgdGhpcy5fdCA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gc3RlcCgxKTtcbiAgfVxuICBpZihraW5kID09ICdrZXlzJyAgKXJldHVybiBzdGVwKDAsIGluZGV4KTtcbiAgaWYoa2luZCA9PSAndmFsdWVzJylyZXR1cm4gc3RlcCgwLCBPW2luZGV4XSk7XG4gIHJldHVybiBzdGVwKDAsIFtpbmRleCwgT1tpbmRleF1dKTtcbn0sICd2YWx1ZXMnKTtcblxuLy8gYXJndW1lbnRzTGlzdFtAQGl0ZXJhdG9yXSBpcyAlQXJyYXlQcm90b192YWx1ZXMlICg5LjQuNC42LCA5LjQuNC43KVxuSXRlcmF0b3JzLkFyZ3VtZW50cyA9IEl0ZXJhdG9ycy5BcnJheTtcblxuYWRkVG9VbnNjb3BhYmxlcygna2V5cycpO1xuYWRkVG9VbnNjb3BhYmxlcygndmFsdWVzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCdlbnRyaWVzJyk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5pdGVyYXRvci5qc1xuICoqIG1vZHVsZSBpZCA9IDE5NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihkb25lLCB2YWx1ZSl7XG4gIHJldHVybiB7dmFsdWU6IHZhbHVlLCBkb25lOiAhIWRvbmV9O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2l0ZXItc3RlcC5qc1xuICoqIG1vZHVsZSBpZCA9IDE5NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGdsb2JhbCAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBpbmhlcml0SWZSZXF1aXJlZCA9IHJlcXVpcmUoJy4vX2luaGVyaXQtaWYtcmVxdWlyZWQnKVxuICAsIGRQICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZlxuICAsIGdPUE4gICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mXG4gICwgaXNSZWdFeHAgICAgICAgICAgPSByZXF1aXJlKCcuL19pcy1yZWdleHAnKVxuICAsICRmbGFncyAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZmxhZ3MnKVxuICAsICRSZWdFeHAgICAgICAgICAgID0gZ2xvYmFsLlJlZ0V4cFxuICAsIEJhc2UgICAgICAgICAgICAgID0gJFJlZ0V4cFxuICAsIHByb3RvICAgICAgICAgICAgID0gJFJlZ0V4cC5wcm90b3R5cGVcbiAgLCByZTEgICAgICAgICAgICAgICA9IC9hL2dcbiAgLCByZTIgICAgICAgICAgICAgICA9IC9hL2dcbiAgLy8gXCJuZXdcIiBjcmVhdGVzIGEgbmV3IG9iamVjdCwgb2xkIHdlYmtpdCBidWdneSBoZXJlXG4gICwgQ09SUkVDVF9ORVcgICAgICAgPSBuZXcgJFJlZ0V4cChyZTEpICE9PSByZTE7XG5cbmlmKHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgKCFDT1JSRUNUX05FVyB8fCByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHJlMltyZXF1aXJlKCcuL193a3MnKSgnbWF0Y2gnKV0gPSBmYWxzZTtcbiAgLy8gUmVnRXhwIGNvbnN0cnVjdG9yIGNhbiBhbHRlciBmbGFncyBhbmQgSXNSZWdFeHAgd29ya3MgY29ycmVjdCB3aXRoIEBAbWF0Y2hcbiAgcmV0dXJuICRSZWdFeHAocmUxKSAhPSByZTEgfHwgJFJlZ0V4cChyZTIpID09IHJlMiB8fCAkUmVnRXhwKHJlMSwgJ2knKSAhPSAnL2EvaSc7XG59KSkpe1xuICAkUmVnRXhwID0gZnVuY3Rpb24gUmVnRXhwKHAsIGYpe1xuICAgIHZhciB0aVJFID0gdGhpcyBpbnN0YW5jZW9mICRSZWdFeHBcbiAgICAgICwgcGlSRSA9IGlzUmVnRXhwKHApXG4gICAgICAsIGZpVSAgPSBmID09PSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuICF0aVJFICYmIHBpUkUgJiYgcC5jb25zdHJ1Y3RvciA9PT0gJFJlZ0V4cCAmJiBmaVUgPyBwXG4gICAgICA6IGluaGVyaXRJZlJlcXVpcmVkKENPUlJFQ1RfTkVXXG4gICAgICAgID8gbmV3IEJhc2UocGlSRSAmJiAhZmlVID8gcC5zb3VyY2UgOiBwLCBmKVxuICAgICAgICA6IEJhc2UoKHBpUkUgPSBwIGluc3RhbmNlb2YgJFJlZ0V4cCkgPyBwLnNvdXJjZSA6IHAsIHBpUkUgJiYgZmlVID8gJGZsYWdzLmNhbGwocCkgOiBmKVxuICAgICAgLCB0aVJFID8gdGhpcyA6IHByb3RvLCAkUmVnRXhwKTtcbiAgfTtcbiAgdmFyIHByb3h5ID0gZnVuY3Rpb24oa2V5KXtcbiAgICBrZXkgaW4gJFJlZ0V4cCB8fCBkUCgkUmVnRXhwLCBrZXksIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIEJhc2Vba2V5XTsgfSxcbiAgICAgIHNldDogZnVuY3Rpb24oaXQpeyBCYXNlW2tleV0gPSBpdDsgfVxuICAgIH0pO1xuICB9O1xuICBmb3IodmFyIGtleXMgPSBnT1BOKEJhc2UpLCBpID0gMDsga2V5cy5sZW5ndGggPiBpOyApcHJveHkoa2V5c1tpKytdKTtcbiAgcHJvdG8uY29uc3RydWN0b3IgPSAkUmVnRXhwO1xuICAkUmVnRXhwLnByb3RvdHlwZSA9IHByb3RvO1xuICByZXF1aXJlKCcuL19yZWRlZmluZScpKGdsb2JhbCwgJ1JlZ0V4cCcsICRSZWdFeHApO1xufVxuXG5yZXF1aXJlKCcuL19zZXQtc3BlY2llcycpKCdSZWdFeHAnKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5jb25zdHJ1Y3Rvci5qc1xuICoqIG1vZHVsZSBpZCA9IDE5NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMjEuMi41LjMgZ2V0IFJlZ0V4cC5wcm90b3R5cGUuZmxhZ3NcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpe1xuICB2YXIgdGhhdCAgID0gYW5PYmplY3QodGhpcylcbiAgICAsIHJlc3VsdCA9ICcnO1xuICBpZih0aGF0Lmdsb2JhbCkgICAgIHJlc3VsdCArPSAnZyc7XG4gIGlmKHRoYXQuaWdub3JlQ2FzZSkgcmVzdWx0ICs9ICdpJztcbiAgaWYodGhhdC5tdWx0aWxpbmUpICByZXN1bHQgKz0gJ20nO1xuICBpZih0aGF0LnVuaWNvZGUpICAgIHJlc3VsdCArPSAndSc7XG4gIGlmKHRoYXQuc3RpY2t5KSAgICAgcmVzdWx0ICs9ICd5JztcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19mbGFncy5qc1xuICoqIG1vZHVsZSBpZCA9IDE5N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG5yZXF1aXJlKCcuL2VzNi5yZWdleHAuZmxhZ3MnKTtcclxudmFyIGFuT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcclxuICAsICRmbGFncyAgICAgID0gcmVxdWlyZSgnLi9fZmxhZ3MnKVxyXG4gICwgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpXHJcbiAgLCBUT19TVFJJTkcgICA9ICd0b1N0cmluZydcclxuICAsICR0b1N0cmluZyAgID0gLy4vW1RPX1NUUklOR107XHJcblxyXG52YXIgZGVmaW5lID0gZnVuY3Rpb24oZm4pe1xyXG4gIHJlcXVpcmUoJy4vX3JlZGVmaW5lJykoUmVnRXhwLnByb3RvdHlwZSwgVE9fU1RSSU5HLCBmbiwgdHJ1ZSk7XHJcbn07XHJcblxyXG4vLyAyMS4yLjUuMTQgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZygpXHJcbmlmKHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXsgcmV0dXJuICR0b1N0cmluZy5jYWxsKHtzb3VyY2U6ICdhJywgZmxhZ3M6ICdiJ30pICE9ICcvYS9iJzsgfSkpe1xyXG4gIGRlZmluZShmdW5jdGlvbiB0b1N0cmluZygpe1xyXG4gICAgdmFyIFIgPSBhbk9iamVjdCh0aGlzKTtcclxuICAgIHJldHVybiAnLycuY29uY2F0KFIuc291cmNlLCAnLycsXHJcbiAgICAgICdmbGFncycgaW4gUiA/IFIuZmxhZ3MgOiAhREVTQ1JJUFRPUlMgJiYgUiBpbnN0YW5jZW9mIFJlZ0V4cCA/ICRmbGFncy5jYWxsKFIpIDogdW5kZWZpbmVkKTtcclxuICB9KTtcclxuLy8gRkY0NC0gUmVnRXhwI3RvU3RyaW5nIGhhcyBhIHdyb25nIG5hbWVcclxufSBlbHNlIGlmKCR0b1N0cmluZy5uYW1lICE9IFRPX1NUUklORyl7XHJcbiAgZGVmaW5lKGZ1bmN0aW9uIHRvU3RyaW5nKCl7XHJcbiAgICByZXR1cm4gJHRvU3RyaW5nLmNhbGwodGhpcyk7XHJcbiAgfSk7XHJcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC50by1zdHJpbmcuanNcbiAqKiBtb2R1bGUgaWQgPSAxOThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDIxLjIuNS4zIGdldCBSZWdFeHAucHJvdG90eXBlLmZsYWdzKClcbmlmKHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgLy4vZy5mbGFncyAhPSAnZycpcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZihSZWdFeHAucHJvdG90eXBlLCAnZmxhZ3MnLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZ2V0OiByZXF1aXJlKCcuL19mbGFncycpXG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5mbGFncy5qc1xuICoqIG1vZHVsZSBpZCA9IDE5OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gQEBtYXRjaCBsb2dpY1xucmVxdWlyZSgnLi9fZml4LXJlLXdrcycpKCdtYXRjaCcsIDEsIGZ1bmN0aW9uKGRlZmluZWQsIE1BVENILCAkbWF0Y2gpe1xuICAvLyAyMS4xLjMuMTEgU3RyaW5nLnByb3RvdHlwZS5tYXRjaChyZWdleHApXG4gIHJldHVybiBbZnVuY3Rpb24gbWF0Y2gocmVnZXhwKXtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIE8gID0gZGVmaW5lZCh0aGlzKVxuICAgICAgLCBmbiA9IHJlZ2V4cCA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiByZWdleHBbTUFUQ0hdO1xuICAgIHJldHVybiBmbiAhPT0gdW5kZWZpbmVkID8gZm4uY2FsbChyZWdleHAsIE8pIDogbmV3IFJlZ0V4cChyZWdleHApW01BVENIXShTdHJpbmcoTykpO1xuICB9LCAkbWF0Y2hdO1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAubWF0Y2guanNcbiAqKiBtb2R1bGUgaWQgPSAyMDBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciBoaWRlICAgICA9IHJlcXVpcmUoJy4vX2hpZGUnKVxuICAsIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKVxuICAsIGZhaWxzICAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKVxuICAsIGRlZmluZWQgID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpXG4gICwgd2tzICAgICAgPSByZXF1aXJlKCcuL193a3MnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihLRVksIGxlbmd0aCwgZXhlYyl7XG4gIHZhciBTWU1CT0wgICA9IHdrcyhLRVkpXG4gICAgLCBmbnMgICAgICA9IGV4ZWMoZGVmaW5lZCwgU1lNQk9MLCAnJ1tLRVldKVxuICAgICwgc3RyZm4gICAgPSBmbnNbMF1cbiAgICAsIHJ4Zm4gICAgID0gZm5zWzFdO1xuICBpZihmYWlscyhmdW5jdGlvbigpe1xuICAgIHZhciBPID0ge307XG4gICAgT1tTWU1CT0xdID0gZnVuY3Rpb24oKXsgcmV0dXJuIDc7IH07XG4gICAgcmV0dXJuICcnW0tFWV0oTykgIT0gNztcbiAgfSkpe1xuICAgIHJlZGVmaW5lKFN0cmluZy5wcm90b3R5cGUsIEtFWSwgc3RyZm4pO1xuICAgIGhpZGUoUmVnRXhwLnByb3RvdHlwZSwgU1lNQk9MLCBsZW5ndGggPT0gMlxuICAgICAgLy8gMjEuMi41LjggUmVnRXhwLnByb3RvdHlwZVtAQHJlcGxhY2VdKHN0cmluZywgcmVwbGFjZVZhbHVlKVxuICAgICAgLy8gMjEuMi41LjExIFJlZ0V4cC5wcm90b3R5cGVbQEBzcGxpdF0oc3RyaW5nLCBsaW1pdClcbiAgICAgID8gZnVuY3Rpb24oc3RyaW5nLCBhcmcpeyByZXR1cm4gcnhmbi5jYWxsKHN0cmluZywgdGhpcywgYXJnKTsgfVxuICAgICAgLy8gMjEuMi41LjYgUmVnRXhwLnByb3RvdHlwZVtAQG1hdGNoXShzdHJpbmcpXG4gICAgICAvLyAyMS4yLjUuOSBSZWdFeHAucHJvdG90eXBlW0BAc2VhcmNoXShzdHJpbmcpXG4gICAgICA6IGZ1bmN0aW9uKHN0cmluZyl7IHJldHVybiByeGZuLmNhbGwoc3RyaW5nLCB0aGlzKTsgfVxuICAgICk7XG4gIH1cbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19maXgtcmUtd2tzLmpzXG4gKiogbW9kdWxlIGlkID0gMjAxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBAQHJlcGxhY2UgbG9naWNcbnJlcXVpcmUoJy4vX2ZpeC1yZS13a3MnKSgncmVwbGFjZScsIDIsIGZ1bmN0aW9uKGRlZmluZWQsIFJFUExBQ0UsICRyZXBsYWNlKXtcbiAgLy8gMjEuMS4zLjE0IFN0cmluZy5wcm90b3R5cGUucmVwbGFjZShzZWFyY2hWYWx1ZSwgcmVwbGFjZVZhbHVlKVxuICByZXR1cm4gW2Z1bmN0aW9uIHJlcGxhY2Uoc2VhcmNoVmFsdWUsIHJlcGxhY2VWYWx1ZSl7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIHZhciBPICA9IGRlZmluZWQodGhpcylcbiAgICAgICwgZm4gPSBzZWFyY2hWYWx1ZSA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBzZWFyY2hWYWx1ZVtSRVBMQUNFXTtcbiAgICByZXR1cm4gZm4gIT09IHVuZGVmaW5lZFxuICAgICAgPyBmbi5jYWxsKHNlYXJjaFZhbHVlLCBPLCByZXBsYWNlVmFsdWUpXG4gICAgICA6ICRyZXBsYWNlLmNhbGwoU3RyaW5nKE8pLCBzZWFyY2hWYWx1ZSwgcmVwbGFjZVZhbHVlKTtcbiAgfSwgJHJlcGxhY2VdO1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAucmVwbGFjZS5qc1xuICoqIG1vZHVsZSBpZCA9IDIwMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gQEBzZWFyY2ggbG9naWNcbnJlcXVpcmUoJy4vX2ZpeC1yZS13a3MnKSgnc2VhcmNoJywgMSwgZnVuY3Rpb24oZGVmaW5lZCwgU0VBUkNILCAkc2VhcmNoKXtcbiAgLy8gMjEuMS4zLjE1IFN0cmluZy5wcm90b3R5cGUuc2VhcmNoKHJlZ2V4cClcbiAgcmV0dXJuIFtmdW5jdGlvbiBzZWFyY2gocmVnZXhwKXtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIE8gID0gZGVmaW5lZCh0aGlzKVxuICAgICAgLCBmbiA9IHJlZ2V4cCA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiByZWdleHBbU0VBUkNIXTtcbiAgICByZXR1cm4gZm4gIT09IHVuZGVmaW5lZCA/IGZuLmNhbGwocmVnZXhwLCBPKSA6IG5ldyBSZWdFeHAocmVnZXhwKVtTRUFSQ0hdKFN0cmluZyhPKSk7XG4gIH0sICRzZWFyY2hdO1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAuc2VhcmNoLmpzXG4gKiogbW9kdWxlIGlkID0gMjAzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBAQHNwbGl0IGxvZ2ljXG5yZXF1aXJlKCcuL19maXgtcmUtd2tzJykoJ3NwbGl0JywgMiwgZnVuY3Rpb24oZGVmaW5lZCwgU1BMSVQsICRzcGxpdCl7XG4gICd1c2Ugc3RyaWN0JztcbiAgdmFyIGlzUmVnRXhwICAgPSByZXF1aXJlKCcuL19pcy1yZWdleHAnKVxuICAgICwgX3NwbGl0ICAgICA9ICRzcGxpdFxuICAgICwgJHB1c2ggICAgICA9IFtdLnB1c2hcbiAgICAsICRTUExJVCAgICAgPSAnc3BsaXQnXG4gICAgLCBMRU5HVEggICAgID0gJ2xlbmd0aCdcbiAgICAsIExBU1RfSU5ERVggPSAnbGFzdEluZGV4JztcbiAgaWYoXG4gICAgJ2FiYmMnWyRTUExJVF0oLyhiKSovKVsxXSA9PSAnYycgfHxcbiAgICAndGVzdCdbJFNQTElUXSgvKD86KS8sIC0xKVtMRU5HVEhdICE9IDQgfHxcbiAgICAnYWInWyRTUExJVF0oLyg/OmFiKSovKVtMRU5HVEhdICE9IDIgfHxcbiAgICAnLidbJFNQTElUXSgvKC4/KSguPykvKVtMRU5HVEhdICE9IDQgfHxcbiAgICAnLidbJFNQTElUXSgvKCkoKS8pW0xFTkdUSF0gPiAxIHx8XG4gICAgJydbJFNQTElUXSgvLj8vKVtMRU5HVEhdXG4gICl7XG4gICAgdmFyIE5QQ0cgPSAvKCk/Py8uZXhlYygnJylbMV0gPT09IHVuZGVmaW5lZDsgLy8gbm9ucGFydGljaXBhdGluZyBjYXB0dXJpbmcgZ3JvdXBcbiAgICAvLyBiYXNlZCBvbiBlczUtc2hpbSBpbXBsZW1lbnRhdGlvbiwgbmVlZCB0byByZXdvcmsgaXRcbiAgICAkc3BsaXQgPSBmdW5jdGlvbihzZXBhcmF0b3IsIGxpbWl0KXtcbiAgICAgIHZhciBzdHJpbmcgPSBTdHJpbmcodGhpcyk7XG4gICAgICBpZihzZXBhcmF0b3IgPT09IHVuZGVmaW5lZCAmJiBsaW1pdCA9PT0gMClyZXR1cm4gW107XG4gICAgICAvLyBJZiBgc2VwYXJhdG9yYCBpcyBub3QgYSByZWdleCwgdXNlIG5hdGl2ZSBzcGxpdFxuICAgICAgaWYoIWlzUmVnRXhwKHNlcGFyYXRvcikpcmV0dXJuIF9zcGxpdC5jYWxsKHN0cmluZywgc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgICB2YXIgb3V0cHV0ID0gW107XG4gICAgICB2YXIgZmxhZ3MgPSAoc2VwYXJhdG9yLmlnbm9yZUNhc2UgPyAnaScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci5tdWx0aWxpbmUgPyAnbScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci51bmljb2RlID8gJ3UnIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3Iuc3RpY2t5ID8gJ3knIDogJycpO1xuICAgICAgdmFyIGxhc3RMYXN0SW5kZXggPSAwO1xuICAgICAgdmFyIHNwbGl0TGltaXQgPSBsaW1pdCA9PT0gdW5kZWZpbmVkID8gNDI5NDk2NzI5NSA6IGxpbWl0ID4+PiAwO1xuICAgICAgLy8gTWFrZSBgZ2xvYmFsYCBhbmQgYXZvaWQgYGxhc3RJbmRleGAgaXNzdWVzIGJ5IHdvcmtpbmcgd2l0aCBhIGNvcHlcbiAgICAgIHZhciBzZXBhcmF0b3JDb3B5ID0gbmV3IFJlZ0V4cChzZXBhcmF0b3Iuc291cmNlLCBmbGFncyArICdnJyk7XG4gICAgICB2YXIgc2VwYXJhdG9yMiwgbWF0Y2gsIGxhc3RJbmRleCwgbGFzdExlbmd0aCwgaTtcbiAgICAgIC8vIERvZXNuJ3QgbmVlZCBmbGFncyBneSwgYnV0IHRoZXkgZG9uJ3QgaHVydFxuICAgICAgaWYoIU5QQ0cpc2VwYXJhdG9yMiA9IG5ldyBSZWdFeHAoJ14nICsgc2VwYXJhdG9yQ29weS5zb3VyY2UgKyAnJCg/IVxcXFxzKScsIGZsYWdzKTtcbiAgICAgIHdoaWxlKG1hdGNoID0gc2VwYXJhdG9yQ29weS5leGVjKHN0cmluZykpe1xuICAgICAgICAvLyBgc2VwYXJhdG9yQ29weS5sYXN0SW5kZXhgIGlzIG5vdCByZWxpYWJsZSBjcm9zcy1icm93c2VyXG4gICAgICAgIGxhc3RJbmRleCA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF1bTEVOR1RIXTtcbiAgICAgICAgaWYobGFzdEluZGV4ID4gbGFzdExhc3RJbmRleCl7XG4gICAgICAgICAgb3V0cHV0LnB1c2goc3RyaW5nLnNsaWNlKGxhc3RMYXN0SW5kZXgsIG1hdGNoLmluZGV4KSk7XG4gICAgICAgICAgLy8gRml4IGJyb3dzZXJzIHdob3NlIGBleGVjYCBtZXRob2RzIGRvbid0IGNvbnNpc3RlbnRseSByZXR1cm4gYHVuZGVmaW5lZGAgZm9yIE5QQ0dcbiAgICAgICAgICBpZighTlBDRyAmJiBtYXRjaFtMRU5HVEhdID4gMSltYXRjaFswXS5yZXBsYWNlKHNlcGFyYXRvcjIsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBmb3IoaSA9IDE7IGkgPCBhcmd1bWVudHNbTEVOR1RIXSAtIDI7IGkrKylpZihhcmd1bWVudHNbaV0gPT09IHVuZGVmaW5lZCltYXRjaFtpXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZihtYXRjaFtMRU5HVEhdID4gMSAmJiBtYXRjaC5pbmRleCA8IHN0cmluZ1tMRU5HVEhdKSRwdXNoLmFwcGx5KG91dHB1dCwgbWF0Y2guc2xpY2UoMSkpO1xuICAgICAgICAgIGxhc3RMZW5ndGggPSBtYXRjaFswXVtMRU5HVEhdO1xuICAgICAgICAgIGxhc3RMYXN0SW5kZXggPSBsYXN0SW5kZXg7XG4gICAgICAgICAgaWYob3V0cHV0W0xFTkdUSF0gPj0gc3BsaXRMaW1pdClicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZihzZXBhcmF0b3JDb3B5W0xBU1RfSU5ERVhdID09PSBtYXRjaC5pbmRleClzZXBhcmF0b3JDb3B5W0xBU1RfSU5ERVhdKys7IC8vIEF2b2lkIGFuIGluZmluaXRlIGxvb3BcbiAgICAgIH1cbiAgICAgIGlmKGxhc3RMYXN0SW5kZXggPT09IHN0cmluZ1tMRU5HVEhdKXtcbiAgICAgICAgaWYobGFzdExlbmd0aCB8fCAhc2VwYXJhdG9yQ29weS50ZXN0KCcnKSlvdXRwdXQucHVzaCgnJyk7XG4gICAgICB9IGVsc2Ugb3V0cHV0LnB1c2goc3RyaW5nLnNsaWNlKGxhc3RMYXN0SW5kZXgpKTtcbiAgICAgIHJldHVybiBvdXRwdXRbTEVOR1RIXSA+IHNwbGl0TGltaXQgPyBvdXRwdXQuc2xpY2UoMCwgc3BsaXRMaW1pdCkgOiBvdXRwdXQ7XG4gICAgfTtcbiAgLy8gQ2hha3JhLCBWOFxuICB9IGVsc2UgaWYoJzAnWyRTUExJVF0odW5kZWZpbmVkLCAwKVtMRU5HVEhdKXtcbiAgICAkc3BsaXQgPSBmdW5jdGlvbihzZXBhcmF0b3IsIGxpbWl0KXtcbiAgICAgIHJldHVybiBzZXBhcmF0b3IgPT09IHVuZGVmaW5lZCAmJiBsaW1pdCA9PT0gMCA/IFtdIDogX3NwbGl0LmNhbGwodGhpcywgc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgfTtcbiAgfVxuICAvLyAyMS4xLjMuMTcgU3RyaW5nLnByb3RvdHlwZS5zcGxpdChzZXBhcmF0b3IsIGxpbWl0KVxuICByZXR1cm4gW2Z1bmN0aW9uIHNwbGl0KHNlcGFyYXRvciwgbGltaXQpe1xuICAgIHZhciBPICA9IGRlZmluZWQodGhpcylcbiAgICAgICwgZm4gPSBzZXBhcmF0b3IgPT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogc2VwYXJhdG9yW1NQTElUXTtcbiAgICByZXR1cm4gZm4gIT09IHVuZGVmaW5lZCA/IGZuLmNhbGwoc2VwYXJhdG9yLCBPLCBsaW1pdCkgOiAkc3BsaXQuY2FsbChTdHJpbmcoTyksIHNlcGFyYXRvciwgbGltaXQpO1xuICB9LCAkc3BsaXRdO1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAuc3BsaXQuanNcbiAqKiBtb2R1bGUgaWQgPSAyMDRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciBMSUJSQVJZICAgICAgICAgICAgPSByZXF1aXJlKCcuL19saWJyYXJ5JylcbiAgLCBnbG9iYWwgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGN0eCAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2N0eCcpXG4gICwgY2xhc3NvZiAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpXG4gICwgJGV4cG9ydCAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBpc09iamVjdCAgICAgICAgICAgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGFuT2JqZWN0ICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgYUZ1bmN0aW9uICAgICAgICAgID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpXG4gICwgYW5JbnN0YW5jZSAgICAgICAgID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKVxuICAsIGZvck9mICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2Zvci1vZicpXG4gICwgc2V0UHJvdG8gICAgICAgICAgID0gcmVxdWlyZSgnLi9fc2V0LXByb3RvJykuc2V0XG4gICwgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fc3BlY2llcy1jb25zdHJ1Y3RvcicpXG4gICwgdGFzayAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fdGFzaycpLnNldFxuICAsIG1pY3JvdGFzayAgICAgICAgICA9IHJlcXVpcmUoJy4vX21pY3JvdGFzaycpKClcbiAgLCBQUk9NSVNFICAgICAgICAgICAgPSAnUHJvbWlzZSdcbiAgLCBUeXBlRXJyb3IgICAgICAgICAgPSBnbG9iYWwuVHlwZUVycm9yXG4gICwgcHJvY2VzcyAgICAgICAgICAgID0gZ2xvYmFsLnByb2Nlc3NcbiAgLCAkUHJvbWlzZSAgICAgICAgICAgPSBnbG9iYWxbUFJPTUlTRV1cbiAgLCBwcm9jZXNzICAgICAgICAgICAgPSBnbG9iYWwucHJvY2Vzc1xuICAsIGlzTm9kZSAgICAgICAgICAgICA9IGNsYXNzb2YocHJvY2VzcykgPT0gJ3Byb2Nlc3MnXG4gICwgZW1wdHkgICAgICAgICAgICAgID0gZnVuY3Rpb24oKXsgLyogZW1wdHkgKi8gfVxuICAsIEludGVybmFsLCBHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHksIFdyYXBwZXI7XG5cbnZhciBVU0VfTkFUSVZFID0gISFmdW5jdGlvbigpe1xuICB0cnkge1xuICAgIC8vIGNvcnJlY3Qgc3ViY2xhc3Npbmcgd2l0aCBAQHNwZWNpZXMgc3VwcG9ydFxuICAgIHZhciBwcm9taXNlICAgICA9ICRQcm9taXNlLnJlc29sdmUoMSlcbiAgICAgICwgRmFrZVByb21pc2UgPSAocHJvbWlzZS5jb25zdHJ1Y3RvciA9IHt9KVtyZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpXSA9IGZ1bmN0aW9uKGV4ZWMpeyBleGVjKGVtcHR5LCBlbXB0eSk7IH07XG4gICAgLy8gdW5oYW5kbGVkIHJlamVjdGlvbnMgdHJhY2tpbmcgc3VwcG9ydCwgTm9kZUpTIFByb21pc2Ugd2l0aG91dCBpdCBmYWlscyBAQHNwZWNpZXMgdGVzdFxuICAgIHJldHVybiAoaXNOb2RlIHx8IHR5cGVvZiBQcm9taXNlUmVqZWN0aW9uRXZlbnQgPT0gJ2Z1bmN0aW9uJykgJiYgcHJvbWlzZS50aGVuKGVtcHR5KSBpbnN0YW5jZW9mIEZha2VQcm9taXNlO1xuICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG59KCk7XG5cbi8vIGhlbHBlcnNcbnZhciBzYW1lQ29uc3RydWN0b3IgPSBmdW5jdGlvbihhLCBiKXtcbiAgLy8gd2l0aCBsaWJyYXJ5IHdyYXBwZXIgc3BlY2lhbCBjYXNlXG4gIHJldHVybiBhID09PSBiIHx8IGEgPT09ICRQcm9taXNlICYmIGIgPT09IFdyYXBwZXI7XG59O1xudmFyIGlzVGhlbmFibGUgPSBmdW5jdGlvbihpdCl7XG4gIHZhciB0aGVuO1xuICByZXR1cm4gaXNPYmplY3QoaXQpICYmIHR5cGVvZiAodGhlbiA9IGl0LnRoZW4pID09ICdmdW5jdGlvbicgPyB0aGVuIDogZmFsc2U7XG59O1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24oQyl7XG4gIHJldHVybiBzYW1lQ29uc3RydWN0b3IoJFByb21pc2UsIEMpXG4gICAgPyBuZXcgUHJvbWlzZUNhcGFiaWxpdHkoQylcbiAgICA6IG5ldyBHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHkoQyk7XG59O1xudmFyIFByb21pc2VDYXBhYmlsaXR5ID0gR2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24oQyl7XG4gIHZhciByZXNvbHZlLCByZWplY3Q7XG4gIHRoaXMucHJvbWlzZSA9IG5ldyBDKGZ1bmN0aW9uKCQkcmVzb2x2ZSwgJCRyZWplY3Qpe1xuICAgIGlmKHJlc29sdmUgIT09IHVuZGVmaW5lZCB8fCByZWplY3QgIT09IHVuZGVmaW5lZCl0aHJvdyBUeXBlRXJyb3IoJ0JhZCBQcm9taXNlIGNvbnN0cnVjdG9yJyk7XG4gICAgcmVzb2x2ZSA9ICQkcmVzb2x2ZTtcbiAgICByZWplY3QgID0gJCRyZWplY3Q7XG4gIH0pO1xuICB0aGlzLnJlc29sdmUgPSBhRnVuY3Rpb24ocmVzb2x2ZSk7XG4gIHRoaXMucmVqZWN0ICA9IGFGdW5jdGlvbihyZWplY3QpO1xufTtcbnZhciBwZXJmb3JtID0gZnVuY3Rpb24oZXhlYyl7XG4gIHRyeSB7XG4gICAgZXhlYygpO1xuICB9IGNhdGNoKGUpe1xuICAgIHJldHVybiB7ZXJyb3I6IGV9O1xuICB9XG59O1xudmFyIG5vdGlmeSA9IGZ1bmN0aW9uKHByb21pc2UsIGlzUmVqZWN0KXtcbiAgaWYocHJvbWlzZS5fbilyZXR1cm47XG4gIHByb21pc2UuX24gPSB0cnVlO1xuICB2YXIgY2hhaW4gPSBwcm9taXNlLl9jO1xuICBtaWNyb3Rhc2soZnVuY3Rpb24oKXtcbiAgICB2YXIgdmFsdWUgPSBwcm9taXNlLl92XG4gICAgICAsIG9rICAgID0gcHJvbWlzZS5fcyA9PSAxXG4gICAgICAsIGkgICAgID0gMDtcbiAgICB2YXIgcnVuID0gZnVuY3Rpb24ocmVhY3Rpb24pe1xuICAgICAgdmFyIGhhbmRsZXIgPSBvayA/IHJlYWN0aW9uLm9rIDogcmVhY3Rpb24uZmFpbFxuICAgICAgICAsIHJlc29sdmUgPSByZWFjdGlvbi5yZXNvbHZlXG4gICAgICAgICwgcmVqZWN0ICA9IHJlYWN0aW9uLnJlamVjdFxuICAgICAgICAsIGRvbWFpbiAgPSByZWFjdGlvbi5kb21haW5cbiAgICAgICAgLCByZXN1bHQsIHRoZW47XG4gICAgICB0cnkge1xuICAgICAgICBpZihoYW5kbGVyKXtcbiAgICAgICAgICBpZighb2spe1xuICAgICAgICAgICAgaWYocHJvbWlzZS5faCA9PSAyKW9uSGFuZGxlVW5oYW5kbGVkKHByb21pc2UpO1xuICAgICAgICAgICAgcHJvbWlzZS5faCA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKGhhbmRsZXIgPT09IHRydWUpcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZihkb21haW4pZG9tYWluLmVudGVyKCk7XG4gICAgICAgICAgICByZXN1bHQgPSBoYW5kbGVyKHZhbHVlKTtcbiAgICAgICAgICAgIGlmKGRvbWFpbilkb21haW4uZXhpdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZihyZXN1bHQgPT09IHJlYWN0aW9uLnByb21pc2Upe1xuICAgICAgICAgICAgcmVqZWN0KFR5cGVFcnJvcignUHJvbWlzZS1jaGFpbiBjeWNsZScpKTtcbiAgICAgICAgICB9IGVsc2UgaWYodGhlbiA9IGlzVGhlbmFibGUocmVzdWx0KSl7XG4gICAgICAgICAgICB0aGVuLmNhbGwocmVzdWx0LCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0gZWxzZSByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0gZWxzZSByZWplY3QodmFsdWUpO1xuICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgd2hpbGUoY2hhaW4ubGVuZ3RoID4gaSlydW4oY2hhaW5baSsrXSk7IC8vIHZhcmlhYmxlIGxlbmd0aCAtIGNhbid0IHVzZSBmb3JFYWNoXG4gICAgcHJvbWlzZS5fYyA9IFtdO1xuICAgIHByb21pc2UuX24gPSBmYWxzZTtcbiAgICBpZihpc1JlamVjdCAmJiAhcHJvbWlzZS5faClvblVuaGFuZGxlZChwcm9taXNlKTtcbiAgfSk7XG59O1xudmFyIG9uVW5oYW5kbGVkID0gZnVuY3Rpb24ocHJvbWlzZSl7XG4gIHRhc2suY2FsbChnbG9iYWwsIGZ1bmN0aW9uKCl7XG4gICAgdmFyIHZhbHVlID0gcHJvbWlzZS5fdlxuICAgICAgLCBhYnJ1cHQsIGhhbmRsZXIsIGNvbnNvbGU7XG4gICAgaWYoaXNVbmhhbmRsZWQocHJvbWlzZSkpe1xuICAgICAgYWJydXB0ID0gcGVyZm9ybShmdW5jdGlvbigpe1xuICAgICAgICBpZihpc05vZGUpe1xuICAgICAgICAgIHByb2Nlc3MuZW1pdCgndW5oYW5kbGVkUmVqZWN0aW9uJywgdmFsdWUsIHByb21pc2UpO1xuICAgICAgICB9IGVsc2UgaWYoaGFuZGxlciA9IGdsb2JhbC5vbnVuaGFuZGxlZHJlamVjdGlvbil7XG4gICAgICAgICAgaGFuZGxlcih7cHJvbWlzZTogcHJvbWlzZSwgcmVhc29uOiB2YWx1ZX0pO1xuICAgICAgICB9IGVsc2UgaWYoKGNvbnNvbGUgPSBnbG9iYWwuY29uc29sZSkgJiYgY29uc29sZS5lcnJvcil7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignVW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uJywgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIC8vIEJyb3dzZXJzIHNob3VsZCBub3QgdHJpZ2dlciBgcmVqZWN0aW9uSGFuZGxlZGAgZXZlbnQgaWYgaXQgd2FzIGhhbmRsZWQgaGVyZSwgTm9kZUpTIC0gc2hvdWxkXG4gICAgICBwcm9taXNlLl9oID0gaXNOb2RlIHx8IGlzVW5oYW5kbGVkKHByb21pc2UpID8gMiA6IDE7XG4gICAgfSBwcm9taXNlLl9hID0gdW5kZWZpbmVkO1xuICAgIGlmKGFicnVwdCl0aHJvdyBhYnJ1cHQuZXJyb3I7XG4gIH0pO1xufTtcbnZhciBpc1VuaGFuZGxlZCA9IGZ1bmN0aW9uKHByb21pc2Upe1xuICBpZihwcm9taXNlLl9oID09IDEpcmV0dXJuIGZhbHNlO1xuICB2YXIgY2hhaW4gPSBwcm9taXNlLl9hIHx8IHByb21pc2UuX2NcbiAgICAsIGkgICAgID0gMFxuICAgICwgcmVhY3Rpb247XG4gIHdoaWxlKGNoYWluLmxlbmd0aCA+IGkpe1xuICAgIHJlYWN0aW9uID0gY2hhaW5baSsrXTtcbiAgICBpZihyZWFjdGlvbi5mYWlsIHx8ICFpc1VuaGFuZGxlZChyZWFjdGlvbi5wcm9taXNlKSlyZXR1cm4gZmFsc2U7XG4gIH0gcmV0dXJuIHRydWU7XG59O1xudmFyIG9uSGFuZGxlVW5oYW5kbGVkID0gZnVuY3Rpb24ocHJvbWlzZSl7XG4gIHRhc2suY2FsbChnbG9iYWwsIGZ1bmN0aW9uKCl7XG4gICAgdmFyIGhhbmRsZXI7XG4gICAgaWYoaXNOb2RlKXtcbiAgICAgIHByb2Nlc3MuZW1pdCgncmVqZWN0aW9uSGFuZGxlZCcsIHByb21pc2UpO1xuICAgIH0gZWxzZSBpZihoYW5kbGVyID0gZ2xvYmFsLm9ucmVqZWN0aW9uaGFuZGxlZCl7XG4gICAgICBoYW5kbGVyKHtwcm9taXNlOiBwcm9taXNlLCByZWFzb246IHByb21pc2UuX3Z9KTtcbiAgICB9XG4gIH0pO1xufTtcbnZhciAkcmVqZWN0ID0gZnVuY3Rpb24odmFsdWUpe1xuICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gIGlmKHByb21pc2UuX2QpcmV0dXJuO1xuICBwcm9taXNlLl9kID0gdHJ1ZTtcbiAgcHJvbWlzZSA9IHByb21pc2UuX3cgfHwgcHJvbWlzZTsgLy8gdW53cmFwXG4gIHByb21pc2UuX3YgPSB2YWx1ZTtcbiAgcHJvbWlzZS5fcyA9IDI7XG4gIGlmKCFwcm9taXNlLl9hKXByb21pc2UuX2EgPSBwcm9taXNlLl9jLnNsaWNlKCk7XG4gIG5vdGlmeShwcm9taXNlLCB0cnVlKTtcbn07XG52YXIgJHJlc29sdmUgPSBmdW5jdGlvbih2YWx1ZSl7XG4gIHZhciBwcm9taXNlID0gdGhpc1xuICAgICwgdGhlbjtcbiAgaWYocHJvbWlzZS5fZClyZXR1cm47XG4gIHByb21pc2UuX2QgPSB0cnVlO1xuICBwcm9taXNlID0gcHJvbWlzZS5fdyB8fCBwcm9taXNlOyAvLyB1bndyYXBcbiAgdHJ5IHtcbiAgICBpZihwcm9taXNlID09PSB2YWx1ZSl0aHJvdyBUeXBlRXJyb3IoXCJQcm9taXNlIGNhbid0IGJlIHJlc29sdmVkIGl0c2VsZlwiKTtcbiAgICBpZih0aGVuID0gaXNUaGVuYWJsZSh2YWx1ZSkpe1xuICAgICAgbWljcm90YXNrKGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciB3cmFwcGVyID0ge193OiBwcm9taXNlLCBfZDogZmFsc2V9OyAvLyB3cmFwXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhlbi5jYWxsKHZhbHVlLCBjdHgoJHJlc29sdmUsIHdyYXBwZXIsIDEpLCBjdHgoJHJlamVjdCwgd3JhcHBlciwgMSkpO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICRyZWplY3QuY2FsbCh3cmFwcGVyLCBlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb21pc2UuX3YgPSB2YWx1ZTtcbiAgICAgIHByb21pc2UuX3MgPSAxO1xuICAgICAgbm90aWZ5KHByb21pc2UsIGZhbHNlKTtcbiAgICB9XG4gIH0gY2F0Y2goZSl7XG4gICAgJHJlamVjdC5jYWxsKHtfdzogcHJvbWlzZSwgX2Q6IGZhbHNlfSwgZSk7IC8vIHdyYXBcbiAgfVxufTtcblxuLy8gY29uc3RydWN0b3IgcG9seWZpbGxcbmlmKCFVU0VfTkFUSVZFKXtcbiAgLy8gMjUuNC4zLjEgUHJvbWlzZShleGVjdXRvcilcbiAgJFByb21pc2UgPSBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKXtcbiAgICBhbkluc3RhbmNlKHRoaXMsICRQcm9taXNlLCBQUk9NSVNFLCAnX2gnKTtcbiAgICBhRnVuY3Rpb24oZXhlY3V0b3IpO1xuICAgIEludGVybmFsLmNhbGwodGhpcyk7XG4gICAgdHJ5IHtcbiAgICAgIGV4ZWN1dG9yKGN0eCgkcmVzb2x2ZSwgdGhpcywgMSksIGN0eCgkcmVqZWN0LCB0aGlzLCAxKSk7XG4gICAgfSBjYXRjaChlcnIpe1xuICAgICAgJHJlamVjdC5jYWxsKHRoaXMsIGVycik7XG4gICAgfVxuICB9O1xuICBJbnRlcm5hbCA9IGZ1bmN0aW9uIFByb21pc2UoZXhlY3V0b3Ipe1xuICAgIHRoaXMuX2MgPSBbXTsgICAgICAgICAgICAgLy8gPC0gYXdhaXRpbmcgcmVhY3Rpb25zXG4gICAgdGhpcy5fYSA9IHVuZGVmaW5lZDsgICAgICAvLyA8LSBjaGVja2VkIGluIGlzVW5oYW5kbGVkIHJlYWN0aW9uc1xuICAgIHRoaXMuX3MgPSAwOyAgICAgICAgICAgICAgLy8gPC0gc3RhdGVcbiAgICB0aGlzLl9kID0gZmFsc2U7ICAgICAgICAgIC8vIDwtIGRvbmVcbiAgICB0aGlzLl92ID0gdW5kZWZpbmVkOyAgICAgIC8vIDwtIHZhbHVlXG4gICAgdGhpcy5faCA9IDA7ICAgICAgICAgICAgICAvLyA8LSByZWplY3Rpb24gc3RhdGUsIDAgLSBkZWZhdWx0LCAxIC0gaGFuZGxlZCwgMiAtIHVuaGFuZGxlZFxuICAgIHRoaXMuX24gPSBmYWxzZTsgICAgICAgICAgLy8gPC0gbm90aWZ5XG4gIH07XG4gIEludGVybmFsLnByb3RvdHlwZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpKCRQcm9taXNlLnByb3RvdHlwZSwge1xuICAgIC8vIDI1LjQuNS4zIFByb21pc2UucHJvdG90eXBlLnRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpXG4gICAgdGhlbjogZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCl7XG4gICAgICB2YXIgcmVhY3Rpb24gICAgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShzcGVjaWVzQ29uc3RydWN0b3IodGhpcywgJFByb21pc2UpKTtcbiAgICAgIHJlYWN0aW9uLm9rICAgICA9IHR5cGVvZiBvbkZ1bGZpbGxlZCA9PSAnZnVuY3Rpb24nID8gb25GdWxmaWxsZWQgOiB0cnVlO1xuICAgICAgcmVhY3Rpb24uZmFpbCAgID0gdHlwZW9mIG9uUmVqZWN0ZWQgPT0gJ2Z1bmN0aW9uJyAmJiBvblJlamVjdGVkO1xuICAgICAgcmVhY3Rpb24uZG9tYWluID0gaXNOb2RlID8gcHJvY2Vzcy5kb21haW4gOiB1bmRlZmluZWQ7XG4gICAgICB0aGlzLl9jLnB1c2gocmVhY3Rpb24pO1xuICAgICAgaWYodGhpcy5fYSl0aGlzLl9hLnB1c2gocmVhY3Rpb24pO1xuICAgICAgaWYodGhpcy5fcylub3RpZnkodGhpcywgZmFsc2UpO1xuICAgICAgcmV0dXJuIHJlYWN0aW9uLnByb21pc2U7XG4gICAgfSxcbiAgICAvLyAyNS40LjUuMSBQcm9taXNlLnByb3RvdHlwZS5jYXRjaChvblJlamVjdGVkKVxuICAgICdjYXRjaCc6IGZ1bmN0aW9uKG9uUmVqZWN0ZWQpe1xuICAgICAgcmV0dXJuIHRoaXMudGhlbih1bmRlZmluZWQsIG9uUmVqZWN0ZWQpO1xuICAgIH1cbiAgfSk7XG4gIFByb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgcHJvbWlzZSAgPSBuZXcgSW50ZXJuYWw7XG4gICAgdGhpcy5wcm9taXNlID0gcHJvbWlzZTtcbiAgICB0aGlzLnJlc29sdmUgPSBjdHgoJHJlc29sdmUsIHByb21pc2UsIDEpO1xuICAgIHRoaXMucmVqZWN0ICA9IGN0eCgkcmVqZWN0LCBwcm9taXNlLCAxKTtcbiAgfTtcbn1cblxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwge1Byb21pc2U6ICRQcm9taXNlfSk7XG5yZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpKCRQcm9taXNlLCBQUk9NSVNFKTtcbnJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJykoUFJPTUlTRSk7XG5XcmFwcGVyID0gcmVxdWlyZSgnLi9fY29yZScpW1BST01JU0VdO1xuXG4vLyBzdGF0aWNzXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC41IFByb21pc2UucmVqZWN0KHIpXG4gIHJlamVjdDogZnVuY3Rpb24gcmVqZWN0KHIpe1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkodGhpcylcbiAgICAgICwgJCRyZWplY3QgICA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgICQkcmVqZWN0KHIpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pO1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoTElCUkFSWSB8fCAhVVNFX05BVElWRSksIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjYgUHJvbWlzZS5yZXNvbHZlKHgpXG4gIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUoeCl7XG4gICAgLy8gaW5zdGFuY2VvZiBpbnN0ZWFkIG9mIGludGVybmFsIHNsb3QgY2hlY2sgYmVjYXVzZSB3ZSBzaG91bGQgZml4IGl0IHdpdGhvdXQgcmVwbGFjZW1lbnQgbmF0aXZlIFByb21pc2UgY29yZVxuICAgIGlmKHggaW5zdGFuY2VvZiAkUHJvbWlzZSAmJiBzYW1lQ29uc3RydWN0b3IoeC5jb25zdHJ1Y3RvciwgdGhpcykpcmV0dXJuIHg7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSh0aGlzKVxuICAgICAgLCAkJHJlc29sdmUgID0gY2FwYWJpbGl0eS5yZXNvbHZlO1xuICAgICQkcmVzb2x2ZSh4KTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTtcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIShVU0VfTkFUSVZFICYmIHJlcXVpcmUoJy4vX2l0ZXItZGV0ZWN0JykoZnVuY3Rpb24oaXRlcil7XG4gICRQcm9taXNlLmFsbChpdGVyKVsnY2F0Y2gnXShlbXB0eSk7XG59KSksIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjEgUHJvbWlzZS5hbGwoaXRlcmFibGUpXG4gIGFsbDogZnVuY3Rpb24gYWxsKGl0ZXJhYmxlKXtcbiAgICB2YXIgQyAgICAgICAgICA9IHRoaXNcbiAgICAgICwgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KEMpXG4gICAgICAsIHJlc29sdmUgICAgPSBjYXBhYmlsaXR5LnJlc29sdmVcbiAgICAgICwgcmVqZWN0ICAgICA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgIHZhciBhYnJ1cHQgPSBwZXJmb3JtKGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgdmFsdWVzICAgID0gW11cbiAgICAgICAgLCBpbmRleCAgICAgPSAwXG4gICAgICAgICwgcmVtYWluaW5nID0gMTtcbiAgICAgIGZvck9mKGl0ZXJhYmxlLCBmYWxzZSwgZnVuY3Rpb24ocHJvbWlzZSl7XG4gICAgICAgIHZhciAkaW5kZXggICAgICAgID0gaW5kZXgrK1xuICAgICAgICAgICwgYWxyZWFkeUNhbGxlZCA9IGZhbHNlO1xuICAgICAgICB2YWx1ZXMucHVzaCh1bmRlZmluZWQpO1xuICAgICAgICByZW1haW5pbmcrKztcbiAgICAgICAgQy5yZXNvbHZlKHByb21pc2UpLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgICAgICAgIGlmKGFscmVhZHlDYWxsZWQpcmV0dXJuO1xuICAgICAgICAgIGFscmVhZHlDYWxsZWQgID0gdHJ1ZTtcbiAgICAgICAgICB2YWx1ZXNbJGluZGV4XSA9IHZhbHVlO1xuICAgICAgICAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUodmFsdWVzKTtcbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgIH0pO1xuICAgICAgLS1yZW1haW5pbmcgfHwgcmVzb2x2ZSh2YWx1ZXMpO1xuICAgIH0pO1xuICAgIGlmKGFicnVwdClyZWplY3QoYWJydXB0LmVycm9yKTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9LFxuICAvLyAyNS40LjQuNCBQcm9taXNlLnJhY2UoaXRlcmFibGUpXG4gIHJhY2U6IGZ1bmN0aW9uIHJhY2UoaXRlcmFibGUpe1xuICAgIHZhciBDICAgICAgICAgID0gdGhpc1xuICAgICAgLCBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkoQylcbiAgICAgICwgcmVqZWN0ICAgICA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgIHZhciBhYnJ1cHQgPSBwZXJmb3JtKGZ1bmN0aW9uKCl7XG4gICAgICBmb3JPZihpdGVyYWJsZSwgZmFsc2UsIGZ1bmN0aW9uKHByb21pc2Upe1xuICAgICAgICBDLnJlc29sdmUocHJvbWlzZSkudGhlbihjYXBhYmlsaXR5LnJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBpZihhYnJ1cHQpcmVqZWN0KGFicnVwdC5lcnJvcik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5wcm9taXNlLmpzXG4gKiogbW9kdWxlIGlkID0gMjA1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgY3R4ICAgICAgICAgPSByZXF1aXJlKCcuL19jdHgnKVxuICAsIGNhbGwgICAgICAgID0gcmVxdWlyZSgnLi9faXRlci1jYWxsJylcbiAgLCBpc0FycmF5SXRlciA9IHJlcXVpcmUoJy4vX2lzLWFycmF5LWl0ZXInKVxuICAsIGFuT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCB0b0xlbmd0aCAgICA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpXG4gICwgZ2V0SXRlckZuICAgPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpXG4gICwgQlJFQUsgICAgICAgPSB7fVxuICAsIFJFVFVSTiAgICAgID0ge307XG52YXIgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXRlcmFibGUsIGVudHJpZXMsIGZuLCB0aGF0LCBJVEVSQVRPUil7XG4gIHZhciBpdGVyRm4gPSBJVEVSQVRPUiA/IGZ1bmN0aW9uKCl7IHJldHVybiBpdGVyYWJsZTsgfSA6IGdldEl0ZXJGbihpdGVyYWJsZSlcbiAgICAsIGYgICAgICA9IGN0eChmbiwgdGhhdCwgZW50cmllcyA/IDIgOiAxKVxuICAgICwgaW5kZXggID0gMFxuICAgICwgbGVuZ3RoLCBzdGVwLCBpdGVyYXRvciwgcmVzdWx0O1xuICBpZih0eXBlb2YgaXRlckZuICE9ICdmdW5jdGlvbicpdGhyb3cgVHlwZUVycm9yKGl0ZXJhYmxlICsgJyBpcyBub3QgaXRlcmFibGUhJyk7XG4gIC8vIGZhc3QgY2FzZSBmb3IgYXJyYXlzIHdpdGggZGVmYXVsdCBpdGVyYXRvclxuICBpZihpc0FycmF5SXRlcihpdGVyRm4pKWZvcihsZW5ndGggPSB0b0xlbmd0aChpdGVyYWJsZS5sZW5ndGgpOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKyl7XG4gICAgcmVzdWx0ID0gZW50cmllcyA/IGYoYW5PYmplY3Qoc3RlcCA9IGl0ZXJhYmxlW2luZGV4XSlbMF0sIHN0ZXBbMV0pIDogZihpdGVyYWJsZVtpbmRleF0pO1xuICAgIGlmKHJlc3VsdCA9PT0gQlJFQUsgfHwgcmVzdWx0ID09PSBSRVRVUk4pcmV0dXJuIHJlc3VsdDtcbiAgfSBlbHNlIGZvcihpdGVyYXRvciA9IGl0ZXJGbi5jYWxsKGl0ZXJhYmxlKTsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOyApe1xuICAgIHJlc3VsdCA9IGNhbGwoaXRlcmF0b3IsIGYsIHN0ZXAudmFsdWUsIGVudHJpZXMpO1xuICAgIGlmKHJlc3VsdCA9PT0gQlJFQUsgfHwgcmVzdWx0ID09PSBSRVRVUk4pcmV0dXJuIHJlc3VsdDtcbiAgfVxufTtcbmV4cG9ydHMuQlJFQUsgID0gQlJFQUs7XG5leHBvcnRzLlJFVFVSTiA9IFJFVFVSTjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2Zvci1vZi5qc1xuICoqIG1vZHVsZSBpZCA9IDIwNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gNy4zLjIwIFNwZWNpZXNDb25zdHJ1Y3RvcihPLCBkZWZhdWx0Q29uc3RydWN0b3IpXG52YXIgYW5PYmplY3QgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJylcbiAgLCBTUEVDSUVTICAgPSByZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihPLCBEKXtcbiAgdmFyIEMgPSBhbk9iamVjdChPKS5jb25zdHJ1Y3RvciwgUztcbiAgcmV0dXJuIEMgPT09IHVuZGVmaW5lZCB8fCAoUyA9IGFuT2JqZWN0KEMpW1NQRUNJRVNdKSA9PSB1bmRlZmluZWQgPyBEIDogYUZ1bmN0aW9uKFMpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX3NwZWNpZXMtY29uc3RydWN0b3IuanNcbiAqKiBtb2R1bGUgaWQgPSAyMDdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBjdHggICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19jdHgnKVxuICAsIGludm9rZSAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2ludm9rZScpXG4gICwgaHRtbCAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faHRtbCcpXG4gICwgY2VsICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpXG4gICwgZ2xvYmFsICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBwcm9jZXNzICAgICAgICAgICAgPSBnbG9iYWwucHJvY2Vzc1xuICAsIHNldFRhc2sgICAgICAgICAgICA9IGdsb2JhbC5zZXRJbW1lZGlhdGVcbiAgLCBjbGVhclRhc2sgICAgICAgICAgPSBnbG9iYWwuY2xlYXJJbW1lZGlhdGVcbiAgLCBNZXNzYWdlQ2hhbm5lbCAgICAgPSBnbG9iYWwuTWVzc2FnZUNoYW5uZWxcbiAgLCBjb3VudGVyICAgICAgICAgICAgPSAwXG4gICwgcXVldWUgICAgICAgICAgICAgID0ge31cbiAgLCBPTlJFQURZU1RBVEVDSEFOR0UgPSAnb25yZWFkeXN0YXRlY2hhbmdlJ1xuICAsIGRlZmVyLCBjaGFubmVsLCBwb3J0O1xudmFyIHJ1biA9IGZ1bmN0aW9uKCl7XG4gIHZhciBpZCA9ICt0aGlzO1xuICBpZihxdWV1ZS5oYXNPd25Qcm9wZXJ0eShpZCkpe1xuICAgIHZhciBmbiA9IHF1ZXVlW2lkXTtcbiAgICBkZWxldGUgcXVldWVbaWRdO1xuICAgIGZuKCk7XG4gIH1cbn07XG52YXIgbGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCl7XG4gIHJ1bi5jYWxsKGV2ZW50LmRhdGEpO1xufTtcbi8vIE5vZGUuanMgMC45KyAmIElFMTArIGhhcyBzZXRJbW1lZGlhdGUsIG90aGVyd2lzZTpcbmlmKCFzZXRUYXNrIHx8ICFjbGVhclRhc2spe1xuICBzZXRUYXNrID0gZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGZuKXtcbiAgICB2YXIgYXJncyA9IFtdLCBpID0gMTtcbiAgICB3aGlsZShhcmd1bWVudHMubGVuZ3RoID4gaSlhcmdzLnB1c2goYXJndW1lbnRzW2krK10pO1xuICAgIHF1ZXVlWysrY291bnRlcl0gPSBmdW5jdGlvbigpe1xuICAgICAgaW52b2tlKHR5cGVvZiBmbiA9PSAnZnVuY3Rpb24nID8gZm4gOiBGdW5jdGlvbihmbiksIGFyZ3MpO1xuICAgIH07XG4gICAgZGVmZXIoY291bnRlcik7XG4gICAgcmV0dXJuIGNvdW50ZXI7XG4gIH07XG4gIGNsZWFyVGFzayA9IGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGlkKXtcbiAgICBkZWxldGUgcXVldWVbaWRdO1xuICB9O1xuICAvLyBOb2RlLmpzIDAuOC1cbiAgaWYocmVxdWlyZSgnLi9fY29mJykocHJvY2VzcykgPT0gJ3Byb2Nlc3MnKXtcbiAgICBkZWZlciA9IGZ1bmN0aW9uKGlkKXtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soY3R4KHJ1biwgaWQsIDEpKTtcbiAgICB9O1xuICAvLyBCcm93c2VycyB3aXRoIE1lc3NhZ2VDaGFubmVsLCBpbmNsdWRlcyBXZWJXb3JrZXJzXG4gIH0gZWxzZSBpZihNZXNzYWdlQ2hhbm5lbCl7XG4gICAgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbDtcbiAgICBwb3J0ICAgID0gY2hhbm5lbC5wb3J0MjtcbiAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGxpc3RlbmVyO1xuICAgIGRlZmVyID0gY3R4KHBvcnQucG9zdE1lc3NhZ2UsIHBvcnQsIDEpO1xuICAvLyBCcm93c2VycyB3aXRoIHBvc3RNZXNzYWdlLCBza2lwIFdlYldvcmtlcnNcbiAgLy8gSUU4IGhhcyBwb3N0TWVzc2FnZSwgYnV0IGl0J3Mgc3luYyAmIHR5cGVvZiBpdHMgcG9zdE1lc3NhZ2UgaXMgJ29iamVjdCdcbiAgfSBlbHNlIGlmKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyICYmIHR5cGVvZiBwb3N0TWVzc2FnZSA9PSAnZnVuY3Rpb24nICYmICFnbG9iYWwuaW1wb3J0U2NyaXB0cyl7XG4gICAgZGVmZXIgPSBmdW5jdGlvbihpZCl7XG4gICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoaWQgKyAnJywgJyonKTtcbiAgICB9O1xuICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbGlzdGVuZXIsIGZhbHNlKTtcbiAgLy8gSUU4LVxuICB9IGVsc2UgaWYoT05SRUFEWVNUQVRFQ0hBTkdFIGluIGNlbCgnc2NyaXB0Jykpe1xuICAgIGRlZmVyID0gZnVuY3Rpb24oaWQpe1xuICAgICAgaHRtbC5hcHBlbmRDaGlsZChjZWwoJ3NjcmlwdCcpKVtPTlJFQURZU1RBVEVDSEFOR0VdID0gZnVuY3Rpb24oKXtcbiAgICAgICAgaHRtbC5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgICAgICAgcnVuLmNhbGwoaWQpO1xuICAgICAgfTtcbiAgICB9O1xuICAvLyBSZXN0IG9sZCBicm93c2Vyc1xuICB9IGVsc2Uge1xuICAgIGRlZmVyID0gZnVuY3Rpb24oaWQpe1xuICAgICAgc2V0VGltZW91dChjdHgocnVuLCBpZCwgMSksIDApO1xuICAgIH07XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXQ6ICAgc2V0VGFzayxcbiAgY2xlYXI6IGNsZWFyVGFza1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX3Rhc2suanNcbiAqKiBtb2R1bGUgaWQgPSAyMDhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBnbG9iYWwgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIG1hY3JvdGFzayA9IHJlcXVpcmUoJy4vX3Rhc2snKS5zZXRcbiAgLCBPYnNlcnZlciAgPSBnbG9iYWwuTXV0YXRpb25PYnNlcnZlciB8fCBnbG9iYWwuV2ViS2l0TXV0YXRpb25PYnNlcnZlclxuICAsIHByb2Nlc3MgICA9IGdsb2JhbC5wcm9jZXNzXG4gICwgUHJvbWlzZSAgID0gZ2xvYmFsLlByb21pc2VcbiAgLCBpc05vZGUgICAgPSByZXF1aXJlKCcuL19jb2YnKShwcm9jZXNzKSA9PSAncHJvY2Vzcyc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKXtcbiAgdmFyIGhlYWQsIGxhc3QsIG5vdGlmeTtcblxuICB2YXIgZmx1c2ggPSBmdW5jdGlvbigpe1xuICAgIHZhciBwYXJlbnQsIGZuO1xuICAgIGlmKGlzTm9kZSAmJiAocGFyZW50ID0gcHJvY2Vzcy5kb21haW4pKXBhcmVudC5leGl0KCk7XG4gICAgd2hpbGUoaGVhZCl7XG4gICAgICBmbiAgID0gaGVhZC5mbjtcbiAgICAgIGhlYWQgPSBoZWFkLm5leHQ7XG4gICAgICB0cnkge1xuICAgICAgICBmbigpO1xuICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgaWYoaGVhZClub3RpZnkoKTtcbiAgICAgICAgZWxzZSBsYXN0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH0gbGFzdCA9IHVuZGVmaW5lZDtcbiAgICBpZihwYXJlbnQpcGFyZW50LmVudGVyKCk7XG4gIH07XG5cbiAgLy8gTm9kZS5qc1xuICBpZihpc05vZGUpe1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uKCl7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZsdXNoKTtcbiAgICB9O1xuICAvLyBicm93c2VycyB3aXRoIE11dGF0aW9uT2JzZXJ2ZXJcbiAgfSBlbHNlIGlmKE9ic2VydmVyKXtcbiAgICB2YXIgdG9nZ2xlID0gdHJ1ZVxuICAgICAgLCBub2RlICAgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gICAgbmV3IE9ic2VydmVyKGZsdXNoKS5vYnNlcnZlKG5vZGUsIHtjaGFyYWN0ZXJEYXRhOiB0cnVlfSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24oKXtcbiAgICAgIG5vZGUuZGF0YSA9IHRvZ2dsZSA9ICF0b2dnbGU7XG4gICAgfTtcbiAgLy8gZW52aXJvbm1lbnRzIHdpdGggbWF5YmUgbm9uLWNvbXBsZXRlbHkgY29ycmVjdCwgYnV0IGV4aXN0ZW50IFByb21pc2VcbiAgfSBlbHNlIGlmKFByb21pc2UgJiYgUHJvbWlzZS5yZXNvbHZlKXtcbiAgICB2YXIgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uKCl7XG4gICAgICBwcm9taXNlLnRoZW4oZmx1c2gpO1xuICAgIH07XG4gIC8vIGZvciBvdGhlciBlbnZpcm9ubWVudHMgLSBtYWNyb3Rhc2sgYmFzZWQgb246XG4gIC8vIC0gc2V0SW1tZWRpYXRlXG4gIC8vIC0gTWVzc2FnZUNoYW5uZWxcbiAgLy8gLSB3aW5kb3cucG9zdE1lc3NhZ1xuICAvLyAtIG9ucmVhZHlzdGF0ZWNoYW5nZVxuICAvLyAtIHNldFRpbWVvdXRcbiAgfSBlbHNlIHtcbiAgICBub3RpZnkgPSBmdW5jdGlvbigpe1xuICAgICAgLy8gc3RyYW5nZSBJRSArIHdlYnBhY2sgZGV2IHNlcnZlciBidWcgLSB1c2UgLmNhbGwoZ2xvYmFsKVxuICAgICAgbWFjcm90YXNrLmNhbGwoZ2xvYmFsLCBmbHVzaCk7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbihmbil7XG4gICAgdmFyIHRhc2sgPSB7Zm46IGZuLCBuZXh0OiB1bmRlZmluZWR9O1xuICAgIGlmKGxhc3QpbGFzdC5uZXh0ID0gdGFzaztcbiAgICBpZighaGVhZCl7XG4gICAgICBoZWFkID0gdGFzaztcbiAgICAgIG5vdGlmeSgpO1xuICAgIH0gbGFzdCA9IHRhc2s7XG4gIH07XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fbWljcm90YXNrLmpzXG4gKiogbW9kdWxlIGlkID0gMjA5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih0YXJnZXQsIHNyYywgc2FmZSl7XG4gIGZvcih2YXIga2V5IGluIHNyYylyZWRlZmluZSh0YXJnZXQsIGtleSwgc3JjW2tleV0sIHNhZmUpO1xuICByZXR1cm4gdGFyZ2V0O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX3JlZGVmaW5lLWFsbC5qc1xuICoqIG1vZHVsZSBpZCA9IDIxMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHN0cm9uZyA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24tc3Ryb25nJyk7XG5cbi8vIDIzLjEgTWFwIE9iamVjdHNcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbicpKCdNYXAnLCBmdW5jdGlvbihnZXQpe1xuICByZXR1cm4gZnVuY3Rpb24gTWFwKCl7IHJldHVybiBnZXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpOyB9O1xufSwge1xuICAvLyAyMy4xLjMuNiBNYXAucHJvdG90eXBlLmdldChrZXkpXG4gIGdldDogZnVuY3Rpb24gZ2V0KGtleSl7XG4gICAgdmFyIGVudHJ5ID0gc3Ryb25nLmdldEVudHJ5KHRoaXMsIGtleSk7XG4gICAgcmV0dXJuIGVudHJ5ICYmIGVudHJ5LnY7XG4gIH0sXG4gIC8vIDIzLjEuMy45IE1hcC5wcm90b3R5cGUuc2V0KGtleSwgdmFsdWUpXG4gIHNldDogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpe1xuICAgIHJldHVybiBzdHJvbmcuZGVmKHRoaXMsIGtleSA9PT0gMCA/IDAgOiBrZXksIHZhbHVlKTtcbiAgfVxufSwgc3Ryb25nLCB0cnVlKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hcC5qc1xuICoqIG1vZHVsZSBpZCA9IDIxMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGRQICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZlxuICAsIGNyZWF0ZSAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpXG4gICwgaGlkZSAgICAgICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgLCByZWRlZmluZUFsbCA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpXG4gICwgY3R4ICAgICAgICAgPSByZXF1aXJlKCcuL19jdHgnKVxuICAsIGFuSW5zdGFuY2UgID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKVxuICAsIGRlZmluZWQgICAgID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpXG4gICwgZm9yT2YgICAgICAgPSByZXF1aXJlKCcuL19mb3Itb2YnKVxuICAsICRpdGVyRGVmaW5lID0gcmVxdWlyZSgnLi9faXRlci1kZWZpbmUnKVxuICAsIHN0ZXAgICAgICAgID0gcmVxdWlyZSgnLi9faXRlci1zdGVwJylcbiAgLCBzZXRTcGVjaWVzICA9IHJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJylcbiAgLCBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJylcbiAgLCBmYXN0S2V5ICAgICA9IHJlcXVpcmUoJy4vX21ldGEnKS5mYXN0S2V5XG4gICwgU0laRSAgICAgICAgPSBERVNDUklQVE9SUyA/ICdfcycgOiAnc2l6ZSc7XG5cbnZhciBnZXRFbnRyeSA9IGZ1bmN0aW9uKHRoYXQsIGtleSl7XG4gIC8vIGZhc3QgY2FzZVxuICB2YXIgaW5kZXggPSBmYXN0S2V5KGtleSksIGVudHJ5O1xuICBpZihpbmRleCAhPT0gJ0YnKXJldHVybiB0aGF0Ll9pW2luZGV4XTtcbiAgLy8gZnJvemVuIG9iamVjdCBjYXNlXG4gIGZvcihlbnRyeSA9IHRoYXQuX2Y7IGVudHJ5OyBlbnRyeSA9IGVudHJ5Lm4pe1xuICAgIGlmKGVudHJ5LmsgPT0ga2V5KXJldHVybiBlbnRyeTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldENvbnN0cnVjdG9yOiBmdW5jdGlvbih3cmFwcGVyLCBOQU1FLCBJU19NQVAsIEFEREVSKXtcbiAgICB2YXIgQyA9IHdyYXBwZXIoZnVuY3Rpb24odGhhdCwgaXRlcmFibGUpe1xuICAgICAgYW5JbnN0YW5jZSh0aGF0LCBDLCBOQU1FLCAnX2knKTtcbiAgICAgIHRoYXQuX2kgPSBjcmVhdGUobnVsbCk7IC8vIGluZGV4XG4gICAgICB0aGF0Ll9mID0gdW5kZWZpbmVkOyAgICAvLyBmaXJzdCBlbnRyeVxuICAgICAgdGhhdC5fbCA9IHVuZGVmaW5lZDsgICAgLy8gbGFzdCBlbnRyeVxuICAgICAgdGhhdFtTSVpFXSA9IDA7ICAgICAgICAgLy8gc2l6ZVxuICAgICAgaWYoaXRlcmFibGUgIT0gdW5kZWZpbmVkKWZvck9mKGl0ZXJhYmxlLCBJU19NQVAsIHRoYXRbQURERVJdLCB0aGF0KTtcbiAgICB9KTtcbiAgICByZWRlZmluZUFsbChDLnByb3RvdHlwZSwge1xuICAgICAgLy8gMjMuMS4zLjEgTWFwLnByb3RvdHlwZS5jbGVhcigpXG4gICAgICAvLyAyMy4yLjMuMiBTZXQucHJvdG90eXBlLmNsZWFyKClcbiAgICAgIGNsZWFyOiBmdW5jdGlvbiBjbGVhcigpe1xuICAgICAgICBmb3IodmFyIHRoYXQgPSB0aGlzLCBkYXRhID0gdGhhdC5faSwgZW50cnkgPSB0aGF0Ll9mOyBlbnRyeTsgZW50cnkgPSBlbnRyeS5uKXtcbiAgICAgICAgICBlbnRyeS5yID0gdHJ1ZTtcbiAgICAgICAgICBpZihlbnRyeS5wKWVudHJ5LnAgPSBlbnRyeS5wLm4gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgZGVsZXRlIGRhdGFbZW50cnkuaV07XG4gICAgICAgIH1cbiAgICAgICAgdGhhdC5fZiA9IHRoYXQuX2wgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoYXRbU0laRV0gPSAwO1xuICAgICAgfSxcbiAgICAgIC8vIDIzLjEuMy4zIE1hcC5wcm90b3R5cGUuZGVsZXRlKGtleSlcbiAgICAgIC8vIDIzLjIuMy40IFNldC5wcm90b3R5cGUuZGVsZXRlKHZhbHVlKVxuICAgICAgJ2RlbGV0ZSc6IGZ1bmN0aW9uKGtleSl7XG4gICAgICAgIHZhciB0aGF0ICA9IHRoaXNcbiAgICAgICAgICAsIGVudHJ5ID0gZ2V0RW50cnkodGhhdCwga2V5KTtcbiAgICAgICAgaWYoZW50cnkpe1xuICAgICAgICAgIHZhciBuZXh0ID0gZW50cnkublxuICAgICAgICAgICAgLCBwcmV2ID0gZW50cnkucDtcbiAgICAgICAgICBkZWxldGUgdGhhdC5faVtlbnRyeS5pXTtcbiAgICAgICAgICBlbnRyeS5yID0gdHJ1ZTtcbiAgICAgICAgICBpZihwcmV2KXByZXYubiA9IG5leHQ7XG4gICAgICAgICAgaWYobmV4dCluZXh0LnAgPSBwcmV2O1xuICAgICAgICAgIGlmKHRoYXQuX2YgPT0gZW50cnkpdGhhdC5fZiA9IG5leHQ7XG4gICAgICAgICAgaWYodGhhdC5fbCA9PSBlbnRyeSl0aGF0Ll9sID0gcHJldjtcbiAgICAgICAgICB0aGF0W1NJWkVdLS07XG4gICAgICAgIH0gcmV0dXJuICEhZW50cnk7XG4gICAgICB9LFxuICAgICAgLy8gMjMuMi4zLjYgU2V0LnByb3RvdHlwZS5mb3JFYWNoKGNhbGxiYWNrZm4sIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gICAgICAvLyAyMy4xLjMuNSBNYXAucHJvdG90eXBlLmZvckVhY2goY2FsbGJhY2tmbiwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbiAgICAgIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2tmbiAvKiwgdGhhdCA9IHVuZGVmaW5lZCAqLyl7XG4gICAgICAgIGFuSW5zdGFuY2UodGhpcywgQywgJ2ZvckVhY2gnKTtcbiAgICAgICAgdmFyIGYgPSBjdHgoY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIDMpXG4gICAgICAgICAgLCBlbnRyeTtcbiAgICAgICAgd2hpbGUoZW50cnkgPSBlbnRyeSA/IGVudHJ5Lm4gOiB0aGlzLl9mKXtcbiAgICAgICAgICBmKGVudHJ5LnYsIGVudHJ5LmssIHRoaXMpO1xuICAgICAgICAgIC8vIHJldmVydCB0byB0aGUgbGFzdCBleGlzdGluZyBlbnRyeVxuICAgICAgICAgIHdoaWxlKGVudHJ5ICYmIGVudHJ5LnIpZW50cnkgPSBlbnRyeS5wO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gMjMuMS4zLjcgTWFwLnByb3RvdHlwZS5oYXMoa2V5KVxuICAgICAgLy8gMjMuMi4zLjcgU2V0LnByb3RvdHlwZS5oYXModmFsdWUpXG4gICAgICBoYXM6IGZ1bmN0aW9uIGhhcyhrZXkpe1xuICAgICAgICByZXR1cm4gISFnZXRFbnRyeSh0aGlzLCBrZXkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmKERFU0NSSVBUT1JTKWRQKEMucHJvdG90eXBlLCAnc2l6ZScsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIGRlZmluZWQodGhpc1tTSVpFXSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIEM7XG4gIH0sXG4gIGRlZjogZnVuY3Rpb24odGhhdCwga2V5LCB2YWx1ZSl7XG4gICAgdmFyIGVudHJ5ID0gZ2V0RW50cnkodGhhdCwga2V5KVxuICAgICAgLCBwcmV2LCBpbmRleDtcbiAgICAvLyBjaGFuZ2UgZXhpc3RpbmcgZW50cnlcbiAgICBpZihlbnRyeSl7XG4gICAgICBlbnRyeS52ID0gdmFsdWU7XG4gICAgLy8gY3JlYXRlIG5ldyBlbnRyeVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGF0Ll9sID0gZW50cnkgPSB7XG4gICAgICAgIGk6IGluZGV4ID0gZmFzdEtleShrZXksIHRydWUpLCAvLyA8LSBpbmRleFxuICAgICAgICBrOiBrZXksICAgICAgICAgICAgICAgICAgICAgICAgLy8gPC0ga2V5XG4gICAgICAgIHY6IHZhbHVlLCAgICAgICAgICAgICAgICAgICAgICAvLyA8LSB2YWx1ZVxuICAgICAgICBwOiBwcmV2ID0gdGhhdC5fbCwgICAgICAgICAgICAgLy8gPC0gcHJldmlvdXMgZW50cnlcbiAgICAgICAgbjogdW5kZWZpbmVkLCAgICAgICAgICAgICAgICAgIC8vIDwtIG5leHQgZW50cnlcbiAgICAgICAgcjogZmFsc2UgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIHJlbW92ZWRcbiAgICAgIH07XG4gICAgICBpZighdGhhdC5fZil0aGF0Ll9mID0gZW50cnk7XG4gICAgICBpZihwcmV2KXByZXYubiA9IGVudHJ5O1xuICAgICAgdGhhdFtTSVpFXSsrO1xuICAgICAgLy8gYWRkIHRvIGluZGV4XG4gICAgICBpZihpbmRleCAhPT0gJ0YnKXRoYXQuX2lbaW5kZXhdID0gZW50cnk7XG4gICAgfSByZXR1cm4gdGhhdDtcbiAgfSxcbiAgZ2V0RW50cnk6IGdldEVudHJ5LFxuICBzZXRTdHJvbmc6IGZ1bmN0aW9uKEMsIE5BTUUsIElTX01BUCl7XG4gICAgLy8gYWRkIC5rZXlzLCAudmFsdWVzLCAuZW50cmllcywgW0BAaXRlcmF0b3JdXG4gICAgLy8gMjMuMS4zLjQsIDIzLjEuMy44LCAyMy4xLjMuMTEsIDIzLjEuMy4xMiwgMjMuMi4zLjUsIDIzLjIuMy44LCAyMy4yLjMuMTAsIDIzLjIuMy4xMVxuICAgICRpdGVyRGVmaW5lKEMsIE5BTUUsIGZ1bmN0aW9uKGl0ZXJhdGVkLCBraW5kKXtcbiAgICAgIHRoaXMuX3QgPSBpdGVyYXRlZDsgIC8vIHRhcmdldFxuICAgICAgdGhpcy5fayA9IGtpbmQ7ICAgICAgLy8ga2luZFxuICAgICAgdGhpcy5fbCA9IHVuZGVmaW5lZDsgLy8gcHJldmlvdXNcbiAgICB9LCBmdW5jdGlvbigpe1xuICAgICAgdmFyIHRoYXQgID0gdGhpc1xuICAgICAgICAsIGtpbmQgID0gdGhhdC5fa1xuICAgICAgICAsIGVudHJ5ID0gdGhhdC5fbDtcbiAgICAgIC8vIHJldmVydCB0byB0aGUgbGFzdCBleGlzdGluZyBlbnRyeVxuICAgICAgd2hpbGUoZW50cnkgJiYgZW50cnkucillbnRyeSA9IGVudHJ5LnA7XG4gICAgICAvLyBnZXQgbmV4dCBlbnRyeVxuICAgICAgaWYoIXRoYXQuX3QgfHwgISh0aGF0Ll9sID0gZW50cnkgPSBlbnRyeSA/IGVudHJ5Lm4gOiB0aGF0Ll90Ll9mKSl7XG4gICAgICAgIC8vIG9yIGZpbmlzaCB0aGUgaXRlcmF0aW9uXG4gICAgICAgIHRoYXQuX3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBzdGVwKDEpO1xuICAgICAgfVxuICAgICAgLy8gcmV0dXJuIHN0ZXAgYnkga2luZFxuICAgICAgaWYoa2luZCA9PSAna2V5cycgIClyZXR1cm4gc3RlcCgwLCBlbnRyeS5rKTtcbiAgICAgIGlmKGtpbmQgPT0gJ3ZhbHVlcycpcmV0dXJuIHN0ZXAoMCwgZW50cnkudik7XG4gICAgICByZXR1cm4gc3RlcCgwLCBbZW50cnkuaywgZW50cnkudl0pO1xuICAgIH0sIElTX01BUCA/ICdlbnRyaWVzJyA6ICd2YWx1ZXMnICwgIUlTX01BUCwgdHJ1ZSk7XG5cbiAgICAvLyBhZGQgW0BAc3BlY2llc10sIDIzLjEuMi4yLCAyMy4yLjIuMlxuICAgIHNldFNwZWNpZXMoTkFNRSk7XG4gIH1cbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19jb2xsZWN0aW9uLXN0cm9uZy5qc1xuICoqIG1vZHVsZSBpZCA9IDIxMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCAkZXhwb3J0ICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgcmVkZWZpbmUgICAgICAgICAgPSByZXF1aXJlKCcuL19yZWRlZmluZScpXG4gICwgcmVkZWZpbmVBbGwgICAgICAgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKVxuICAsIG1ldGEgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fbWV0YScpXG4gICwgZm9yT2YgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19mb3Itb2YnKVxuICAsIGFuSW5zdGFuY2UgICAgICAgID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKVxuICAsIGlzT2JqZWN0ICAgICAgICAgID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBmYWlscyAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2ZhaWxzJylcbiAgLCAkaXRlckRldGVjdCAgICAgICA9IHJlcXVpcmUoJy4vX2l0ZXItZGV0ZWN0JylcbiAgLCBzZXRUb1N0cmluZ1RhZyAgICA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJylcbiAgLCBpbmhlcml0SWZSZXF1aXJlZCA9IHJlcXVpcmUoJy4vX2luaGVyaXQtaWYtcmVxdWlyZWQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihOQU1FLCB3cmFwcGVyLCBtZXRob2RzLCBjb21tb24sIElTX01BUCwgSVNfV0VBSyl7XG4gIHZhciBCYXNlICA9IGdsb2JhbFtOQU1FXVxuICAgICwgQyAgICAgPSBCYXNlXG4gICAgLCBBRERFUiA9IElTX01BUCA/ICdzZXQnIDogJ2FkZCdcbiAgICAsIHByb3RvID0gQyAmJiBDLnByb3RvdHlwZVxuICAgICwgTyAgICAgPSB7fTtcbiAgdmFyIGZpeE1ldGhvZCA9IGZ1bmN0aW9uKEtFWSl7XG4gICAgdmFyIGZuID0gcHJvdG9bS0VZXTtcbiAgICByZWRlZmluZShwcm90bywgS0VZLFxuICAgICAgS0VZID09ICdkZWxldGUnID8gZnVuY3Rpb24oYSl7XG4gICAgICAgIHJldHVybiBJU19XRUFLICYmICFpc09iamVjdChhKSA/IGZhbHNlIDogZm4uY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEpO1xuICAgICAgfSA6IEtFWSA9PSAnaGFzJyA/IGZ1bmN0aW9uIGhhcyhhKXtcbiAgICAgICAgcmV0dXJuIElTX1dFQUsgJiYgIWlzT2JqZWN0KGEpID8gZmFsc2UgOiBmbi5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSk7XG4gICAgICB9IDogS0VZID09ICdnZXQnID8gZnVuY3Rpb24gZ2V0KGEpe1xuICAgICAgICByZXR1cm4gSVNfV0VBSyAmJiAhaXNPYmplY3QoYSkgPyB1bmRlZmluZWQgOiBmbi5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSk7XG4gICAgICB9IDogS0VZID09ICdhZGQnID8gZnVuY3Rpb24gYWRkKGEpeyBmbi5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSk7IHJldHVybiB0aGlzOyB9XG4gICAgICAgIDogZnVuY3Rpb24gc2V0KGEsIGIpeyBmbi5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSwgYik7IHJldHVybiB0aGlzOyB9XG4gICAgKTtcbiAgfTtcbiAgaWYodHlwZW9mIEMgIT0gJ2Z1bmN0aW9uJyB8fCAhKElTX1dFQUsgfHwgcHJvdG8uZm9yRWFjaCAmJiAhZmFpbHMoZnVuY3Rpb24oKXtcbiAgICBuZXcgQygpLmVudHJpZXMoKS5uZXh0KCk7XG4gIH0pKSl7XG4gICAgLy8gY3JlYXRlIGNvbGxlY3Rpb24gY29uc3RydWN0b3JcbiAgICBDID0gY29tbW9uLmdldENvbnN0cnVjdG9yKHdyYXBwZXIsIE5BTUUsIElTX01BUCwgQURERVIpO1xuICAgIHJlZGVmaW5lQWxsKEMucHJvdG90eXBlLCBtZXRob2RzKTtcbiAgICBtZXRhLk5FRUQgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHZhciBpbnN0YW5jZSAgICAgICAgICAgICA9IG5ldyBDXG4gICAgICAvLyBlYXJseSBpbXBsZW1lbnRhdGlvbnMgbm90IHN1cHBvcnRzIGNoYWluaW5nXG4gICAgICAsIEhBU05UX0NIQUlOSU5HICAgICAgID0gaW5zdGFuY2VbQURERVJdKElTX1dFQUsgPyB7fSA6IC0wLCAxKSAhPSBpbnN0YW5jZVxuICAgICAgLy8gVjggfiAgQ2hyb21pdW0gNDAtIHdlYWstY29sbGVjdGlvbnMgdGhyb3dzIG9uIHByaW1pdGl2ZXMsIGJ1dCBzaG91bGQgcmV0dXJuIGZhbHNlXG4gICAgICAsIFRIUk9XU19PTl9QUklNSVRJVkVTID0gZmFpbHMoZnVuY3Rpb24oKXsgaW5zdGFuY2UuaGFzKDEpOyB9KVxuICAgICAgLy8gbW9zdCBlYXJseSBpbXBsZW1lbnRhdGlvbnMgZG9lc24ndCBzdXBwb3J0cyBpdGVyYWJsZXMsIG1vc3QgbW9kZXJuIC0gbm90IGNsb3NlIGl0IGNvcnJlY3RseVxuICAgICAgLCBBQ0NFUFRfSVRFUkFCTEVTICAgICA9ICRpdGVyRGV0ZWN0KGZ1bmN0aW9uKGl0ZXIpeyBuZXcgQyhpdGVyKTsgfSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICAgIC8vIGZvciBlYXJseSBpbXBsZW1lbnRhdGlvbnMgLTAgYW5kICswIG5vdCB0aGUgc2FtZVxuICAgICAgLCBCVUdHWV9aRVJPID0gIUlTX1dFQUsgJiYgZmFpbHMoZnVuY3Rpb24oKXtcbiAgICAgICAgLy8gVjggfiBDaHJvbWl1bSA0Mi0gZmFpbHMgb25seSB3aXRoIDUrIGVsZW1lbnRzXG4gICAgICAgIHZhciAkaW5zdGFuY2UgPSBuZXcgQygpXG4gICAgICAgICAgLCBpbmRleCAgICAgPSA1O1xuICAgICAgICB3aGlsZShpbmRleC0tKSRpbnN0YW5jZVtBRERFUl0oaW5kZXgsIGluZGV4KTtcbiAgICAgICAgcmV0dXJuICEkaW5zdGFuY2UuaGFzKC0wKTtcbiAgICAgIH0pO1xuICAgIGlmKCFBQ0NFUFRfSVRFUkFCTEVTKXsgXG4gICAgICBDID0gd3JhcHBlcihmdW5jdGlvbih0YXJnZXQsIGl0ZXJhYmxlKXtcbiAgICAgICAgYW5JbnN0YW5jZSh0YXJnZXQsIEMsIE5BTUUpO1xuICAgICAgICB2YXIgdGhhdCA9IGluaGVyaXRJZlJlcXVpcmVkKG5ldyBCYXNlLCB0YXJnZXQsIEMpO1xuICAgICAgICBpZihpdGVyYWJsZSAhPSB1bmRlZmluZWQpZm9yT2YoaXRlcmFibGUsIElTX01BUCwgdGhhdFtBRERFUl0sIHRoYXQpO1xuICAgICAgICByZXR1cm4gdGhhdDtcbiAgICAgIH0pO1xuICAgICAgQy5wcm90b3R5cGUgPSBwcm90bztcbiAgICAgIHByb3RvLmNvbnN0cnVjdG9yID0gQztcbiAgICB9XG4gICAgaWYoVEhST1dTX09OX1BSSU1JVElWRVMgfHwgQlVHR1lfWkVSTyl7XG4gICAgICBmaXhNZXRob2QoJ2RlbGV0ZScpO1xuICAgICAgZml4TWV0aG9kKCdoYXMnKTtcbiAgICAgIElTX01BUCAmJiBmaXhNZXRob2QoJ2dldCcpO1xuICAgIH1cbiAgICBpZihCVUdHWV9aRVJPIHx8IEhBU05UX0NIQUlOSU5HKWZpeE1ldGhvZChBRERFUik7XG4gICAgLy8gd2VhayBjb2xsZWN0aW9ucyBzaG91bGQgbm90IGNvbnRhaW5zIC5jbGVhciBtZXRob2RcbiAgICBpZihJU19XRUFLICYmIHByb3RvLmNsZWFyKWRlbGV0ZSBwcm90by5jbGVhcjtcbiAgfVxuXG4gIHNldFRvU3RyaW5nVGFnKEMsIE5BTUUpO1xuXG4gIE9bTkFNRV0gPSBDO1xuICAkZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqIChDICE9IEJhc2UpLCBPKTtcblxuICBpZighSVNfV0VBSyljb21tb24uc2V0U3Ryb25nKEMsIE5BTUUsIElTX01BUCk7XG5cbiAgcmV0dXJuIEM7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fY29sbGVjdGlvbi5qc1xuICoqIG1vZHVsZSBpZCA9IDIxM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHN0cm9uZyA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24tc3Ryb25nJyk7XG5cbi8vIDIzLjIgU2V0IE9iamVjdHNcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbicpKCdTZXQnLCBmdW5jdGlvbihnZXQpe1xuICByZXR1cm4gZnVuY3Rpb24gU2V0KCl7IHJldHVybiBnZXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpOyB9O1xufSwge1xuICAvLyAyMy4yLjMuMSBTZXQucHJvdG90eXBlLmFkZCh2YWx1ZSlcbiAgYWRkOiBmdW5jdGlvbiBhZGQodmFsdWUpe1xuICAgIHJldHVybiBzdHJvbmcuZGVmKHRoaXMsIHZhbHVlID0gdmFsdWUgPT09IDAgPyAwIDogdmFsdWUsIHZhbHVlKTtcbiAgfVxufSwgc3Ryb25nKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnNldC5qc1xuICoqIG1vZHVsZSBpZCA9IDIxNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGVhY2ggICAgICAgICA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSgwKVxuICAsIHJlZGVmaW5lICAgICA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJylcbiAgLCBtZXRhICAgICAgICAgPSByZXF1aXJlKCcuL19tZXRhJylcbiAgLCBhc3NpZ24gICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtYXNzaWduJylcbiAgLCB3ZWFrICAgICAgICAgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uLXdlYWsnKVxuICAsIGlzT2JqZWN0ICAgICA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgaGFzICAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCBnZXRXZWFrICAgICAgPSBtZXRhLmdldFdlYWtcbiAgLCBpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlXG4gICwgdW5jYXVnaHRGcm96ZW5TdG9yZSA9IHdlYWsudWZzdG9yZVxuICAsIHRtcCAgICAgICAgICA9IHt9XG4gICwgSW50ZXJuYWxNYXA7XG5cbnZhciB3cmFwcGVyID0gZnVuY3Rpb24oZ2V0KXtcbiAgcmV0dXJuIGZ1bmN0aW9uIFdlYWtNYXAoKXtcbiAgICByZXR1cm4gZ2V0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTtcbiAgfTtcbn07XG5cbnZhciBtZXRob2RzID0ge1xuICAvLyAyMy4zLjMuMyBXZWFrTWFwLnByb3RvdHlwZS5nZXQoa2V5KVxuICBnZXQ6IGZ1bmN0aW9uIGdldChrZXkpe1xuICAgIGlmKGlzT2JqZWN0KGtleSkpe1xuICAgICAgdmFyIGRhdGEgPSBnZXRXZWFrKGtleSk7XG4gICAgICBpZihkYXRhID09PSB0cnVlKXJldHVybiB1bmNhdWdodEZyb3plblN0b3JlKHRoaXMpLmdldChrZXkpO1xuICAgICAgcmV0dXJuIGRhdGEgPyBkYXRhW3RoaXMuX2ldIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgfSxcbiAgLy8gMjMuMy4zLjUgV2Vha01hcC5wcm90b3R5cGUuc2V0KGtleSwgdmFsdWUpXG4gIHNldDogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpe1xuICAgIHJldHVybiB3ZWFrLmRlZih0aGlzLCBrZXksIHZhbHVlKTtcbiAgfVxufTtcblxuLy8gMjMuMyBXZWFrTWFwIE9iamVjdHNcbnZhciAkV2Vha01hcCA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbicpKCdXZWFrTWFwJywgd3JhcHBlciwgbWV0aG9kcywgd2VhaywgdHJ1ZSwgdHJ1ZSk7XG5cbi8vIElFMTEgV2Vha01hcCBmcm96ZW4ga2V5cyBmaXhcbmlmKG5ldyAkV2Vha01hcCgpLnNldCgoT2JqZWN0LmZyZWV6ZSB8fCBPYmplY3QpKHRtcCksIDcpLmdldCh0bXApICE9IDcpe1xuICBJbnRlcm5hbE1hcCA9IHdlYWsuZ2V0Q29uc3RydWN0b3Iod3JhcHBlcik7XG4gIGFzc2lnbihJbnRlcm5hbE1hcC5wcm90b3R5cGUsIG1ldGhvZHMpO1xuICBtZXRhLk5FRUQgPSB0cnVlO1xuICBlYWNoKFsnZGVsZXRlJywgJ2hhcycsICdnZXQnLCAnc2V0J10sIGZ1bmN0aW9uKGtleSl7XG4gICAgdmFyIHByb3RvICA9ICRXZWFrTWFwLnByb3RvdHlwZVxuICAgICAgLCBtZXRob2QgPSBwcm90b1trZXldO1xuICAgIHJlZGVmaW5lKHByb3RvLCBrZXksIGZ1bmN0aW9uKGEsIGIpe1xuICAgICAgLy8gc3RvcmUgZnJvemVuIG9iamVjdHMgb24gaW50ZXJuYWwgd2Vha21hcCBzaGltXG4gICAgICBpZihpc09iamVjdChhKSAmJiAhaXNFeHRlbnNpYmxlKGEpKXtcbiAgICAgICAgaWYoIXRoaXMuX2YpdGhpcy5fZiA9IG5ldyBJbnRlcm5hbE1hcDtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX2Zba2V5XShhLCBiKTtcbiAgICAgICAgcmV0dXJuIGtleSA9PSAnc2V0JyA/IHRoaXMgOiByZXN1bHQ7XG4gICAgICAvLyBzdG9yZSBhbGwgdGhlIHJlc3Qgb24gbmF0aXZlIHdlYWttYXBcbiAgICAgIH0gcmV0dXJuIG1ldGhvZC5jYWxsKHRoaXMsIGEsIGIpO1xuICAgIH0pO1xuICB9KTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LndlYWstbWFwLmpzXG4gKiogbW9kdWxlIGlkID0gMjE1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgcmVkZWZpbmVBbGwgICAgICAgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKVxuICAsIGdldFdlYWsgICAgICAgICAgID0gcmVxdWlyZSgnLi9fbWV0YScpLmdldFdlYWtcbiAgLCBhbk9iamVjdCAgICAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgaXNPYmplY3QgICAgICAgICAgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGFuSW5zdGFuY2UgICAgICAgID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKVxuICAsIGZvck9mICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZm9yLW9mJylcbiAgLCBjcmVhdGVBcnJheU1ldGhvZCA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKVxuICAsICRoYXMgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCBhcnJheUZpbmQgICAgICAgICA9IGNyZWF0ZUFycmF5TWV0aG9kKDUpXG4gICwgYXJyYXlGaW5kSW5kZXggICAgPSBjcmVhdGVBcnJheU1ldGhvZCg2KVxuICAsIGlkICAgICAgICAgICAgICAgID0gMDtcblxuLy8gZmFsbGJhY2sgZm9yIHVuY2F1Z2h0IGZyb3plbiBrZXlzXG52YXIgdW5jYXVnaHRGcm96ZW5TdG9yZSA9IGZ1bmN0aW9uKHRoYXQpe1xuICByZXR1cm4gdGhhdC5fbCB8fCAodGhhdC5fbCA9IG5ldyBVbmNhdWdodEZyb3plblN0b3JlKTtcbn07XG52YXIgVW5jYXVnaHRGcm96ZW5TdG9yZSA9IGZ1bmN0aW9uKCl7XG4gIHRoaXMuYSA9IFtdO1xufTtcbnZhciBmaW5kVW5jYXVnaHRGcm96ZW4gPSBmdW5jdGlvbihzdG9yZSwga2V5KXtcbiAgcmV0dXJuIGFycmF5RmluZChzdG9yZS5hLCBmdW5jdGlvbihpdCl7XG4gICAgcmV0dXJuIGl0WzBdID09PSBrZXk7XG4gIH0pO1xufTtcblVuY2F1Z2h0RnJvemVuU3RvcmUucHJvdG90eXBlID0ge1xuICBnZXQ6IGZ1bmN0aW9uKGtleSl7XG4gICAgdmFyIGVudHJ5ID0gZmluZFVuY2F1Z2h0RnJvemVuKHRoaXMsIGtleSk7XG4gICAgaWYoZW50cnkpcmV0dXJuIGVudHJ5WzFdO1xuICB9LFxuICBoYXM6IGZ1bmN0aW9uKGtleSl7XG4gICAgcmV0dXJuICEhZmluZFVuY2F1Z2h0RnJvemVuKHRoaXMsIGtleSk7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24oa2V5LCB2YWx1ZSl7XG4gICAgdmFyIGVudHJ5ID0gZmluZFVuY2F1Z2h0RnJvemVuKHRoaXMsIGtleSk7XG4gICAgaWYoZW50cnkpZW50cnlbMV0gPSB2YWx1ZTtcbiAgICBlbHNlIHRoaXMuYS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0sXG4gICdkZWxldGUnOiBmdW5jdGlvbihrZXkpe1xuICAgIHZhciBpbmRleCA9IGFycmF5RmluZEluZGV4KHRoaXMuYSwgZnVuY3Rpb24oaXQpe1xuICAgICAgcmV0dXJuIGl0WzBdID09PSBrZXk7XG4gICAgfSk7XG4gICAgaWYofmluZGV4KXRoaXMuYS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIHJldHVybiAhIX5pbmRleDtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldENvbnN0cnVjdG9yOiBmdW5jdGlvbih3cmFwcGVyLCBOQU1FLCBJU19NQVAsIEFEREVSKXtcbiAgICB2YXIgQyA9IHdyYXBwZXIoZnVuY3Rpb24odGhhdCwgaXRlcmFibGUpe1xuICAgICAgYW5JbnN0YW5jZSh0aGF0LCBDLCBOQU1FLCAnX2knKTtcbiAgICAgIHRoYXQuX2kgPSBpZCsrOyAgICAgIC8vIGNvbGxlY3Rpb24gaWRcbiAgICAgIHRoYXQuX2wgPSB1bmRlZmluZWQ7IC8vIGxlYWsgc3RvcmUgZm9yIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RzXG4gICAgICBpZihpdGVyYWJsZSAhPSB1bmRlZmluZWQpZm9yT2YoaXRlcmFibGUsIElTX01BUCwgdGhhdFtBRERFUl0sIHRoYXQpO1xuICAgIH0pO1xuICAgIHJlZGVmaW5lQWxsKEMucHJvdG90eXBlLCB7XG4gICAgICAvLyAyMy4zLjMuMiBXZWFrTWFwLnByb3RvdHlwZS5kZWxldGUoa2V5KVxuICAgICAgLy8gMjMuNC4zLjMgV2Vha1NldC5wcm90b3R5cGUuZGVsZXRlKHZhbHVlKVxuICAgICAgJ2RlbGV0ZSc6IGZ1bmN0aW9uKGtleSl7XG4gICAgICAgIGlmKCFpc09iamVjdChrZXkpKXJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIGRhdGEgPSBnZXRXZWFrKGtleSk7XG4gICAgICAgIGlmKGRhdGEgPT09IHRydWUpcmV0dXJuIHVuY2F1Z2h0RnJvemVuU3RvcmUodGhpcylbJ2RlbGV0ZSddKGtleSk7XG4gICAgICAgIHJldHVybiBkYXRhICYmICRoYXMoZGF0YSwgdGhpcy5faSkgJiYgZGVsZXRlIGRhdGFbdGhpcy5faV07XG4gICAgICB9LFxuICAgICAgLy8gMjMuMy4zLjQgV2Vha01hcC5wcm90b3R5cGUuaGFzKGtleSlcbiAgICAgIC8vIDIzLjQuMy40IFdlYWtTZXQucHJvdG90eXBlLmhhcyh2YWx1ZSlcbiAgICAgIGhhczogZnVuY3Rpb24gaGFzKGtleSl7XG4gICAgICAgIGlmKCFpc09iamVjdChrZXkpKXJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIGRhdGEgPSBnZXRXZWFrKGtleSk7XG4gICAgICAgIGlmKGRhdGEgPT09IHRydWUpcmV0dXJuIHVuY2F1Z2h0RnJvemVuU3RvcmUodGhpcykuaGFzKGtleSk7XG4gICAgICAgIHJldHVybiBkYXRhICYmICRoYXMoZGF0YSwgdGhpcy5faSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIEM7XG4gIH0sXG4gIGRlZjogZnVuY3Rpb24odGhhdCwga2V5LCB2YWx1ZSl7XG4gICAgdmFyIGRhdGEgPSBnZXRXZWFrKGFuT2JqZWN0KGtleSksIHRydWUpO1xuICAgIGlmKGRhdGEgPT09IHRydWUpdW5jYXVnaHRGcm96ZW5TdG9yZSh0aGF0KS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgZWxzZSBkYXRhW3RoYXQuX2ldID0gdmFsdWU7XG4gICAgcmV0dXJuIHRoYXQ7XG4gIH0sXG4gIHVmc3RvcmU6IHVuY2F1Z2h0RnJvemVuU3RvcmVcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19jb2xsZWN0aW9uLXdlYWsuanNcbiAqKiBtb2R1bGUgaWQgPSAyMTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciB3ZWFrID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbi13ZWFrJyk7XG5cbi8vIDIzLjQgV2Vha1NldCBPYmplY3RzXG5yZXF1aXJlKCcuL19jb2xsZWN0aW9uJykoJ1dlYWtTZXQnLCBmdW5jdGlvbihnZXQpe1xuICByZXR1cm4gZnVuY3Rpb24gV2Vha1NldCgpeyByZXR1cm4gZ2V0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTsgfTtcbn0sIHtcbiAgLy8gMjMuNC4zLjEgV2Vha1NldC5wcm90b3R5cGUuYWRkKHZhbHVlKVxuICBhZGQ6IGZ1bmN0aW9uIGFkZCh2YWx1ZSl7XG4gICAgcmV0dXJuIHdlYWsuZGVmKHRoaXMsIHZhbHVlLCB0cnVlKTtcbiAgfVxufSwgd2VhaywgZmFsc2UsIHRydWUpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYud2Vhay1zZXQuanNcbiAqKiBtb2R1bGUgaWQgPSAyMTdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICR0eXBlZCAgICAgICA9IHJlcXVpcmUoJy4vX3R5cGVkJylcbiAgLCBidWZmZXIgICAgICAgPSByZXF1aXJlKCcuL190eXBlZC1idWZmZXInKVxuICAsIGFuT2JqZWN0ICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgdG9JbmRleCAgICAgID0gcmVxdWlyZSgnLi9fdG8taW5kZXgnKVxuICAsIHRvTGVuZ3RoICAgICA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpXG4gICwgaXNPYmplY3QgICAgID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBUWVBFRF9BUlJBWSAgPSByZXF1aXJlKCcuL193a3MnKSgndHlwZWRfYXJyYXknKVxuICAsIEFycmF5QnVmZmVyICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLkFycmF5QnVmZmVyXG4gICwgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fc3BlY2llcy1jb25zdHJ1Y3RvcicpXG4gICwgJEFycmF5QnVmZmVyID0gYnVmZmVyLkFycmF5QnVmZmVyXG4gICwgJERhdGFWaWV3ICAgID0gYnVmZmVyLkRhdGFWaWV3XG4gICwgJGlzVmlldyAgICAgID0gJHR5cGVkLkFCViAmJiBBcnJheUJ1ZmZlci5pc1ZpZXdcbiAgLCAkc2xpY2UgICAgICAgPSAkQXJyYXlCdWZmZXIucHJvdG90eXBlLnNsaWNlXG4gICwgVklFVyAgICAgICAgID0gJHR5cGVkLlZJRVdcbiAgLCBBUlJBWV9CVUZGRVIgPSAnQXJyYXlCdWZmZXInO1xuXG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqIChBcnJheUJ1ZmZlciAhPT0gJEFycmF5QnVmZmVyKSwge0FycmF5QnVmZmVyOiAkQXJyYXlCdWZmZXJ9KTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhJHR5cGVkLkNPTlNUUiwgQVJSQVlfQlVGRkVSLCB7XG4gIC8vIDI0LjEuMy4xIEFycmF5QnVmZmVyLmlzVmlldyhhcmcpXG4gIGlzVmlldzogZnVuY3Rpb24gaXNWaWV3KGl0KXtcbiAgICByZXR1cm4gJGlzVmlldyAmJiAkaXNWaWV3KGl0KSB8fCBpc09iamVjdChpdCkgJiYgVklFVyBpbiBpdDtcbiAgfVxufSk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5VICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICByZXR1cm4gIW5ldyAkQXJyYXlCdWZmZXIoMikuc2xpY2UoMSwgdW5kZWZpbmVkKS5ieXRlTGVuZ3RoO1xufSksIEFSUkFZX0JVRkZFUiwge1xuICAvLyAyNC4xLjQuMyBBcnJheUJ1ZmZlci5wcm90b3R5cGUuc2xpY2Uoc3RhcnQsIGVuZClcbiAgc2xpY2U6IGZ1bmN0aW9uIHNsaWNlKHN0YXJ0LCBlbmQpe1xuICAgIGlmKCRzbGljZSAhPT0gdW5kZWZpbmVkICYmIGVuZCA9PT0gdW5kZWZpbmVkKXJldHVybiAkc2xpY2UuY2FsbChhbk9iamVjdCh0aGlzKSwgc3RhcnQpOyAvLyBGRiBmaXhcbiAgICB2YXIgbGVuICAgID0gYW5PYmplY3QodGhpcykuYnl0ZUxlbmd0aFxuICAgICAgLCBmaXJzdCAgPSB0b0luZGV4KHN0YXJ0LCBsZW4pXG4gICAgICAsIGZpbmFsICA9IHRvSW5kZXgoZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiBlbmQsIGxlbilcbiAgICAgICwgcmVzdWx0ID0gbmV3IChzcGVjaWVzQ29uc3RydWN0b3IodGhpcywgJEFycmF5QnVmZmVyKSkodG9MZW5ndGgoZmluYWwgLSBmaXJzdCkpXG4gICAgICAsIHZpZXdTICA9IG5ldyAkRGF0YVZpZXcodGhpcylcbiAgICAgICwgdmlld1QgID0gbmV3ICREYXRhVmlldyhyZXN1bHQpXG4gICAgICAsIGluZGV4ICA9IDA7XG4gICAgd2hpbGUoZmlyc3QgPCBmaW5hbCl7XG4gICAgICB2aWV3VC5zZXRVaW50OChpbmRleCsrLCB2aWV3Uy5nZXRVaW50OChmaXJzdCsrKSk7XG4gICAgfSByZXR1cm4gcmVzdWx0O1xuICB9XG59KTtcblxucmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKShBUlJBWV9CVUZGRVIpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuYXJyYXktYnVmZmVyLmpzXG4gKiogbW9kdWxlIGlkID0gMjE4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBoaWRlICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgLCB1aWQgICAgPSByZXF1aXJlKCcuL191aWQnKVxuICAsIFRZUEVEICA9IHVpZCgndHlwZWRfYXJyYXknKVxuICAsIFZJRVcgICA9IHVpZCgndmlldycpXG4gICwgQUJWICAgID0gISEoZ2xvYmFsLkFycmF5QnVmZmVyICYmIGdsb2JhbC5EYXRhVmlldylcbiAgLCBDT05TVFIgPSBBQlZcbiAgLCBpID0gMCwgbCA9IDksIFR5cGVkO1xuXG52YXIgVHlwZWRBcnJheUNvbnN0cnVjdG9ycyA9IChcbiAgJ0ludDhBcnJheSxVaW50OEFycmF5LFVpbnQ4Q2xhbXBlZEFycmF5LEludDE2QXJyYXksVWludDE2QXJyYXksSW50MzJBcnJheSxVaW50MzJBcnJheSxGbG9hdDMyQXJyYXksRmxvYXQ2NEFycmF5J1xuKS5zcGxpdCgnLCcpO1xuXG53aGlsZShpIDwgbCl7XG4gIGlmKFR5cGVkID0gZ2xvYmFsW1R5cGVkQXJyYXlDb25zdHJ1Y3RvcnNbaSsrXV0pe1xuICAgIGhpZGUoVHlwZWQucHJvdG90eXBlLCBUWVBFRCwgdHJ1ZSk7XG4gICAgaGlkZShUeXBlZC5wcm90b3R5cGUsIFZJRVcsIHRydWUpO1xuICB9IGVsc2UgQ09OU1RSID0gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBBQlY6ICAgIEFCVixcbiAgQ09OU1RSOiBDT05TVFIsXG4gIFRZUEVEOiAgVFlQRUQsXG4gIFZJRVc6ICAgVklFV1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX3R5cGVkLmpzXG4gKiogbW9kdWxlIGlkID0gMjE5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsICAgICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIERFU0NSSVBUT1JTICAgID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKVxuICAsIExJQlJBUlkgICAgICAgID0gcmVxdWlyZSgnLi9fbGlicmFyeScpXG4gICwgJHR5cGVkICAgICAgICAgPSByZXF1aXJlKCcuL190eXBlZCcpXG4gICwgaGlkZSAgICAgICAgICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgLCByZWRlZmluZUFsbCAgICA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpXG4gICwgZmFpbHMgICAgICAgICAgPSByZXF1aXJlKCcuL19mYWlscycpXG4gICwgYW5JbnN0YW5jZSAgICAgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpXG4gICwgdG9JbnRlZ2VyICAgICAgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJylcbiAgLCB0b0xlbmd0aCAgICAgICA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpXG4gICwgZ09QTiAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmZcbiAgLCBkUCAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmZcbiAgLCBhcnJheUZpbGwgICAgICA9IHJlcXVpcmUoJy4vX2FycmF5LWZpbGwnKVxuICAsIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKVxuICAsIEFSUkFZX0JVRkZFUiAgID0gJ0FycmF5QnVmZmVyJ1xuICAsIERBVEFfVklFVyAgICAgID0gJ0RhdGFWaWV3J1xuICAsIFBST1RPVFlQRSAgICAgID0gJ3Byb3RvdHlwZSdcbiAgLCBXUk9OR19MRU5HVEggICA9ICdXcm9uZyBsZW5ndGghJ1xuICAsIFdST05HX0lOREVYICAgID0gJ1dyb25nIGluZGV4ISdcbiAgLCAkQXJyYXlCdWZmZXIgICA9IGdsb2JhbFtBUlJBWV9CVUZGRVJdXG4gICwgJERhdGFWaWV3ICAgICAgPSBnbG9iYWxbREFUQV9WSUVXXVxuICAsIE1hdGggICAgICAgICAgID0gZ2xvYmFsLk1hdGhcbiAgLCBwYXJzZUludCAgICAgICA9IGdsb2JhbC5wYXJzZUludFxuICAsIFJhbmdlRXJyb3IgICAgID0gZ2xvYmFsLlJhbmdlRXJyb3JcbiAgLCBJbmZpbml0eSAgICAgICA9IGdsb2JhbC5JbmZpbml0eVxuICAsIEJhc2VCdWZmZXIgICAgID0gJEFycmF5QnVmZmVyXG4gICwgYWJzICAgICAgICAgICAgPSBNYXRoLmFic1xuICAsIHBvdyAgICAgICAgICAgID0gTWF0aC5wb3dcbiAgLCBtaW4gICAgICAgICAgICA9IE1hdGgubWluXG4gICwgZmxvb3IgICAgICAgICAgPSBNYXRoLmZsb29yXG4gICwgbG9nICAgICAgICAgICAgPSBNYXRoLmxvZ1xuICAsIExOMiAgICAgICAgICAgID0gTWF0aC5MTjJcbiAgLCBCVUZGRVIgICAgICAgICA9ICdidWZmZXInXG4gICwgQllURV9MRU5HVEggICAgPSAnYnl0ZUxlbmd0aCdcbiAgLCBCWVRFX09GRlNFVCAgICA9ICdieXRlT2Zmc2V0J1xuICAsICRCVUZGRVIgICAgICAgID0gREVTQ1JJUFRPUlMgPyAnX2InIDogQlVGRkVSXG4gICwgJExFTkdUSCAgICAgICAgPSBERVNDUklQVE9SUyA/ICdfbCcgOiBCWVRFX0xFTkdUSFxuICAsICRPRkZTRVQgICAgICAgID0gREVTQ1JJUFRPUlMgPyAnX28nIDogQllURV9PRkZTRVQ7XG5cbi8vIElFRUU3NTQgY29udmVyc2lvbnMgYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9pZWVlNzU0XG52YXIgcGFja0lFRUU3NTQgPSBmdW5jdGlvbih2YWx1ZSwgbUxlbiwgbkJ5dGVzKXtcbiAgdmFyIGJ1ZmZlciA9IEFycmF5KG5CeXRlcylcbiAgICAsIGVMZW4gICA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICAgICwgZU1heCAgID0gKDEgPDwgZUxlbikgLSAxXG4gICAgLCBlQmlhcyAgPSBlTWF4ID4+IDFcbiAgICAsIHJ0ICAgICA9IG1MZW4gPT09IDIzID8gcG93KDIsIC0yNCkgLSBwb3coMiwgLTc3KSA6IDBcbiAgICAsIGkgICAgICA9IDBcbiAgICAsIHMgICAgICA9IHZhbHVlIDwgMCB8fCB2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwID8gMSA6IDBcbiAgICAsIGUsIG0sIGM7XG4gIHZhbHVlID0gYWJzKHZhbHVlKVxuICBpZih2YWx1ZSAhPSB2YWx1ZSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpe1xuICAgIG0gPSB2YWx1ZSAhPSB2YWx1ZSA/IDEgOiAwO1xuICAgIGUgPSBlTWF4O1xuICB9IGVsc2Uge1xuICAgIGUgPSBmbG9vcihsb2codmFsdWUpIC8gTE4yKTtcbiAgICBpZih2YWx1ZSAqIChjID0gcG93KDIsIC1lKSkgPCAxKXtcbiAgICAgIGUtLTtcbiAgICAgIGMgKj0gMjtcbiAgICB9XG4gICAgaWYoZSArIGVCaWFzID49IDEpe1xuICAgICAgdmFsdWUgKz0gcnQgLyBjO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIHBvdygyLCAxIC0gZUJpYXMpO1xuICAgIH1cbiAgICBpZih2YWx1ZSAqIGMgPj0gMil7XG4gICAgICBlKys7XG4gICAgICBjIC89IDI7XG4gICAgfVxuICAgIGlmKGUgKyBlQmlhcyA+PSBlTWF4KXtcbiAgICAgIG0gPSAwO1xuICAgICAgZSA9IGVNYXg7XG4gICAgfSBlbHNlIGlmKGUgKyBlQmlhcyA+PSAxKXtcbiAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBwb3coMiwgbUxlbik7XG4gICAgICBlID0gZSArIGVCaWFzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBwb3coMiwgZUJpYXMgLSAxKSAqIHBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSAwO1xuICAgIH1cbiAgfVxuICBmb3IoOyBtTGVuID49IDg7IGJ1ZmZlcltpKytdID0gbSAmIDI1NSwgbSAvPSAyNTYsIG1MZW4gLT0gOCk7XG4gIGUgPSBlIDw8IG1MZW4gfCBtO1xuICBlTGVuICs9IG1MZW47XG4gIGZvcig7IGVMZW4gPiAwOyBidWZmZXJbaSsrXSA9IGUgJiAyNTUsIGUgLz0gMjU2LCBlTGVuIC09IDgpO1xuICBidWZmZXJbLS1pXSB8PSBzICogMTI4O1xuICByZXR1cm4gYnVmZmVyO1xufTtcbnZhciB1bnBhY2tJRUVFNzU0ID0gZnVuY3Rpb24oYnVmZmVyLCBtTGVuLCBuQnl0ZXMpe1xuICB2YXIgZUxlbiAgPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgICAsIGVNYXggID0gKDEgPDwgZUxlbikgLSAxXG4gICAgLCBlQmlhcyA9IGVNYXggPj4gMVxuICAgICwgbkJpdHMgPSBlTGVuIC0gN1xuICAgICwgaSAgICAgPSBuQnl0ZXMgLSAxXG4gICAgLCBzICAgICA9IGJ1ZmZlcltpLS1dXG4gICAgLCBlICAgICA9IHMgJiAxMjdcbiAgICAsIG07XG4gIHMgPj49IDc7XG4gIGZvcig7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbaV0sIGktLSwgbkJpdHMgLT0gOCk7XG4gIG0gPSBlICYgKDEgPDwgLW5CaXRzKSAtIDE7XG4gIGUgPj49IC1uQml0cztcbiAgbkJpdHMgKz0gbUxlbjtcbiAgZm9yKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltpXSwgaS0tLCBuQml0cyAtPSA4KTtcbiAgaWYoZSA9PT0gMCl7XG4gICAgZSA9IDEgLSBlQmlhcztcbiAgfSBlbHNlIGlmKGUgPT09IGVNYXgpe1xuICAgIHJldHVybiBtID8gTmFOIDogcyA/IC1JbmZpbml0eSA6IEluZmluaXR5O1xuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgcG93KDIsIG1MZW4pO1xuICAgIGUgPSBlIC0gZUJpYXM7XG4gIH0gcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBwb3coMiwgZSAtIG1MZW4pO1xufTtcblxudmFyIHVucGFja0kzMiA9IGZ1bmN0aW9uKGJ5dGVzKXtcbiAgcmV0dXJuIGJ5dGVzWzNdIDw8IDI0IHwgYnl0ZXNbMl0gPDwgMTYgfCBieXRlc1sxXSA8PCA4IHwgYnl0ZXNbMF07XG59O1xudmFyIHBhY2tJOCA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIFtpdCAmIDB4ZmZdO1xufTtcbnZhciBwYWNrSTE2ID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gW2l0ICYgMHhmZiwgaXQgPj4gOCAmIDB4ZmZdO1xufTtcbnZhciBwYWNrSTMyID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gW2l0ICYgMHhmZiwgaXQgPj4gOCAmIDB4ZmYsIGl0ID4+IDE2ICYgMHhmZiwgaXQgPj4gMjQgJiAweGZmXTtcbn07XG52YXIgcGFja0Y2NCA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIHBhY2tJRUVFNzU0KGl0LCA1MiwgOCk7XG59O1xudmFyIHBhY2tGMzIgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBwYWNrSUVFRTc1NChpdCwgMjMsIDQpO1xufTtcblxudmFyIGFkZEdldHRlciA9IGZ1bmN0aW9uKEMsIGtleSwgaW50ZXJuYWwpe1xuICBkUChDW1BST1RPVFlQRV0sIGtleSwge2dldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXNbaW50ZXJuYWxdOyB9fSk7XG59O1xuXG52YXIgZ2V0ID0gZnVuY3Rpb24odmlldywgYnl0ZXMsIGluZGV4LCBpc0xpdHRsZUVuZGlhbil7XG4gIHZhciBudW1JbmRleCA9ICtpbmRleFxuICAgICwgaW50SW5kZXggPSB0b0ludGVnZXIobnVtSW5kZXgpO1xuICBpZihudW1JbmRleCAhPSBpbnRJbmRleCB8fCBpbnRJbmRleCA8IDAgfHwgaW50SW5kZXggKyBieXRlcyA+IHZpZXdbJExFTkdUSF0pdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19JTkRFWCk7XG4gIHZhciBzdG9yZSA9IHZpZXdbJEJVRkZFUl0uX2JcbiAgICAsIHN0YXJ0ID0gaW50SW5kZXggKyB2aWV3WyRPRkZTRVRdXG4gICAgLCBwYWNrICA9IHN0b3JlLnNsaWNlKHN0YXJ0LCBzdGFydCArIGJ5dGVzKTtcbiAgcmV0dXJuIGlzTGl0dGxlRW5kaWFuID8gcGFjayA6IHBhY2sucmV2ZXJzZSgpO1xufTtcbnZhciBzZXQgPSBmdW5jdGlvbih2aWV3LCBieXRlcywgaW5kZXgsIGNvbnZlcnNpb24sIHZhbHVlLCBpc0xpdHRsZUVuZGlhbil7XG4gIHZhciBudW1JbmRleCA9ICtpbmRleFxuICAgICwgaW50SW5kZXggPSB0b0ludGVnZXIobnVtSW5kZXgpO1xuICBpZihudW1JbmRleCAhPSBpbnRJbmRleCB8fCBpbnRJbmRleCA8IDAgfHwgaW50SW5kZXggKyBieXRlcyA+IHZpZXdbJExFTkdUSF0pdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19JTkRFWCk7XG4gIHZhciBzdG9yZSA9IHZpZXdbJEJVRkZFUl0uX2JcbiAgICAsIHN0YXJ0ID0gaW50SW5kZXggKyB2aWV3WyRPRkZTRVRdXG4gICAgLCBwYWNrICA9IGNvbnZlcnNpb24oK3ZhbHVlKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGJ5dGVzOyBpKyspc3RvcmVbc3RhcnQgKyBpXSA9IHBhY2tbaXNMaXR0bGVFbmRpYW4gPyBpIDogYnl0ZXMgLSBpIC0gMV07XG59O1xuXG52YXIgdmFsaWRhdGVBcnJheUJ1ZmZlckFyZ3VtZW50cyA9IGZ1bmN0aW9uKHRoYXQsIGxlbmd0aCl7XG4gIGFuSW5zdGFuY2UodGhhdCwgJEFycmF5QnVmZmVyLCBBUlJBWV9CVUZGRVIpO1xuICB2YXIgbnVtYmVyTGVuZ3RoID0gK2xlbmd0aFxuICAgICwgYnl0ZUxlbmd0aCAgID0gdG9MZW5ndGgobnVtYmVyTGVuZ3RoKTtcbiAgaWYobnVtYmVyTGVuZ3RoICE9IGJ5dGVMZW5ndGgpdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuICByZXR1cm4gYnl0ZUxlbmd0aDtcbn07XG5cbmlmKCEkdHlwZWQuQUJWKXtcbiAgJEFycmF5QnVmZmVyID0gZnVuY3Rpb24gQXJyYXlCdWZmZXIobGVuZ3RoKXtcbiAgICB2YXIgYnl0ZUxlbmd0aCA9IHZhbGlkYXRlQXJyYXlCdWZmZXJBcmd1bWVudHModGhpcywgbGVuZ3RoKTtcbiAgICB0aGlzLl9iICAgICAgID0gYXJyYXlGaWxsLmNhbGwoQXJyYXkoYnl0ZUxlbmd0aCksIDApO1xuICAgIHRoaXNbJExFTkdUSF0gPSBieXRlTGVuZ3RoO1xuICB9O1xuXG4gICREYXRhVmlldyA9IGZ1bmN0aW9uIERhdGFWaWV3KGJ1ZmZlciwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCl7XG4gICAgYW5JbnN0YW5jZSh0aGlzLCAkRGF0YVZpZXcsIERBVEFfVklFVyk7XG4gICAgYW5JbnN0YW5jZShidWZmZXIsICRBcnJheUJ1ZmZlciwgREFUQV9WSUVXKTtcbiAgICB2YXIgYnVmZmVyTGVuZ3RoID0gYnVmZmVyWyRMRU5HVEhdXG4gICAgICAsIG9mZnNldCAgICAgICA9IHRvSW50ZWdlcihieXRlT2Zmc2V0KTtcbiAgICBpZihvZmZzZXQgPCAwIHx8IG9mZnNldCA+IGJ1ZmZlckxlbmd0aCl0aHJvdyBSYW5nZUVycm9yKCdXcm9uZyBvZmZzZXQhJyk7XG4gICAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPT09IHVuZGVmaW5lZCA/IGJ1ZmZlckxlbmd0aCAtIG9mZnNldCA6IHRvTGVuZ3RoKGJ5dGVMZW5ndGgpO1xuICAgIGlmKG9mZnNldCArIGJ5dGVMZW5ndGggPiBidWZmZXJMZW5ndGgpdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuICAgIHRoaXNbJEJVRkZFUl0gPSBidWZmZXI7XG4gICAgdGhpc1skT0ZGU0VUXSA9IG9mZnNldDtcbiAgICB0aGlzWyRMRU5HVEhdID0gYnl0ZUxlbmd0aDtcbiAgfTtcblxuICBpZihERVNDUklQVE9SUyl7XG4gICAgYWRkR2V0dGVyKCRBcnJheUJ1ZmZlciwgQllURV9MRU5HVEgsICdfbCcpO1xuICAgIGFkZEdldHRlcigkRGF0YVZpZXcsIEJVRkZFUiwgJ19iJyk7XG4gICAgYWRkR2V0dGVyKCREYXRhVmlldywgQllURV9MRU5HVEgsICdfbCcpO1xuICAgIGFkZEdldHRlcigkRGF0YVZpZXcsIEJZVEVfT0ZGU0VULCAnX28nKTtcbiAgfVxuXG4gIHJlZGVmaW5lQWxsKCREYXRhVmlld1tQUk9UT1RZUEVdLCB7XG4gICAgZ2V0SW50ODogZnVuY3Rpb24gZ2V0SW50OChieXRlT2Zmc2V0KXtcbiAgICAgIHJldHVybiBnZXQodGhpcywgMSwgYnl0ZU9mZnNldClbMF0gPDwgMjQgPj4gMjQ7XG4gICAgfSxcbiAgICBnZXRVaW50ODogZnVuY3Rpb24gZ2V0VWludDgoYnl0ZU9mZnNldCl7XG4gICAgICByZXR1cm4gZ2V0KHRoaXMsIDEsIGJ5dGVPZmZzZXQpWzBdO1xuICAgIH0sXG4gICAgZ2V0SW50MTY6IGZ1bmN0aW9uIGdldEludDE2KGJ5dGVPZmZzZXQgLyosIGxpdHRsZUVuZGlhbiAqLyl7XG4gICAgICB2YXIgYnl0ZXMgPSBnZXQodGhpcywgMiwgYnl0ZU9mZnNldCwgYXJndW1lbnRzWzFdKTtcbiAgICAgIHJldHVybiAoYnl0ZXNbMV0gPDwgOCB8IGJ5dGVzWzBdKSA8PCAxNiA+PiAxNjtcbiAgICB9LFxuICAgIGdldFVpbnQxNjogZnVuY3Rpb24gZ2V0VWludDE2KGJ5dGVPZmZzZXQgLyosIGxpdHRsZUVuZGlhbiAqLyl7XG4gICAgICB2YXIgYnl0ZXMgPSBnZXQodGhpcywgMiwgYnl0ZU9mZnNldCwgYXJndW1lbnRzWzFdKTtcbiAgICAgIHJldHVybiBieXRlc1sxXSA8PCA4IHwgYnl0ZXNbMF07XG4gICAgfSxcbiAgICBnZXRJbnQzMjogZnVuY3Rpb24gZ2V0SW50MzIoYnl0ZU9mZnNldCAvKiwgbGl0dGxlRW5kaWFuICovKXtcbiAgICAgIHJldHVybiB1bnBhY2tJMzIoZ2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50c1sxXSkpO1xuICAgIH0sXG4gICAgZ2V0VWludDMyOiBmdW5jdGlvbiBnZXRVaW50MzIoYnl0ZU9mZnNldCAvKiwgbGl0dGxlRW5kaWFuICovKXtcbiAgICAgIHJldHVybiB1bnBhY2tJMzIoZ2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50c1sxXSkpID4+PiAwO1xuICAgIH0sXG4gICAgZ2V0RmxvYXQzMjogZnVuY3Rpb24gZ2V0RmxvYXQzMihieXRlT2Zmc2V0IC8qLCBsaXR0bGVFbmRpYW4gKi8pe1xuICAgICAgcmV0dXJuIHVucGFja0lFRUU3NTQoZ2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50c1sxXSksIDIzLCA0KTtcbiAgICB9LFxuICAgIGdldEZsb2F0NjQ6IGZ1bmN0aW9uIGdldEZsb2F0NjQoYnl0ZU9mZnNldCAvKiwgbGl0dGxlRW5kaWFuICovKXtcbiAgICAgIHJldHVybiB1bnBhY2tJRUVFNzU0KGdldCh0aGlzLCA4LCBieXRlT2Zmc2V0LCBhcmd1bWVudHNbMV0pLCA1MiwgOCk7XG4gICAgfSxcbiAgICBzZXRJbnQ4OiBmdW5jdGlvbiBzZXRJbnQ4KGJ5dGVPZmZzZXQsIHZhbHVlKXtcbiAgICAgIHNldCh0aGlzLCAxLCBieXRlT2Zmc2V0LCBwYWNrSTgsIHZhbHVlKTtcbiAgICB9LFxuICAgIHNldFVpbnQ4OiBmdW5jdGlvbiBzZXRVaW50OChieXRlT2Zmc2V0LCB2YWx1ZSl7XG4gICAgICBzZXQodGhpcywgMSwgYnl0ZU9mZnNldCwgcGFja0k4LCB2YWx1ZSk7XG4gICAgfSxcbiAgICBzZXRJbnQxNjogZnVuY3Rpb24gc2V0SW50MTYoYnl0ZU9mZnNldCwgdmFsdWUgLyosIGxpdHRsZUVuZGlhbiAqLyl7XG4gICAgICBzZXQodGhpcywgMiwgYnl0ZU9mZnNldCwgcGFja0kxNiwgdmFsdWUsIGFyZ3VtZW50c1syXSk7XG4gICAgfSxcbiAgICBzZXRVaW50MTY6IGZ1bmN0aW9uIHNldFVpbnQxNihieXRlT2Zmc2V0LCB2YWx1ZSAvKiwgbGl0dGxlRW5kaWFuICovKXtcbiAgICAgIHNldCh0aGlzLCAyLCBieXRlT2Zmc2V0LCBwYWNrSTE2LCB2YWx1ZSwgYXJndW1lbnRzWzJdKTtcbiAgICB9LFxuICAgIHNldEludDMyOiBmdW5jdGlvbiBzZXRJbnQzMihieXRlT2Zmc2V0LCB2YWx1ZSAvKiwgbGl0dGxlRW5kaWFuICovKXtcbiAgICAgIHNldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBwYWNrSTMyLCB2YWx1ZSwgYXJndW1lbnRzWzJdKTtcbiAgICB9LFxuICAgIHNldFVpbnQzMjogZnVuY3Rpb24gc2V0VWludDMyKGJ5dGVPZmZzZXQsIHZhbHVlIC8qLCBsaXR0bGVFbmRpYW4gKi8pe1xuICAgICAgc2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIHBhY2tJMzIsIHZhbHVlLCBhcmd1bWVudHNbMl0pO1xuICAgIH0sXG4gICAgc2V0RmxvYXQzMjogZnVuY3Rpb24gc2V0RmxvYXQzMihieXRlT2Zmc2V0LCB2YWx1ZSAvKiwgbGl0dGxlRW5kaWFuICovKXtcbiAgICAgIHNldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBwYWNrRjMyLCB2YWx1ZSwgYXJndW1lbnRzWzJdKTtcbiAgICB9LFxuICAgIHNldEZsb2F0NjQ6IGZ1bmN0aW9uIHNldEZsb2F0NjQoYnl0ZU9mZnNldCwgdmFsdWUgLyosIGxpdHRsZUVuZGlhbiAqLyl7XG4gICAgICBzZXQodGhpcywgOCwgYnl0ZU9mZnNldCwgcGFja0Y2NCwgdmFsdWUsIGFyZ3VtZW50c1syXSk7XG4gICAgfVxuICB9KTtcbn0gZWxzZSB7XG4gIGlmKCFmYWlscyhmdW5jdGlvbigpe1xuICAgIG5ldyAkQXJyYXlCdWZmZXI7ICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICB9KSB8fCAhZmFpbHMoZnVuY3Rpb24oKXtcbiAgICBuZXcgJEFycmF5QnVmZmVyKC41KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgfSkpe1xuICAgICRBcnJheUJ1ZmZlciA9IGZ1bmN0aW9uIEFycmF5QnVmZmVyKGxlbmd0aCl7XG4gICAgICByZXR1cm4gbmV3IEJhc2VCdWZmZXIodmFsaWRhdGVBcnJheUJ1ZmZlckFyZ3VtZW50cyh0aGlzLCBsZW5ndGgpKTtcbiAgICB9O1xuICAgIHZhciBBcnJheUJ1ZmZlclByb3RvID0gJEFycmF5QnVmZmVyW1BST1RPVFlQRV0gPSBCYXNlQnVmZmVyW1BST1RPVFlQRV07XG4gICAgZm9yKHZhciBrZXlzID0gZ09QTihCYXNlQnVmZmVyKSwgaiA9IDAsIGtleTsga2V5cy5sZW5ndGggPiBqOyApe1xuICAgICAgaWYoISgoa2V5ID0ga2V5c1tqKytdKSBpbiAkQXJyYXlCdWZmZXIpKWhpZGUoJEFycmF5QnVmZmVyLCBrZXksIEJhc2VCdWZmZXJba2V5XSk7XG4gICAgfTtcbiAgICBpZighTElCUkFSWSlBcnJheUJ1ZmZlclByb3RvLmNvbnN0cnVjdG9yID0gJEFycmF5QnVmZmVyO1xuICB9XG4gIC8vIGlPUyBTYWZhcmkgNy54IGJ1Z1xuICB2YXIgdmlldyA9IG5ldyAkRGF0YVZpZXcobmV3ICRBcnJheUJ1ZmZlcigyKSlcbiAgICAsICRzZXRJbnQ4ID0gJERhdGFWaWV3W1BST1RPVFlQRV0uc2V0SW50ODtcbiAgdmlldy5zZXRJbnQ4KDAsIDIxNDc0ODM2NDgpO1xuICB2aWV3LnNldEludDgoMSwgMjE0NzQ4MzY0OSk7XG4gIGlmKHZpZXcuZ2V0SW50OCgwKSB8fCAhdmlldy5nZXRJbnQ4KDEpKXJlZGVmaW5lQWxsKCREYXRhVmlld1tQUk9UT1RZUEVdLCB7XG4gICAgc2V0SW50ODogZnVuY3Rpb24gc2V0SW50OChieXRlT2Zmc2V0LCB2YWx1ZSl7XG4gICAgICAkc2V0SW50OC5jYWxsKHRoaXMsIGJ5dGVPZmZzZXQsIHZhbHVlIDw8IDI0ID4+IDI0KTtcbiAgICB9LFxuICAgIHNldFVpbnQ4OiBmdW5jdGlvbiBzZXRVaW50OChieXRlT2Zmc2V0LCB2YWx1ZSl7XG4gICAgICAkc2V0SW50OC5jYWxsKHRoaXMsIGJ5dGVPZmZzZXQsIHZhbHVlIDw8IDI0ID4+IDI0KTtcbiAgICB9XG4gIH0sIHRydWUpO1xufVxuc2V0VG9TdHJpbmdUYWcoJEFycmF5QnVmZmVyLCBBUlJBWV9CVUZGRVIpO1xuc2V0VG9TdHJpbmdUYWcoJERhdGFWaWV3LCBEQVRBX1ZJRVcpO1xuaGlkZSgkRGF0YVZpZXdbUFJPVE9UWVBFXSwgJHR5cGVkLlZJRVcsIHRydWUpO1xuZXhwb3J0c1tBUlJBWV9CVUZGRVJdID0gJEFycmF5QnVmZmVyO1xuZXhwb3J0c1tEQVRBX1ZJRVddID0gJERhdGFWaWV3O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fdHlwZWQtYnVmZmVyLmpzXG4gKiogbW9kdWxlIGlkID0gMjIwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fdHlwZWQnKS5BQlYsIHtcbiAgRGF0YVZpZXc6IHJlcXVpcmUoJy4vX3R5cGVkLWJ1ZmZlcicpLkRhdGFWaWV3XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmRhdGEtdmlldy5qc1xuICoqIG1vZHVsZSBpZCA9IDIyMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnSW50OCcsIDEsIGZ1bmN0aW9uKGluaXQpe1xuICByZXR1cm4gZnVuY3Rpb24gSW50OEFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCl7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuaW50OC1hcnJheS5qc1xuICoqIG1vZHVsZSBpZCA9IDIyMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuaWYocmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSl7XG4gIHZhciBMSUJSQVJZICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fbGlicmFyeScpXG4gICAgLCBnbG9iYWwgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgICAsIGZhaWxzICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19mYWlscycpXG4gICAgLCAkZXhwb3J0ICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgICAsICR0eXBlZCAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL190eXBlZCcpXG4gICAgLCAkYnVmZmVyICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fdHlwZWQtYnVmZmVyJylcbiAgICAsIGN0eCAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19jdHgnKVxuICAgICwgYW5JbnN0YW5jZSAgICAgICAgICA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJylcbiAgICAsIHByb3BlcnR5RGVzYyAgICAgICAgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJylcbiAgICAsIGhpZGUgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgICAsIHJlZGVmaW5lQWxsICAgICAgICAgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKVxuICAgICwgaXNJbnRlZ2VyICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2lzLWludGVnZXInKVxuICAgICwgdG9JbnRlZ2VyICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKVxuICAgICwgdG9MZW5ndGggICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpXG4gICAgLCB0b0luZGV4ICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fdG8taW5kZXgnKVxuICAgICwgdG9QcmltaXRpdmUgICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpXG4gICAgLCBoYXMgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgICAsIHNhbWUgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19zYW1lLXZhbHVlJylcbiAgICAsIGNsYXNzb2YgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19jbGFzc29mJylcbiAgICAsIGlzT2JqZWN0ICAgICAgICAgICAgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAgICwgdG9PYmplY3QgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICAgLCBpc0FycmF5SXRlciAgICAgICAgID0gcmVxdWlyZSgnLi9faXMtYXJyYXktaXRlcicpXG4gICAgLCBjcmVhdGUgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpXG4gICAgLCBnZXRQcm90b3R5cGVPZiAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpXG4gICAgLCBnT1BOICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mXG4gICAgLCBpc0l0ZXJhYmxlICAgICAgICAgID0gcmVxdWlyZSgnLi9jb3JlLmlzLWl0ZXJhYmxlJylcbiAgICAsIGdldEl0ZXJGbiAgICAgICAgICAgPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpXG4gICAgLCB1aWQgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fdWlkJylcbiAgICAsIHdrcyAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL193a3MnKVxuICAgICwgY3JlYXRlQXJyYXlNZXRob2QgICA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKVxuICAgICwgY3JlYXRlQXJyYXlJbmNsdWRlcyA9IHJlcXVpcmUoJy4vX2FycmF5LWluY2x1ZGVzJylcbiAgICAsIHNwZWNpZXNDb25zdHJ1Y3RvciAgPSByZXF1aXJlKCcuL19zcGVjaWVzLWNvbnN0cnVjdG9yJylcbiAgICAsIEFycmF5SXRlcmF0b3JzICAgICAgPSByZXF1aXJlKCcuL2VzNi5hcnJheS5pdGVyYXRvcicpXG4gICAgLCBJdGVyYXRvcnMgICAgICAgICAgID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJylcbiAgICAsICRpdGVyRGV0ZWN0ICAgICAgICAgPSByZXF1aXJlKCcuL19pdGVyLWRldGVjdCcpXG4gICAgLCBzZXRTcGVjaWVzICAgICAgICAgID0gcmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKVxuICAgICwgYXJyYXlGaWxsICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2FycmF5LWZpbGwnKVxuICAgICwgYXJyYXlDb3B5V2l0aGluICAgICA9IHJlcXVpcmUoJy4vX2FycmF5LWNvcHktd2l0aGluJylcbiAgICAsICREUCAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKVxuICAgICwgJEdPUEQgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJylcbiAgICAsIGRQICAgICAgICAgICAgICAgICAgPSAkRFAuZlxuICAgICwgZ09QRCAgICAgICAgICAgICAgICA9ICRHT1BELmZcbiAgICAsIFJhbmdlRXJyb3IgICAgICAgICAgPSBnbG9iYWwuUmFuZ2VFcnJvclxuICAgICwgVHlwZUVycm9yICAgICAgICAgICA9IGdsb2JhbC5UeXBlRXJyb3JcbiAgICAsIFVpbnQ4QXJyYXkgICAgICAgICAgPSBnbG9iYWwuVWludDhBcnJheVxuICAgICwgQVJSQVlfQlVGRkVSICAgICAgICA9ICdBcnJheUJ1ZmZlcidcbiAgICAsIFNIQVJFRF9CVUZGRVIgICAgICAgPSAnU2hhcmVkJyArIEFSUkFZX0JVRkZFUlxuICAgICwgQllURVNfUEVSX0VMRU1FTlQgICA9ICdCWVRFU19QRVJfRUxFTUVOVCdcbiAgICAsIFBST1RPVFlQRSAgICAgICAgICAgPSAncHJvdG90eXBlJ1xuICAgICwgQXJyYXlQcm90byAgICAgICAgICA9IEFycmF5W1BST1RPVFlQRV1cbiAgICAsICRBcnJheUJ1ZmZlciAgICAgICAgPSAkYnVmZmVyLkFycmF5QnVmZmVyXG4gICAgLCAkRGF0YVZpZXcgICAgICAgICAgID0gJGJ1ZmZlci5EYXRhVmlld1xuICAgICwgYXJyYXlGb3JFYWNoICAgICAgICA9IGNyZWF0ZUFycmF5TWV0aG9kKDApXG4gICAgLCBhcnJheUZpbHRlciAgICAgICAgID0gY3JlYXRlQXJyYXlNZXRob2QoMilcbiAgICAsIGFycmF5U29tZSAgICAgICAgICAgPSBjcmVhdGVBcnJheU1ldGhvZCgzKVxuICAgICwgYXJyYXlFdmVyeSAgICAgICAgICA9IGNyZWF0ZUFycmF5TWV0aG9kKDQpXG4gICAgLCBhcnJheUZpbmQgICAgICAgICAgID0gY3JlYXRlQXJyYXlNZXRob2QoNSlcbiAgICAsIGFycmF5RmluZEluZGV4ICAgICAgPSBjcmVhdGVBcnJheU1ldGhvZCg2KVxuICAgICwgYXJyYXlJbmNsdWRlcyAgICAgICA9IGNyZWF0ZUFycmF5SW5jbHVkZXModHJ1ZSlcbiAgICAsIGFycmF5SW5kZXhPZiAgICAgICAgPSBjcmVhdGVBcnJheUluY2x1ZGVzKGZhbHNlKVxuICAgICwgYXJyYXlWYWx1ZXMgICAgICAgICA9IEFycmF5SXRlcmF0b3JzLnZhbHVlc1xuICAgICwgYXJyYXlLZXlzICAgICAgICAgICA9IEFycmF5SXRlcmF0b3JzLmtleXNcbiAgICAsIGFycmF5RW50cmllcyAgICAgICAgPSBBcnJheUl0ZXJhdG9ycy5lbnRyaWVzXG4gICAgLCBhcnJheUxhc3RJbmRleE9mICAgID0gQXJyYXlQcm90by5sYXN0SW5kZXhPZlxuICAgICwgYXJyYXlSZWR1Y2UgICAgICAgICA9IEFycmF5UHJvdG8ucmVkdWNlXG4gICAgLCBhcnJheVJlZHVjZVJpZ2h0ICAgID0gQXJyYXlQcm90by5yZWR1Y2VSaWdodFxuICAgICwgYXJyYXlKb2luICAgICAgICAgICA9IEFycmF5UHJvdG8uam9pblxuICAgICwgYXJyYXlTb3J0ICAgICAgICAgICA9IEFycmF5UHJvdG8uc29ydFxuICAgICwgYXJyYXlTbGljZSAgICAgICAgICA9IEFycmF5UHJvdG8uc2xpY2VcbiAgICAsIGFycmF5VG9TdHJpbmcgICAgICAgPSBBcnJheVByb3RvLnRvU3RyaW5nXG4gICAgLCBhcnJheVRvTG9jYWxlU3RyaW5nID0gQXJyYXlQcm90by50b0xvY2FsZVN0cmluZ1xuICAgICwgSVRFUkFUT1IgICAgICAgICAgICA9IHdrcygnaXRlcmF0b3InKVxuICAgICwgVEFHICAgICAgICAgICAgICAgICA9IHdrcygndG9TdHJpbmdUYWcnKVxuICAgICwgVFlQRURfQ09OU1RSVUNUT1IgICA9IHVpZCgndHlwZWRfY29uc3RydWN0b3InKVxuICAgICwgREVGX0NPTlNUUlVDVE9SICAgICA9IHVpZCgnZGVmX2NvbnN0cnVjdG9yJylcbiAgICAsIEFMTF9DT05TVFJVQ1RPUlMgICAgPSAkdHlwZWQuQ09OU1RSXG4gICAgLCBUWVBFRF9BUlJBWSAgICAgICAgID0gJHR5cGVkLlRZUEVEXG4gICAgLCBWSUVXICAgICAgICAgICAgICAgID0gJHR5cGVkLlZJRVdcbiAgICAsIFdST05HX0xFTkdUSCAgICAgICAgPSAnV3JvbmcgbGVuZ3RoISc7XG5cbiAgdmFyICRtYXAgPSBjcmVhdGVBcnJheU1ldGhvZCgxLCBmdW5jdGlvbihPLCBsZW5ndGgpe1xuICAgIHJldHVybiBhbGxvY2F0ZShzcGVjaWVzQ29uc3RydWN0b3IoTywgT1tERUZfQ09OU1RSVUNUT1JdKSwgbGVuZ3RoKTtcbiAgfSk7XG5cbiAgdmFyIExJVFRMRV9FTkRJQU4gPSBmYWlscyhmdW5jdGlvbigpe1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShuZXcgVWludDE2QXJyYXkoWzFdKS5idWZmZXIpWzBdID09PSAxO1xuICB9KTtcblxuICB2YXIgRk9SQ0VEX1NFVCA9ICEhVWludDhBcnJheSAmJiAhIVVpbnQ4QXJyYXlbUFJPVE9UWVBFXS5zZXQgJiYgZmFpbHMoZnVuY3Rpb24oKXtcbiAgICBuZXcgVWludDhBcnJheSgxKS5zZXQoe30pO1xuICB9KTtcblxuICB2YXIgc3RyaWN0VG9MZW5ndGggPSBmdW5jdGlvbihpdCwgU0FNRSl7XG4gICAgaWYoaXQgPT09IHVuZGVmaW5lZCl0aHJvdyBUeXBlRXJyb3IoV1JPTkdfTEVOR1RIKTtcbiAgICB2YXIgbnVtYmVyID0gK2l0XG4gICAgICAsIGxlbmd0aCA9IHRvTGVuZ3RoKGl0KTtcbiAgICBpZihTQU1FICYmICFzYW1lKG51bWJlciwgbGVuZ3RoKSl0aHJvdyBSYW5nZUVycm9yKFdST05HX0xFTkdUSCk7XG4gICAgcmV0dXJuIGxlbmd0aDtcbiAgfTtcblxuICB2YXIgdG9PZmZzZXQgPSBmdW5jdGlvbihpdCwgQllURVMpe1xuICAgIHZhciBvZmZzZXQgPSB0b0ludGVnZXIoaXQpO1xuICAgIGlmKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICUgQllURVMpdGhyb3cgUmFuZ2VFcnJvcignV3Jvbmcgb2Zmc2V0IScpO1xuICAgIHJldHVybiBvZmZzZXQ7XG4gIH07XG5cbiAgdmFyIHZhbGlkYXRlID0gZnVuY3Rpb24oaXQpe1xuICAgIGlmKGlzT2JqZWN0KGl0KSAmJiBUWVBFRF9BUlJBWSBpbiBpdClyZXR1cm4gaXQ7XG4gICAgdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYSB0eXBlZCBhcnJheSEnKTtcbiAgfTtcblxuICB2YXIgYWxsb2NhdGUgPSBmdW5jdGlvbihDLCBsZW5ndGgpe1xuICAgIGlmKCEoaXNPYmplY3QoQykgJiYgVFlQRURfQ09OU1RSVUNUT1IgaW4gQykpe1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdJdCBpcyBub3QgYSB0eXBlZCBhcnJheSBjb25zdHJ1Y3RvciEnKTtcbiAgICB9IHJldHVybiBuZXcgQyhsZW5ndGgpO1xuICB9O1xuXG4gIHZhciBzcGVjaWVzRnJvbUxpc3QgPSBmdW5jdGlvbihPLCBsaXN0KXtcbiAgICByZXR1cm4gZnJvbUxpc3Qoc3BlY2llc0NvbnN0cnVjdG9yKE8sIE9bREVGX0NPTlNUUlVDVE9SXSksIGxpc3QpO1xuICB9O1xuXG4gIHZhciBmcm9tTGlzdCA9IGZ1bmN0aW9uKEMsIGxpc3Qpe1xuICAgIHZhciBpbmRleCAgPSAwXG4gICAgICAsIGxlbmd0aCA9IGxpc3QubGVuZ3RoXG4gICAgICAsIHJlc3VsdCA9IGFsbG9jYXRlKEMsIGxlbmd0aCk7XG4gICAgd2hpbGUobGVuZ3RoID4gaW5kZXgpcmVzdWx0W2luZGV4XSA9IGxpc3RbaW5kZXgrK107XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICB2YXIgYWRkR2V0dGVyID0gZnVuY3Rpb24oaXQsIGtleSwgaW50ZXJuYWwpe1xuICAgIGRQKGl0LCBrZXksIHtnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLl9kW2ludGVybmFsXTsgfX0pO1xuICB9O1xuXG4gIHZhciAkZnJvbSA9IGZ1bmN0aW9uIGZyb20oc291cmNlIC8qLCBtYXBmbiwgdGhpc0FyZyAqLyl7XG4gICAgdmFyIE8gICAgICAgPSB0b09iamVjdChzb3VyY2UpXG4gICAgICAsIGFMZW4gICAgPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgICAsIG1hcGZuICAgPSBhTGVuID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZFxuICAgICAgLCBtYXBwaW5nID0gbWFwZm4gIT09IHVuZGVmaW5lZFxuICAgICAgLCBpdGVyRm4gID0gZ2V0SXRlckZuKE8pXG4gICAgICAsIGksIGxlbmd0aCwgdmFsdWVzLCByZXN1bHQsIHN0ZXAsIGl0ZXJhdG9yO1xuICAgIGlmKGl0ZXJGbiAhPSB1bmRlZmluZWQgJiYgIWlzQXJyYXlJdGVyKGl0ZXJGbikpe1xuICAgICAgZm9yKGl0ZXJhdG9yID0gaXRlckZuLmNhbGwoTyksIHZhbHVlcyA9IFtdLCBpID0gMDsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOyBpKyspe1xuICAgICAgICB2YWx1ZXMucHVzaChzdGVwLnZhbHVlKTtcbiAgICAgIH0gTyA9IHZhbHVlcztcbiAgICB9XG4gICAgaWYobWFwcGluZyAmJiBhTGVuID4gMiltYXBmbiA9IGN0eChtYXBmbiwgYXJndW1lbnRzWzJdLCAyKTtcbiAgICBmb3IoaSA9IDAsIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKSwgcmVzdWx0ID0gYWxsb2NhdGUodGhpcywgbGVuZ3RoKTsgbGVuZ3RoID4gaTsgaSsrKXtcbiAgICAgIHJlc3VsdFtpXSA9IG1hcHBpbmcgPyBtYXBmbihPW2ldLCBpKSA6IE9baV07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgdmFyICRvZiA9IGZ1bmN0aW9uIG9mKC8qLi4uaXRlbXMqLyl7XG4gICAgdmFyIGluZGV4ICA9IDBcbiAgICAgICwgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgLCByZXN1bHQgPSBhbGxvY2F0ZSh0aGlzLCBsZW5ndGgpO1xuICAgIHdoaWxlKGxlbmd0aCA+IGluZGV4KXJlc3VsdFtpbmRleF0gPSBhcmd1bWVudHNbaW5kZXgrK107XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBpT1MgU2FmYXJpIDYueCBmYWlscyBoZXJlXG4gIHZhciBUT19MT0NBTEVfQlVHID0gISFVaW50OEFycmF5ICYmIGZhaWxzKGZ1bmN0aW9uKCl7IGFycmF5VG9Mb2NhbGVTdHJpbmcuY2FsbChuZXcgVWludDhBcnJheSgxKSk7IH0pO1xuXG4gIHZhciAkdG9Mb2NhbGVTdHJpbmcgPSBmdW5jdGlvbiB0b0xvY2FsZVN0cmluZygpe1xuICAgIHJldHVybiBhcnJheVRvTG9jYWxlU3RyaW5nLmFwcGx5KFRPX0xPQ0FMRV9CVUcgPyBhcnJheVNsaWNlLmNhbGwodmFsaWRhdGUodGhpcykpIDogdmFsaWRhdGUodGhpcyksIGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgdmFyIHByb3RvID0ge1xuICAgIGNvcHlXaXRoaW46IGZ1bmN0aW9uIGNvcHlXaXRoaW4odGFyZ2V0LCBzdGFydCAvKiwgZW5kICovKXtcbiAgICAgIHJldHVybiBhcnJheUNvcHlXaXRoaW4uY2FsbCh2YWxpZGF0ZSh0aGlzKSwgdGFyZ2V0LCBzdGFydCwgYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgZXZlcnk6IGZ1bmN0aW9uIGV2ZXJ5KGNhbGxiYWNrZm4gLyosIHRoaXNBcmcgKi8pe1xuICAgICAgcmV0dXJuIGFycmF5RXZlcnkodmFsaWRhdGUodGhpcyksIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGZpbGw6IGZ1bmN0aW9uIGZpbGwodmFsdWUgLyosIHN0YXJ0LCBlbmQgKi8peyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICByZXR1cm4gYXJyYXlGaWxsLmFwcGx5KHZhbGlkYXRlKHRoaXMpLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgZmlsdGVyOiBmdW5jdGlvbiBmaWx0ZXIoY2FsbGJhY2tmbiAvKiwgdGhpc0FyZyAqLyl7XG4gICAgICByZXR1cm4gc3BlY2llc0Zyb21MaXN0KHRoaXMsIGFycmF5RmlsdGVyKHZhbGlkYXRlKHRoaXMpLCBjYWxsYmFja2ZuLFxuICAgICAgICBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCkpO1xuICAgIH0sXG4gICAgZmluZDogZnVuY3Rpb24gZmluZChwcmVkaWNhdGUgLyosIHRoaXNBcmcgKi8pe1xuICAgICAgcmV0dXJuIGFycmF5RmluZCh2YWxpZGF0ZSh0aGlzKSwgcHJlZGljYXRlLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBmaW5kSW5kZXg6IGZ1bmN0aW9uIGZpbmRJbmRleChwcmVkaWNhdGUgLyosIHRoaXNBcmcgKi8pe1xuICAgICAgcmV0dXJuIGFycmF5RmluZEluZGV4KHZhbGlkYXRlKHRoaXMpLCBwcmVkaWNhdGUsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2tmbiAvKiwgdGhpc0FyZyAqLyl7XG4gICAgICBhcnJheUZvckVhY2godmFsaWRhdGUodGhpcyksIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGluZGV4T2Y6IGZ1bmN0aW9uIGluZGV4T2Yoc2VhcmNoRWxlbWVudCAvKiwgZnJvbUluZGV4ICovKXtcbiAgICAgIHJldHVybiBhcnJheUluZGV4T2YodmFsaWRhdGUodGhpcyksIHNlYXJjaEVsZW1lbnQsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGluY2x1ZGVzOiBmdW5jdGlvbiBpbmNsdWRlcyhzZWFyY2hFbGVtZW50IC8qLCBmcm9tSW5kZXggKi8pe1xuICAgICAgcmV0dXJuIGFycmF5SW5jbHVkZXModmFsaWRhdGUodGhpcyksIHNlYXJjaEVsZW1lbnQsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGpvaW46IGZ1bmN0aW9uIGpvaW4oc2VwYXJhdG9yKXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgcmV0dXJuIGFycmF5Sm9pbi5hcHBseSh2YWxpZGF0ZSh0aGlzKSwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIGxhc3RJbmRleE9mOiBmdW5jdGlvbiBsYXN0SW5kZXhPZihzZWFyY2hFbGVtZW50IC8qLCBmcm9tSW5kZXggKi8peyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICByZXR1cm4gYXJyYXlMYXN0SW5kZXhPZi5hcHBseSh2YWxpZGF0ZSh0aGlzKSwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIG1hcDogZnVuY3Rpb24gbWFwKG1hcGZuIC8qLCB0aGlzQXJnICovKXtcbiAgICAgIHJldHVybiAkbWFwKHZhbGlkYXRlKHRoaXMpLCBtYXBmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgcmVkdWNlOiBmdW5jdGlvbiByZWR1Y2UoY2FsbGJhY2tmbiAvKiwgaW5pdGlhbFZhbHVlICovKXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgcmV0dXJuIGFycmF5UmVkdWNlLmFwcGx5KHZhbGlkYXRlKHRoaXMpLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgcmVkdWNlUmlnaHQ6IGZ1bmN0aW9uIHJlZHVjZVJpZ2h0KGNhbGxiYWNrZm4gLyosIGluaXRpYWxWYWx1ZSAqLyl7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIHJldHVybiBhcnJheVJlZHVjZVJpZ2h0LmFwcGx5KHZhbGlkYXRlKHRoaXMpLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgcmV2ZXJzZTogZnVuY3Rpb24gcmV2ZXJzZSgpe1xuICAgICAgdmFyIHRoYXQgICA9IHRoaXNcbiAgICAgICAgLCBsZW5ndGggPSB2YWxpZGF0ZSh0aGF0KS5sZW5ndGhcbiAgICAgICAgLCBtaWRkbGUgPSBNYXRoLmZsb29yKGxlbmd0aCAvIDIpXG4gICAgICAgICwgaW5kZXggID0gMFxuICAgICAgICAsIHZhbHVlO1xuICAgICAgd2hpbGUoaW5kZXggPCBtaWRkbGUpe1xuICAgICAgICB2YWx1ZSAgICAgICAgID0gdGhhdFtpbmRleF07XG4gICAgICAgIHRoYXRbaW5kZXgrK10gPSB0aGF0Wy0tbGVuZ3RoXTtcbiAgICAgICAgdGhhdFtsZW5ndGhdICA9IHZhbHVlO1xuICAgICAgfSByZXR1cm4gdGhhdDtcbiAgICB9LFxuICAgIHNvbWU6IGZ1bmN0aW9uIHNvbWUoY2FsbGJhY2tmbiAvKiwgdGhpc0FyZyAqLyl7XG4gICAgICByZXR1cm4gYXJyYXlTb21lKHZhbGlkYXRlKHRoaXMpLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBzb3J0OiBmdW5jdGlvbiBzb3J0KGNvbXBhcmVmbil7XG4gICAgICByZXR1cm4gYXJyYXlTb3J0LmNhbGwodmFsaWRhdGUodGhpcyksIGNvbXBhcmVmbik7XG4gICAgfSxcbiAgICBzdWJhcnJheTogZnVuY3Rpb24gc3ViYXJyYXkoYmVnaW4sIGVuZCl7XG4gICAgICB2YXIgTyAgICAgID0gdmFsaWRhdGUodGhpcylcbiAgICAgICAgLCBsZW5ndGggPSBPLmxlbmd0aFxuICAgICAgICAsICRiZWdpbiA9IHRvSW5kZXgoYmVnaW4sIGxlbmd0aCk7XG4gICAgICByZXR1cm4gbmV3IChzcGVjaWVzQ29uc3RydWN0b3IoTywgT1tERUZfQ09OU1RSVUNUT1JdKSkoXG4gICAgICAgIE8uYnVmZmVyLFxuICAgICAgICBPLmJ5dGVPZmZzZXQgKyAkYmVnaW4gKiBPLkJZVEVTX1BFUl9FTEVNRU5ULFxuICAgICAgICB0b0xlbmd0aCgoZW5kID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiB0b0luZGV4KGVuZCwgbGVuZ3RoKSkgLSAkYmVnaW4pXG4gICAgICApO1xuICAgIH1cbiAgfTtcblxuICB2YXIgJHNsaWNlID0gZnVuY3Rpb24gc2xpY2Uoc3RhcnQsIGVuZCl7XG4gICAgcmV0dXJuIHNwZWNpZXNGcm9tTGlzdCh0aGlzLCBhcnJheVNsaWNlLmNhbGwodmFsaWRhdGUodGhpcyksIHN0YXJ0LCBlbmQpKTtcbiAgfTtcblxuICB2YXIgJHNldCA9IGZ1bmN0aW9uIHNldChhcnJheUxpa2UgLyosIG9mZnNldCAqLyl7XG4gICAgdmFsaWRhdGUodGhpcyk7XG4gICAgdmFyIG9mZnNldCA9IHRvT2Zmc2V0KGFyZ3VtZW50c1sxXSwgMSlcbiAgICAgICwgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICAgICwgc3JjICAgID0gdG9PYmplY3QoYXJyYXlMaWtlKVxuICAgICAgLCBsZW4gICAgPSB0b0xlbmd0aChzcmMubGVuZ3RoKVxuICAgICAgLCBpbmRleCAgPSAwO1xuICAgIGlmKGxlbiArIG9mZnNldCA+IGxlbmd0aCl0aHJvdyBSYW5nZUVycm9yKFdST05HX0xFTkdUSCk7XG4gICAgd2hpbGUoaW5kZXggPCBsZW4pdGhpc1tvZmZzZXQgKyBpbmRleF0gPSBzcmNbaW5kZXgrK107XG4gIH07XG5cbiAgdmFyICRpdGVyYXRvcnMgPSB7XG4gICAgZW50cmllczogZnVuY3Rpb24gZW50cmllcygpe1xuICAgICAgcmV0dXJuIGFycmF5RW50cmllcy5jYWxsKHZhbGlkYXRlKHRoaXMpKTtcbiAgICB9LFxuICAgIGtleXM6IGZ1bmN0aW9uIGtleXMoKXtcbiAgICAgIHJldHVybiBhcnJheUtleXMuY2FsbCh2YWxpZGF0ZSh0aGlzKSk7XG4gICAgfSxcbiAgICB2YWx1ZXM6IGZ1bmN0aW9uIHZhbHVlcygpe1xuICAgICAgcmV0dXJuIGFycmF5VmFsdWVzLmNhbGwodmFsaWRhdGUodGhpcykpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaXNUQUluZGV4ID0gZnVuY3Rpb24odGFyZ2V0LCBrZXkpe1xuICAgIHJldHVybiBpc09iamVjdCh0YXJnZXQpXG4gICAgICAmJiB0YXJnZXRbVFlQRURfQVJSQVldXG4gICAgICAmJiB0eXBlb2Yga2V5ICE9ICdzeW1ib2wnXG4gICAgICAmJiBrZXkgaW4gdGFyZ2V0XG4gICAgICAmJiBTdHJpbmcoK2tleSkgPT0gU3RyaW5nKGtleSk7XG4gIH07XG4gIHZhciAkZ2V0RGVzYyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSl7XG4gICAgcmV0dXJuIGlzVEFJbmRleCh0YXJnZXQsIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSkpXG4gICAgICA/IHByb3BlcnR5RGVzYygyLCB0YXJnZXRba2V5XSlcbiAgICAgIDogZ09QRCh0YXJnZXQsIGtleSk7XG4gIH07XG4gIHZhciAkc2V0RGVzYyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBkZXNjKXtcbiAgICBpZihpc1RBSW5kZXgodGFyZ2V0LCBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpKVxuICAgICAgJiYgaXNPYmplY3QoZGVzYylcbiAgICAgICYmIGhhcyhkZXNjLCAndmFsdWUnKVxuICAgICAgJiYgIWhhcyhkZXNjLCAnZ2V0JylcbiAgICAgICYmICFoYXMoZGVzYywgJ3NldCcpXG4gICAgICAvLyBUT0RPOiBhZGQgdmFsaWRhdGlvbiBkZXNjcmlwdG9yIHcvbyBjYWxsaW5nIGFjY2Vzc29yc1xuICAgICAgJiYgIWRlc2MuY29uZmlndXJhYmxlXG4gICAgICAmJiAoIWhhcyhkZXNjLCAnd3JpdGFibGUnKSB8fCBkZXNjLndyaXRhYmxlKVxuICAgICAgJiYgKCFoYXMoZGVzYywgJ2VudW1lcmFibGUnKSB8fCBkZXNjLmVudW1lcmFibGUpXG4gICAgKXtcbiAgICAgIHRhcmdldFtrZXldID0gZGVzYy52YWx1ZTtcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfSBlbHNlIHJldHVybiBkUCh0YXJnZXQsIGtleSwgZGVzYyk7XG4gIH07XG5cbiAgaWYoIUFMTF9DT05TVFJVQ1RPUlMpe1xuICAgICRHT1BELmYgPSAkZ2V0RGVzYztcbiAgICAkRFAuZiAgID0gJHNldERlc2M7XG4gIH1cblxuICAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFBTExfQ09OU1RSVUNUT1JTLCAnT2JqZWN0Jywge1xuICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogJGdldERlc2MsXG4gICAgZGVmaW5lUHJvcGVydHk6ICAgICAgICAgICAkc2V0RGVzY1xuICB9KTtcblxuICBpZihmYWlscyhmdW5jdGlvbigpeyBhcnJheVRvU3RyaW5nLmNhbGwoe30pOyB9KSl7XG4gICAgYXJyYXlUb1N0cmluZyA9IGFycmF5VG9Mb2NhbGVTdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpe1xuICAgICAgcmV0dXJuIGFycmF5Sm9pbi5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIHZhciAkVHlwZWRBcnJheVByb3RvdHlwZSQgPSByZWRlZmluZUFsbCh7fSwgcHJvdG8pO1xuICByZWRlZmluZUFsbCgkVHlwZWRBcnJheVByb3RvdHlwZSQsICRpdGVyYXRvcnMpO1xuICBoaWRlKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgSVRFUkFUT1IsICRpdGVyYXRvcnMudmFsdWVzKTtcbiAgcmVkZWZpbmVBbGwoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCB7XG4gICAgc2xpY2U6ICAgICAgICAgICRzbGljZSxcbiAgICBzZXQ6ICAgICAgICAgICAgJHNldCxcbiAgICBjb25zdHJ1Y3RvcjogICAgZnVuY3Rpb24oKXsgLyogbm9vcCAqLyB9LFxuICAgIHRvU3RyaW5nOiAgICAgICBhcnJheVRvU3RyaW5nLFxuICAgIHRvTG9jYWxlU3RyaW5nOiAkdG9Mb2NhbGVTdHJpbmdcbiAgfSk7XG4gIGFkZEdldHRlcigkVHlwZWRBcnJheVByb3RvdHlwZSQsICdidWZmZXInLCAnYicpO1xuICBhZGRHZXR0ZXIoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCAnYnl0ZU9mZnNldCcsICdvJyk7XG4gIGFkZEdldHRlcigkVHlwZWRBcnJheVByb3RvdHlwZSQsICdieXRlTGVuZ3RoJywgJ2wnKTtcbiAgYWRkR2V0dGVyKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgJ2xlbmd0aCcsICdlJyk7XG4gIGRQKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgVEFHLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpc1tUWVBFRF9BUlJBWV07IH1cbiAgfSk7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihLRVksIEJZVEVTLCB3cmFwcGVyLCBDTEFNUEVEKXtcbiAgICBDTEFNUEVEID0gISFDTEFNUEVEO1xuICAgIHZhciBOQU1FICAgICAgID0gS0VZICsgKENMQU1QRUQgPyAnQ2xhbXBlZCcgOiAnJykgKyAnQXJyYXknXG4gICAgICAsIElTTlRfVUlOVDggPSBOQU1FICE9ICdVaW50OEFycmF5J1xuICAgICAgLCBHRVRURVIgICAgID0gJ2dldCcgKyBLRVlcbiAgICAgICwgU0VUVEVSICAgICA9ICdzZXQnICsgS0VZXG4gICAgICAsIFR5cGVkQXJyYXkgPSBnbG9iYWxbTkFNRV1cbiAgICAgICwgQmFzZSAgICAgICA9IFR5cGVkQXJyYXkgfHwge31cbiAgICAgICwgVEFDICAgICAgICA9IFR5cGVkQXJyYXkgJiYgZ2V0UHJvdG90eXBlT2YoVHlwZWRBcnJheSlcbiAgICAgICwgRk9SQ0VEICAgICA9ICFUeXBlZEFycmF5IHx8ICEkdHlwZWQuQUJWXG4gICAgICAsIE8gICAgICAgICAgPSB7fVxuICAgICAgLCBUeXBlZEFycmF5UHJvdG90eXBlID0gVHlwZWRBcnJheSAmJiBUeXBlZEFycmF5W1BST1RPVFlQRV07XG4gICAgdmFyIGdldHRlciA9IGZ1bmN0aW9uKHRoYXQsIGluZGV4KXtcbiAgICAgIHZhciBkYXRhID0gdGhhdC5fZDtcbiAgICAgIHJldHVybiBkYXRhLnZbR0VUVEVSXShpbmRleCAqIEJZVEVTICsgZGF0YS5vLCBMSVRUTEVfRU5ESUFOKTtcbiAgICB9O1xuICAgIHZhciBzZXR0ZXIgPSBmdW5jdGlvbih0aGF0LCBpbmRleCwgdmFsdWUpe1xuICAgICAgdmFyIGRhdGEgPSB0aGF0Ll9kO1xuICAgICAgaWYoQ0xBTVBFRCl2YWx1ZSA9ICh2YWx1ZSA9IE1hdGgucm91bmQodmFsdWUpKSA8IDAgPyAwIDogdmFsdWUgPiAweGZmID8gMHhmZiA6IHZhbHVlICYgMHhmZjtcbiAgICAgIGRhdGEudltTRVRURVJdKGluZGV4ICogQllURVMgKyBkYXRhLm8sIHZhbHVlLCBMSVRUTEVfRU5ESUFOKTtcbiAgICB9O1xuICAgIHZhciBhZGRFbGVtZW50ID0gZnVuY3Rpb24odGhhdCwgaW5kZXgpe1xuICAgICAgZFAodGhhdCwgaW5kZXgsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpe1xuICAgICAgICAgIHJldHVybiBnZXR0ZXIodGhpcywgaW5kZXgpO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgICAgICByZXR1cm4gc2V0dGVyKHRoaXMsIGluZGV4LCB2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH07XG4gICAgaWYoRk9SQ0VEKXtcbiAgICAgIFR5cGVkQXJyYXkgPSB3cmFwcGVyKGZ1bmN0aW9uKHRoYXQsIGRhdGEsICRvZmZzZXQsICRsZW5ndGgpe1xuICAgICAgICBhbkluc3RhbmNlKHRoYXQsIFR5cGVkQXJyYXksIE5BTUUsICdfZCcpO1xuICAgICAgICB2YXIgaW5kZXggID0gMFxuICAgICAgICAgICwgb2Zmc2V0ID0gMFxuICAgICAgICAgICwgYnVmZmVyLCBieXRlTGVuZ3RoLCBsZW5ndGgsIGtsYXNzO1xuICAgICAgICBpZighaXNPYmplY3QoZGF0YSkpe1xuICAgICAgICAgIGxlbmd0aCAgICAgPSBzdHJpY3RUb0xlbmd0aChkYXRhLCB0cnVlKVxuICAgICAgICAgIGJ5dGVMZW5ndGggPSBsZW5ndGggKiBCWVRFUztcbiAgICAgICAgICBidWZmZXIgICAgID0gbmV3ICRBcnJheUJ1ZmZlcihieXRlTGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIGlmKGRhdGEgaW5zdGFuY2VvZiAkQXJyYXlCdWZmZXIgfHwgKGtsYXNzID0gY2xhc3NvZihkYXRhKSkgPT0gQVJSQVlfQlVGRkVSIHx8IGtsYXNzID09IFNIQVJFRF9CVUZGRVIpe1xuICAgICAgICAgIGJ1ZmZlciA9IGRhdGE7XG4gICAgICAgICAgb2Zmc2V0ID0gdG9PZmZzZXQoJG9mZnNldCwgQllURVMpO1xuICAgICAgICAgIHZhciAkbGVuID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgICAgIGlmKCRsZW5ndGggPT09IHVuZGVmaW5lZCl7XG4gICAgICAgICAgICBpZigkbGVuICUgQllURVMpdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuICAgICAgICAgICAgYnl0ZUxlbmd0aCA9ICRsZW4gLSBvZmZzZXQ7XG4gICAgICAgICAgICBpZihieXRlTGVuZ3RoIDwgMCl0aHJvdyBSYW5nZUVycm9yKFdST05HX0xFTkdUSCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJ5dGVMZW5ndGggPSB0b0xlbmd0aCgkbGVuZ3RoKSAqIEJZVEVTO1xuICAgICAgICAgICAgaWYoYnl0ZUxlbmd0aCArIG9mZnNldCA+ICRsZW4pdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZW5ndGggPSBieXRlTGVuZ3RoIC8gQllURVM7XG4gICAgICAgIH0gZWxzZSBpZihUWVBFRF9BUlJBWSBpbiBkYXRhKXtcbiAgICAgICAgICByZXR1cm4gZnJvbUxpc3QoVHlwZWRBcnJheSwgZGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuICRmcm9tLmNhbGwoVHlwZWRBcnJheSwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaGlkZSh0aGF0LCAnX2QnLCB7XG4gICAgICAgICAgYjogYnVmZmVyLFxuICAgICAgICAgIG86IG9mZnNldCxcbiAgICAgICAgICBsOiBieXRlTGVuZ3RoLFxuICAgICAgICAgIGU6IGxlbmd0aCxcbiAgICAgICAgICB2OiBuZXcgJERhdGFWaWV3KGJ1ZmZlcilcbiAgICAgICAgfSk7XG4gICAgICAgIHdoaWxlKGluZGV4IDwgbGVuZ3RoKWFkZEVsZW1lbnQodGhhdCwgaW5kZXgrKyk7XG4gICAgICB9KTtcbiAgICAgIFR5cGVkQXJyYXlQcm90b3R5cGUgPSBUeXBlZEFycmF5W1BST1RPVFlQRV0gPSBjcmVhdGUoJFR5cGVkQXJyYXlQcm90b3R5cGUkKTtcbiAgICAgIGhpZGUoVHlwZWRBcnJheVByb3RvdHlwZSwgJ2NvbnN0cnVjdG9yJywgVHlwZWRBcnJheSk7XG4gICAgfSBlbHNlIGlmKCEkaXRlckRldGVjdChmdW5jdGlvbihpdGVyKXtcbiAgICAgIC8vIFY4IHdvcmtzIHdpdGggaXRlcmF0b3JzLCBidXQgZmFpbHMgaW4gbWFueSBvdGhlciBjYXNlc1xuICAgICAgLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTQ1NTJcbiAgICAgIG5ldyBUeXBlZEFycmF5KG51bGwpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgICAgbmV3IFR5cGVkQXJyYXkoaXRlcik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgfSwgdHJ1ZSkpe1xuICAgICAgVHlwZWRBcnJheSA9IHdyYXBwZXIoZnVuY3Rpb24odGhhdCwgZGF0YSwgJG9mZnNldCwgJGxlbmd0aCl7XG4gICAgICAgIGFuSW5zdGFuY2UodGhhdCwgVHlwZWRBcnJheSwgTkFNRSk7XG4gICAgICAgIHZhciBrbGFzcztcbiAgICAgICAgLy8gYHdzYCBtb2R1bGUgYnVnLCB0ZW1wb3JhcmlseSByZW1vdmUgdmFsaWRhdGlvbiBsZW5ndGggZm9yIFVpbnQ4QXJyYXlcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3dlYnNvY2tldHMvd3MvcHVsbC82NDVcbiAgICAgICAgaWYoIWlzT2JqZWN0KGRhdGEpKXJldHVybiBuZXcgQmFzZShzdHJpY3RUb0xlbmd0aChkYXRhLCBJU05UX1VJTlQ4KSk7XG4gICAgICAgIGlmKGRhdGEgaW5zdGFuY2VvZiAkQXJyYXlCdWZmZXIgfHwgKGtsYXNzID0gY2xhc3NvZihkYXRhKSkgPT0gQVJSQVlfQlVGRkVSIHx8IGtsYXNzID09IFNIQVJFRF9CVUZGRVIpe1xuICAgICAgICAgIHJldHVybiAkbGVuZ3RoICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gbmV3IEJhc2UoZGF0YSwgdG9PZmZzZXQoJG9mZnNldCwgQllURVMpLCAkbGVuZ3RoKVxuICAgICAgICAgICAgOiAkb2Zmc2V0ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgPyBuZXcgQmFzZShkYXRhLCB0b09mZnNldCgkb2Zmc2V0LCBCWVRFUykpXG4gICAgICAgICAgICAgIDogbmV3IEJhc2UoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYoVFlQRURfQVJSQVkgaW4gZGF0YSlyZXR1cm4gZnJvbUxpc3QoVHlwZWRBcnJheSwgZGF0YSk7XG4gICAgICAgIHJldHVybiAkZnJvbS5jYWxsKFR5cGVkQXJyYXksIGRhdGEpO1xuICAgICAgfSk7XG4gICAgICBhcnJheUZvckVhY2goVEFDICE9PSBGdW5jdGlvbi5wcm90b3R5cGUgPyBnT1BOKEJhc2UpLmNvbmNhdChnT1BOKFRBQykpIDogZ09QTihCYXNlKSwgZnVuY3Rpb24oa2V5KXtcbiAgICAgICAgaWYoIShrZXkgaW4gVHlwZWRBcnJheSkpaGlkZShUeXBlZEFycmF5LCBrZXksIEJhc2Vba2V5XSk7XG4gICAgICB9KTtcbiAgICAgIFR5cGVkQXJyYXlbUFJPVE9UWVBFXSA9IFR5cGVkQXJyYXlQcm90b3R5cGU7XG4gICAgICBpZighTElCUkFSWSlUeXBlZEFycmF5UHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVHlwZWRBcnJheTtcbiAgICB9XG4gICAgdmFyICRuYXRpdmVJdGVyYXRvciAgID0gVHlwZWRBcnJheVByb3RvdHlwZVtJVEVSQVRPUl1cbiAgICAgICwgQ09SUkVDVF9JVEVSX05BTUUgPSAhISRuYXRpdmVJdGVyYXRvciAmJiAoJG5hdGl2ZUl0ZXJhdG9yLm5hbWUgPT0gJ3ZhbHVlcycgfHwgJG5hdGl2ZUl0ZXJhdG9yLm5hbWUgPT0gdW5kZWZpbmVkKVxuICAgICAgLCAkaXRlcmF0b3IgICAgICAgICA9ICRpdGVyYXRvcnMudmFsdWVzO1xuICAgIGhpZGUoVHlwZWRBcnJheSwgVFlQRURfQ09OU1RSVUNUT1IsIHRydWUpO1xuICAgIGhpZGUoVHlwZWRBcnJheVByb3RvdHlwZSwgVFlQRURfQVJSQVksIE5BTUUpO1xuICAgIGhpZGUoVHlwZWRBcnJheVByb3RvdHlwZSwgVklFVywgdHJ1ZSk7XG4gICAgaGlkZShUeXBlZEFycmF5UHJvdG90eXBlLCBERUZfQ09OU1RSVUNUT1IsIFR5cGVkQXJyYXkpO1xuXG4gICAgaWYoQ0xBTVBFRCA/IG5ldyBUeXBlZEFycmF5KDEpW1RBR10gIT0gTkFNRSA6ICEoVEFHIGluIFR5cGVkQXJyYXlQcm90b3R5cGUpKXtcbiAgICAgIGRQKFR5cGVkQXJyYXlQcm90b3R5cGUsIFRBRywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiBOQU1FOyB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBPW05BTUVdID0gVHlwZWRBcnJheTtcblxuICAgICRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogKFR5cGVkQXJyYXkgIT0gQmFzZSksIE8pO1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlMsIE5BTUUsIHtcbiAgICAgIEJZVEVTX1BFUl9FTEVNRU5UOiBCWVRFUyxcbiAgICAgIGZyb206ICRmcm9tLFxuICAgICAgb2Y6ICRvZlxuICAgIH0pO1xuXG4gICAgaWYoIShCWVRFU19QRVJfRUxFTUVOVCBpbiBUeXBlZEFycmF5UHJvdG90eXBlKSloaWRlKFR5cGVkQXJyYXlQcm90b3R5cGUsIEJZVEVTX1BFUl9FTEVNRU5ULCBCWVRFUyk7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuUCwgTkFNRSwgcHJvdG8pO1xuXG4gICAgc2V0U3BlY2llcyhOQU1FKTtcblxuICAgICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogRk9SQ0VEX1NFVCwgTkFNRSwge3NldDogJHNldH0pO1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhQ09SUkVDVF9JVEVSX05BTUUsIE5BTUUsICRpdGVyYXRvcnMpO1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoVHlwZWRBcnJheVByb3RvdHlwZS50b1N0cmluZyAhPSBhcnJheVRvU3RyaW5nKSwgTkFNRSwge3RvU3RyaW5nOiBhcnJheVRvU3RyaW5nfSk7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIGZhaWxzKGZ1bmN0aW9uKCl7XG4gICAgICBuZXcgVHlwZWRBcnJheSgxKS5zbGljZSgpO1xuICAgIH0pLCBOQU1FLCB7c2xpY2U6ICRzbGljZX0pO1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoZmFpbHMoZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiBbMSwgMl0udG9Mb2NhbGVTdHJpbmcoKSAhPSBuZXcgVHlwZWRBcnJheShbMSwgMl0pLnRvTG9jYWxlU3RyaW5nKClcbiAgICB9KSB8fCAhZmFpbHMoZnVuY3Rpb24oKXtcbiAgICAgIFR5cGVkQXJyYXlQcm90b3R5cGUudG9Mb2NhbGVTdHJpbmcuY2FsbChbMSwgMl0pO1xuICAgIH0pKSwgTkFNRSwge3RvTG9jYWxlU3RyaW5nOiAkdG9Mb2NhbGVTdHJpbmd9KTtcblxuICAgIEl0ZXJhdG9yc1tOQU1FXSA9IENPUlJFQ1RfSVRFUl9OQU1FID8gJG5hdGl2ZUl0ZXJhdG9yIDogJGl0ZXJhdG9yO1xuICAgIGlmKCFMSUJSQVJZICYmICFDT1JSRUNUX0lURVJfTkFNRSloaWRlKFR5cGVkQXJyYXlQcm90b3R5cGUsIElURVJBVE9SLCAkaXRlcmF0b3IpO1xuICB9O1xufSBlbHNlIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKXsgLyogZW1wdHkgKi8gfTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX3R5cGVkLWFycmF5LmpzXG4gKiogbW9kdWxlIGlkID0gMjIzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgY2xhc3NvZiAgID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpXG4gICwgSVRFUkFUT1IgID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJylcbiAgLCBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29yZScpLmlzSXRlcmFibGUgPSBmdW5jdGlvbihpdCl7XG4gIHZhciBPID0gT2JqZWN0KGl0KTtcbiAgcmV0dXJuIE9bSVRFUkFUT1JdICE9PSB1bmRlZmluZWRcbiAgICB8fCAnQEBpdGVyYXRvcicgaW4gT1xuICAgIHx8IEl0ZXJhdG9ycy5oYXNPd25Qcm9wZXJ0eShjbGFzc29mKE8pKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2NvcmUuaXMtaXRlcmFibGUuanNcbiAqKiBtb2R1bGUgaWQgPSAyMjRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ1VpbnQ4JywgMSwgZnVuY3Rpb24oaW5pdCl7XG4gIHJldHVybiBmdW5jdGlvbiBVaW50OEFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCl7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQudWludDgtYXJyYXkuanNcbiAqKiBtb2R1bGUgaWQgPSAyMjVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ1VpbnQ4JywgMSwgZnVuY3Rpb24oaW5pdCl7XG4gIHJldHVybiBmdW5jdGlvbiBVaW50OENsYW1wZWRBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpe1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59LCB0cnVlKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQ4LWNsYW1wZWQtYXJyYXkuanNcbiAqKiBtb2R1bGUgaWQgPSAyMjZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ0ludDE2JywgMiwgZnVuY3Rpb24oaW5pdCl7XG4gIHJldHVybiBmdW5jdGlvbiBJbnQxNkFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCl7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuaW50MTYtYXJyYXkuanNcbiAqKiBtb2R1bGUgaWQgPSAyMjdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ1VpbnQxNicsIDIsIGZ1bmN0aW9uKGluaXQpe1xuICByZXR1cm4gZnVuY3Rpb24gVWludDE2QXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKXtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC51aW50MTYtYXJyYXkuanNcbiAqKiBtb2R1bGUgaWQgPSAyMjhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ0ludDMyJywgNCwgZnVuY3Rpb24oaW5pdCl7XG4gIHJldHVybiBmdW5jdGlvbiBJbnQzMkFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCl7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuaW50MzItYXJyYXkuanNcbiAqKiBtb2R1bGUgaWQgPSAyMjlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ1VpbnQzMicsIDQsIGZ1bmN0aW9uKGluaXQpe1xuICByZXR1cm4gZnVuY3Rpb24gVWludDMyQXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKXtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC51aW50MzItYXJyYXkuanNcbiAqKiBtb2R1bGUgaWQgPSAyMzBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ0Zsb2F0MzInLCA0LCBmdW5jdGlvbihpbml0KXtcbiAgcmV0dXJuIGZ1bmN0aW9uIEZsb2F0MzJBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpe1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmZsb2F0MzItYXJyYXkuanNcbiAqKiBtb2R1bGUgaWQgPSAyMzFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ0Zsb2F0NjQnLCA4LCBmdW5jdGlvbihpbml0KXtcbiAgcmV0dXJuIGZ1bmN0aW9uIEZsb2F0NjRBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpe1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmZsb2F0NjQtYXJyYXkuanNcbiAqKiBtb2R1bGUgaWQgPSAyMzJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDI2LjEuMSBSZWZsZWN0LmFwcGx5KHRhcmdldCwgdGhpc0FyZ3VtZW50LCBhcmd1bWVudHNMaXN0KVxudmFyICRleHBvcnQgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpXG4gICwgYW5PYmplY3QgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBfYXBwbHkgICAgPSBGdW5jdGlvbi5hcHBseTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBhcHBseTogZnVuY3Rpb24gYXBwbHkodGFyZ2V0LCB0aGlzQXJndW1lbnQsIGFyZ3VtZW50c0xpc3Qpe1xuICAgIHJldHVybiBfYXBwbHkuY2FsbChhRnVuY3Rpb24odGFyZ2V0KSwgdGhpc0FyZ3VtZW50LCBhbk9iamVjdChhcmd1bWVudHNMaXN0KSk7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5hcHBseS5qc1xuICoqIG1vZHVsZSBpZCA9IDIzM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMjYuMS4yIFJlZmxlY3QuY29uc3RydWN0KHRhcmdldCwgYXJndW1lbnRzTGlzdCBbLCBuZXdUYXJnZXRdKVxudmFyICRleHBvcnQgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgY3JlYXRlICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpXG4gICwgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpXG4gICwgYW5PYmplY3QgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBpc09iamVjdCAgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGJpbmQgICAgICA9IHJlcXVpcmUoJy4vX2JpbmQnKTtcblxuLy8gTVMgRWRnZSBzdXBwb3J0cyBvbmx5IDIgYXJndW1lbnRzXG4vLyBGRiBOaWdodGx5IHNldHMgdGhpcmQgYXJndW1lbnQgYXMgYG5ldy50YXJnZXRgLCBidXQgZG9lcyBub3QgY3JlYXRlIGB0aGlzYCBmcm9tIGl0XG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgZnVuY3Rpb24gRigpe31cbiAgcmV0dXJuICEoUmVmbGVjdC5jb25zdHJ1Y3QoZnVuY3Rpb24oKXt9LCBbXSwgRikgaW5zdGFuY2VvZiBGKTtcbn0pLCAnUmVmbGVjdCcsIHtcbiAgY29uc3RydWN0OiBmdW5jdGlvbiBjb25zdHJ1Y3QoVGFyZ2V0LCBhcmdzIC8qLCBuZXdUYXJnZXQqLyl7XG4gICAgYUZ1bmN0aW9uKFRhcmdldCk7XG4gICAgYW5PYmplY3QoYXJncyk7XG4gICAgdmFyIG5ld1RhcmdldCA9IGFyZ3VtZW50cy5sZW5ndGggPCAzID8gVGFyZ2V0IDogYUZ1bmN0aW9uKGFyZ3VtZW50c1syXSk7XG4gICAgaWYoVGFyZ2V0ID09IG5ld1RhcmdldCl7XG4gICAgICAvLyB3L28gYWx0ZXJlZCBuZXdUYXJnZXQsIG9wdGltaXphdGlvbiBmb3IgMC00IGFyZ3VtZW50c1xuICAgICAgc3dpdGNoKGFyZ3MubGVuZ3RoKXtcbiAgICAgICAgY2FzZSAwOiByZXR1cm4gbmV3IFRhcmdldDtcbiAgICAgICAgY2FzZSAxOiByZXR1cm4gbmV3IFRhcmdldChhcmdzWzBdKTtcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gbmV3IFRhcmdldChhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgY2FzZSAzOiByZXR1cm4gbmV3IFRhcmdldChhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gbmV3IFRhcmdldChhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKTtcbiAgICAgIH1cbiAgICAgIC8vIHcvbyBhbHRlcmVkIG5ld1RhcmdldCwgbG90IG9mIGFyZ3VtZW50cyBjYXNlXG4gICAgICB2YXIgJGFyZ3MgPSBbbnVsbF07XG4gICAgICAkYXJncy5wdXNoLmFwcGx5KCRhcmdzLCBhcmdzKTtcbiAgICAgIHJldHVybiBuZXcgKGJpbmQuYXBwbHkoVGFyZ2V0LCAkYXJncykpO1xuICAgIH1cbiAgICAvLyB3aXRoIGFsdGVyZWQgbmV3VGFyZ2V0LCBub3Qgc3VwcG9ydCBidWlsdC1pbiBjb25zdHJ1Y3RvcnNcbiAgICB2YXIgcHJvdG8gICAgPSBuZXdUYXJnZXQucHJvdG90eXBlXG4gICAgICAsIGluc3RhbmNlID0gY3JlYXRlKGlzT2JqZWN0KHByb3RvKSA/IHByb3RvIDogT2JqZWN0LnByb3RvdHlwZSlcbiAgICAgICwgcmVzdWx0ICAgPSBGdW5jdGlvbi5hcHBseS5jYWxsKFRhcmdldCwgaW5zdGFuY2UsIGFyZ3MpO1xuICAgIHJldHVybiBpc09iamVjdChyZXN1bHQpID8gcmVzdWx0IDogaW5zdGFuY2U7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5jb25zdHJ1Y3QuanNcbiAqKiBtb2R1bGUgaWQgPSAyMzRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDI2LjEuMyBSZWZsZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHlLZXksIGF0dHJpYnV0ZXMpXG52YXIgZFAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKVxuICAsICRleHBvcnQgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBhbk9iamVjdCAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcblxuLy8gTVMgRWRnZSBoYXMgYnJva2VuIFJlZmxlY3QuZGVmaW5lUHJvcGVydHkgLSB0aHJvd2luZyBpbnN0ZWFkIG9mIHJldHVybmluZyBmYWxzZVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIFJlZmxlY3QuZGVmaW5lUHJvcGVydHkoZFAuZih7fSwgMSwge3ZhbHVlOiAxfSksIDEsIHt2YWx1ZTogMn0pO1xufSksICdSZWZsZWN0Jywge1xuICBkZWZpbmVQcm9wZXJ0eTogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eUtleSwgYXR0cmlidXRlcyl7XG4gICAgYW5PYmplY3QodGFyZ2V0KTtcbiAgICBwcm9wZXJ0eUtleSA9IHRvUHJpbWl0aXZlKHByb3BlcnR5S2V5LCB0cnVlKTtcbiAgICBhbk9iamVjdChhdHRyaWJ1dGVzKTtcbiAgICB0cnkge1xuICAgICAgZFAuZih0YXJnZXQsIHByb3BlcnR5S2V5LCBhdHRyaWJ1dGVzKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZGVmaW5lLXByb3BlcnR5LmpzXG4gKiogbW9kdWxlIGlkID0gMjM1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAyNi4xLjQgUmVmbGVjdC5kZWxldGVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5S2V5KVxudmFyICRleHBvcnQgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBnT1BEICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJykuZlxuICAsIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgZGVsZXRlUHJvcGVydHk6IGZ1bmN0aW9uIGRlbGV0ZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHlLZXkpe1xuICAgIHZhciBkZXNjID0gZ09QRChhbk9iamVjdCh0YXJnZXQpLCBwcm9wZXJ0eUtleSk7XG4gICAgcmV0dXJuIGRlc2MgJiYgIWRlc2MuY29uZmlndXJhYmxlID8gZmFsc2UgOiBkZWxldGUgdGFyZ2V0W3Byb3BlcnR5S2V5XTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmRlbGV0ZS1wcm9wZXJ0eS5qc1xuICoqIG1vZHVsZSBpZCA9IDIzNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMjYuMS41IFJlZmxlY3QuZW51bWVyYXRlKHRhcmdldClcbnZhciAkZXhwb3J0ICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBFbnVtZXJhdGUgPSBmdW5jdGlvbihpdGVyYXRlZCl7XG4gIHRoaXMuX3QgPSBhbk9iamVjdChpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4gIHZhciBrZXlzID0gdGhpcy5fayA9IFtdICAgICAgIC8vIGtleXNcbiAgICAsIGtleTtcbiAgZm9yKGtleSBpbiBpdGVyYXRlZClrZXlzLnB1c2goa2V5KTtcbn07XG5yZXF1aXJlKCcuL19pdGVyLWNyZWF0ZScpKEVudW1lcmF0ZSwgJ09iamVjdCcsIGZ1bmN0aW9uKCl7XG4gIHZhciB0aGF0ID0gdGhpc1xuICAgICwga2V5cyA9IHRoYXQuX2tcbiAgICAsIGtleTtcbiAgZG8ge1xuICAgIGlmKHRoYXQuX2kgPj0ga2V5cy5sZW5ndGgpcmV0dXJuIHt2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlfTtcbiAgfSB3aGlsZSghKChrZXkgPSBrZXlzW3RoYXQuX2krK10pIGluIHRoYXQuX3QpKTtcbiAgcmV0dXJuIHt2YWx1ZToga2V5LCBkb25lOiBmYWxzZX07XG59KTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBlbnVtZXJhdGU6IGZ1bmN0aW9uIGVudW1lcmF0ZSh0YXJnZXQpe1xuICAgIHJldHVybiBuZXcgRW51bWVyYXRlKHRhcmdldCk7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5lbnVtZXJhdGUuanNcbiAqKiBtb2R1bGUgaWQgPSAyMzdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDI2LjEuNiBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3BlcnR5S2V5IFssIHJlY2VpdmVyXSlcbnZhciBnT1BEICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJylcbiAgLCBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKVxuICAsIGhhcyAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCAkZXhwb3J0ICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgaXNPYmplY3QgICAgICAgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGFuT2JqZWN0ICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5cbmZ1bmN0aW9uIGdldCh0YXJnZXQsIHByb3BlcnR5S2V5LyosIHJlY2VpdmVyKi8pe1xuICB2YXIgcmVjZWl2ZXIgPSBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHRhcmdldCA6IGFyZ3VtZW50c1syXVxuICAgICwgZGVzYywgcHJvdG87XG4gIGlmKGFuT2JqZWN0KHRhcmdldCkgPT09IHJlY2VpdmVyKXJldHVybiB0YXJnZXRbcHJvcGVydHlLZXldO1xuICBpZihkZXNjID0gZ09QRC5mKHRhcmdldCwgcHJvcGVydHlLZXkpKXJldHVybiBoYXMoZGVzYywgJ3ZhbHVlJylcbiAgICA/IGRlc2MudmFsdWVcbiAgICA6IGRlc2MuZ2V0ICE9PSB1bmRlZmluZWRcbiAgICAgID8gZGVzYy5nZXQuY2FsbChyZWNlaXZlcilcbiAgICAgIDogdW5kZWZpbmVkO1xuICBpZihpc09iamVjdChwcm90byA9IGdldFByb3RvdHlwZU9mKHRhcmdldCkpKXJldHVybiBnZXQocHJvdG8sIHByb3BlcnR5S2V5LCByZWNlaXZlcik7XG59XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtnZXQ6IGdldH0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5nZXQuanNcbiAqKiBtb2R1bGUgaWQgPSAyMzhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDI2LjEuNyBSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIHByb3BlcnR5S2V5KVxudmFyIGdPUEQgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKVxuICAsICRleHBvcnQgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgcHJvcGVydHlLZXkpe1xuICAgIHJldHVybiBnT1BELmYoYW5PYmplY3QodGFyZ2V0KSwgcHJvcGVydHlLZXkpO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzXG4gKiogbW9kdWxlIGlkID0gMjM5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAyNi4xLjggUmVmbGVjdC5nZXRQcm90b3R5cGVPZih0YXJnZXQpXG52YXIgJGV4cG9ydCAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGdldFByb3RvID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpXG4gICwgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBnZXRQcm90b3R5cGVPZjogZnVuY3Rpb24gZ2V0UHJvdG90eXBlT2YodGFyZ2V0KXtcbiAgICByZXR1cm4gZ2V0UHJvdG8oYW5PYmplY3QodGFyZ2V0KSk7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5nZXQtcHJvdG90eXBlLW9mLmpzXG4gKiogbW9kdWxlIGlkID0gMjQwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAyNi4xLjkgUmVmbGVjdC5oYXModGFyZ2V0LCBwcm9wZXJ0eUtleSlcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgaGFzOiBmdW5jdGlvbiBoYXModGFyZ2V0LCBwcm9wZXJ0eUtleSl7XG4gICAgcmV0dXJuIHByb3BlcnR5S2V5IGluIHRhcmdldDtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0Lmhhcy5qc1xuICoqIG1vZHVsZSBpZCA9IDI0MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMjYuMS4xMCBSZWZsZWN0LmlzRXh0ZW5zaWJsZSh0YXJnZXQpXG52YXIgJGV4cG9ydCAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgYW5PYmplY3QgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgJGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGU7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgaXNFeHRlbnNpYmxlOiBmdW5jdGlvbiBpc0V4dGVuc2libGUodGFyZ2V0KXtcbiAgICBhbk9iamVjdCh0YXJnZXQpO1xuICAgIHJldHVybiAkaXNFeHRlbnNpYmxlID8gJGlzRXh0ZW5zaWJsZSh0YXJnZXQpIDogdHJ1ZTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmlzLWV4dGVuc2libGUuanNcbiAqKiBtb2R1bGUgaWQgPSAyNDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDI2LjEuMTEgUmVmbGVjdC5vd25LZXlzKHRhcmdldClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtvd25LZXlzOiByZXF1aXJlKCcuL19vd24ta2V5cycpfSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0Lm93bi1rZXlzLmpzXG4gKiogbW9kdWxlIGlkID0gMjQzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBhbGwgb2JqZWN0IGtleXMsIGluY2x1ZGVzIG5vbi1lbnVtZXJhYmxlIGFuZCBzeW1ib2xzXG52YXIgZ09QTiAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpXG4gICwgZ09QUyAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wcycpXG4gICwgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIFJlZmxlY3QgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuUmVmbGVjdDtcbm1vZHVsZS5leHBvcnRzID0gUmVmbGVjdCAmJiBSZWZsZWN0Lm93bktleXMgfHwgZnVuY3Rpb24gb3duS2V5cyhpdCl7XG4gIHZhciBrZXlzICAgICAgID0gZ09QTi5mKGFuT2JqZWN0KGl0KSlcbiAgICAsIGdldFN5bWJvbHMgPSBnT1BTLmY7XG4gIHJldHVybiBnZXRTeW1ib2xzID8ga2V5cy5jb25jYXQoZ2V0U3ltYm9scyhpdCkpIDoga2V5cztcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19vd24ta2V5cy5qc1xuICoqIG1vZHVsZSBpZCA9IDI0NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMjYuMS4xMiBSZWZsZWN0LnByZXZlbnRFeHRlbnNpb25zKHRhcmdldClcbnZhciAkZXhwb3J0ICAgICAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGFuT2JqZWN0ICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgJHByZXZlbnRFeHRlbnNpb25zID0gT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIHByZXZlbnRFeHRlbnNpb25zOiBmdW5jdGlvbiBwcmV2ZW50RXh0ZW5zaW9ucyh0YXJnZXQpe1xuICAgIGFuT2JqZWN0KHRhcmdldCk7XG4gICAgdHJ5IHtcbiAgICAgIGlmKCRwcmV2ZW50RXh0ZW5zaW9ucykkcHJldmVudEV4dGVuc2lvbnModGFyZ2V0KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QucHJldmVudC1leHRlbnNpb25zLmpzXG4gKiogbW9kdWxlIGlkID0gMjQ1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAyNi4xLjEzIFJlZmxlY3Quc2V0KHRhcmdldCwgcHJvcGVydHlLZXksIFYgWywgcmVjZWl2ZXJdKVxudmFyIGRQICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJylcbiAgLCBnT1BEICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJylcbiAgLCBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKVxuICAsIGhhcyAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCAkZXhwb3J0ICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgY3JlYXRlRGVzYyAgICAgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJylcbiAgLCBhbk9iamVjdCAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgaXNPYmplY3QgICAgICAgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcblxuZnVuY3Rpb24gc2V0KHRhcmdldCwgcHJvcGVydHlLZXksIFYvKiwgcmVjZWl2ZXIqLyl7XG4gIHZhciByZWNlaXZlciA9IGFyZ3VtZW50cy5sZW5ndGggPCA0ID8gdGFyZ2V0IDogYXJndW1lbnRzWzNdXG4gICAgLCBvd25EZXNjICA9IGdPUEQuZihhbk9iamVjdCh0YXJnZXQpLCBwcm9wZXJ0eUtleSlcbiAgICAsIGV4aXN0aW5nRGVzY3JpcHRvciwgcHJvdG87XG4gIGlmKCFvd25EZXNjKXtcbiAgICBpZihpc09iamVjdChwcm90byA9IGdldFByb3RvdHlwZU9mKHRhcmdldCkpKXtcbiAgICAgIHJldHVybiBzZXQocHJvdG8sIHByb3BlcnR5S2V5LCBWLCByZWNlaXZlcik7XG4gICAgfVxuICAgIG93bkRlc2MgPSBjcmVhdGVEZXNjKDApO1xuICB9XG4gIGlmKGhhcyhvd25EZXNjLCAndmFsdWUnKSl7XG4gICAgaWYob3duRGVzYy53cml0YWJsZSA9PT0gZmFsc2UgfHwgIWlzT2JqZWN0KHJlY2VpdmVyKSlyZXR1cm4gZmFsc2U7XG4gICAgZXhpc3RpbmdEZXNjcmlwdG9yID0gZ09QRC5mKHJlY2VpdmVyLCBwcm9wZXJ0eUtleSkgfHwgY3JlYXRlRGVzYygwKTtcbiAgICBleGlzdGluZ0Rlc2NyaXB0b3IudmFsdWUgPSBWO1xuICAgIGRQLmYocmVjZWl2ZXIsIHByb3BlcnR5S2V5LCBleGlzdGluZ0Rlc2NyaXB0b3IpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBvd25EZXNjLnNldCA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiAob3duRGVzYy5zZXQuY2FsbChyZWNlaXZlciwgViksIHRydWUpO1xufVxuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7c2V0OiBzZXR9KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3Quc2V0LmpzXG4gKiogbW9kdWxlIGlkID0gMjQ2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAyNi4xLjE0IFJlZmxlY3Quc2V0UHJvdG90eXBlT2YodGFyZ2V0LCBwcm90bylcbnZhciAkZXhwb3J0ICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgc2V0UHJvdG8gPSByZXF1aXJlKCcuL19zZXQtcHJvdG8nKTtcblxuaWYoc2V0UHJvdG8pJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBzZXRQcm90b3R5cGVPZjogZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YodGFyZ2V0LCBwcm90byl7XG4gICAgc2V0UHJvdG8uY2hlY2sodGFyZ2V0LCBwcm90byk7XG4gICAgdHJ5IHtcbiAgICAgIHNldFByb3RvLnNldCh0YXJnZXQsIHByb3RvKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3Quc2V0LXByb3RvdHlwZS1vZi5qc1xuICoqIG1vZHVsZSBpZCA9IDI0N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvQXJyYXkucHJvdG90eXBlLmluY2x1ZGVzXG52YXIgJGV4cG9ydCAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkaW5jbHVkZXMgPSByZXF1aXJlKCcuL19hcnJheS1pbmNsdWRlcycpKHRydWUpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ0FycmF5Jywge1xuICBpbmNsdWRlczogZnVuY3Rpb24gaW5jbHVkZXMoZWwgLyosIGZyb21JbmRleCA9IDAgKi8pe1xuICAgIHJldHVybiAkaW5jbHVkZXModGhpcywgZWwsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7XG5cbnJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpKCdpbmNsdWRlcycpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczcuYXJyYXkuaW5jbHVkZXMuanNcbiAqKiBtb2R1bGUgaWQgPSAyNDhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRoaWFzYnluZW5zL1N0cmluZy5wcm90b3R5cGUuYXRcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkYXQgICAgID0gcmVxdWlyZSgnLi9fc3RyaW5nLWF0JykodHJ1ZSk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnU3RyaW5nJywge1xuICBhdDogZnVuY3Rpb24gYXQocG9zKXtcbiAgICByZXR1cm4gJGF0KHRoaXMsIHBvcyk7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLmF0LmpzXG4gKiogbW9kdWxlIGlkID0gMjQ5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1zdHJpbmctcGFkLXN0YXJ0LWVuZFxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRwYWQgICAgPSByZXF1aXJlKCcuL19zdHJpbmctcGFkJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnU3RyaW5nJywge1xuICBwYWRTdGFydDogZnVuY3Rpb24gcGFkU3RhcnQobWF4TGVuZ3RoIC8qLCBmaWxsU3RyaW5nID0gJyAnICovKXtcbiAgICByZXR1cm4gJHBhZCh0aGlzLCBtYXhMZW5ndGgsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCB0cnVlKTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcucGFkLXN0YXJ0LmpzXG4gKiogbW9kdWxlIGlkID0gMjUwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1zdHJpbmctcGFkLXN0YXJ0LWVuZFxudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCByZXBlYXQgICA9IHJlcXVpcmUoJy4vX3N0cmluZy1yZXBlYXQnKVxuICAsIGRlZmluZWQgID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHRoYXQsIG1heExlbmd0aCwgZmlsbFN0cmluZywgbGVmdCl7XG4gIHZhciBTICAgICAgICAgICAgPSBTdHJpbmcoZGVmaW5lZCh0aGF0KSlcbiAgICAsIHN0cmluZ0xlbmd0aCA9IFMubGVuZ3RoXG4gICAgLCBmaWxsU3RyICAgICAgPSBmaWxsU3RyaW5nID09PSB1bmRlZmluZWQgPyAnICcgOiBTdHJpbmcoZmlsbFN0cmluZylcbiAgICAsIGludE1heExlbmd0aCA9IHRvTGVuZ3RoKG1heExlbmd0aCk7XG4gIGlmKGludE1heExlbmd0aCA8PSBzdHJpbmdMZW5ndGggfHwgZmlsbFN0ciA9PSAnJylyZXR1cm4gUztcbiAgdmFyIGZpbGxMZW4gPSBpbnRNYXhMZW5ndGggLSBzdHJpbmdMZW5ndGhcbiAgICAsIHN0cmluZ0ZpbGxlciA9IHJlcGVhdC5jYWxsKGZpbGxTdHIsIE1hdGguY2VpbChmaWxsTGVuIC8gZmlsbFN0ci5sZW5ndGgpKTtcbiAgaWYoc3RyaW5nRmlsbGVyLmxlbmd0aCA+IGZpbGxMZW4pc3RyaW5nRmlsbGVyID0gc3RyaW5nRmlsbGVyLnNsaWNlKDAsIGZpbGxMZW4pO1xuICByZXR1cm4gbGVmdCA/IHN0cmluZ0ZpbGxlciArIFMgOiBTICsgc3RyaW5nRmlsbGVyO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLXBhZC5qc1xuICoqIG1vZHVsZSBpZCA9IDI1MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtc3RyaW5nLXBhZC1zdGFydC1lbmRcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkcGFkICAgID0gcmVxdWlyZSgnLi9fc3RyaW5nLXBhZCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ1N0cmluZycsIHtcbiAgcGFkRW5kOiBmdW5jdGlvbiBwYWRFbmQobWF4TGVuZ3RoIC8qLCBmaWxsU3RyaW5nID0gJyAnICovKXtcbiAgICByZXR1cm4gJHBhZCh0aGlzLCBtYXhMZW5ndGgsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCBmYWxzZSk7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLnBhZC1lbmQuanNcbiAqKiBtb2R1bGUgaWQgPSAyNTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zZWJtYXJrYmFnZS9lY21hc2NyaXB0LXN0cmluZy1sZWZ0LXJpZ2h0LXRyaW1cbnJlcXVpcmUoJy4vX3N0cmluZy10cmltJykoJ3RyaW1MZWZ0JywgZnVuY3Rpb24oJHRyaW0pe1xuICByZXR1cm4gZnVuY3Rpb24gdHJpbUxlZnQoKXtcbiAgICByZXR1cm4gJHRyaW0odGhpcywgMSk7XG4gIH07XG59LCAndHJpbVN0YXJ0Jyk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcudHJpbS1sZWZ0LmpzXG4gKiogbW9kdWxlIGlkID0gMjUzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vc2VibWFya2JhZ2UvZWNtYXNjcmlwdC1zdHJpbmctbGVmdC1yaWdodC10cmltXG5yZXF1aXJlKCcuL19zdHJpbmctdHJpbScpKCd0cmltUmlnaHQnLCBmdW5jdGlvbigkdHJpbSl7XG4gIHJldHVybiBmdW5jdGlvbiB0cmltUmlnaHQoKXtcbiAgICByZXR1cm4gJHRyaW0odGhpcywgMik7XG4gIH07XG59LCAndHJpbUVuZCcpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLnRyaW0tcmlnaHQuanNcbiAqKiBtb2R1bGUgaWQgPSAyNTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9TdHJpbmcucHJvdG90eXBlLm1hdGNoQWxsL1xyXG52YXIgJGV4cG9ydCAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxyXG4gICwgZGVmaW5lZCAgICAgPSByZXF1aXJlKCcuL19kZWZpbmVkJylcclxuICAsIHRvTGVuZ3RoICAgID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcclxuICAsIGlzUmVnRXhwICAgID0gcmVxdWlyZSgnLi9faXMtcmVnZXhwJylcclxuICAsIGdldEZsYWdzICAgID0gcmVxdWlyZSgnLi9fZmxhZ3MnKVxyXG4gICwgUmVnRXhwUHJvdG8gPSBSZWdFeHAucHJvdG90eXBlO1xyXG5cclxudmFyICRSZWdFeHBTdHJpbmdJdGVyYXRvciA9IGZ1bmN0aW9uKHJlZ2V4cCwgc3RyaW5nKXtcclxuICB0aGlzLl9yID0gcmVnZXhwO1xyXG4gIHRoaXMuX3MgPSBzdHJpbmc7XHJcbn07XHJcblxyXG5yZXF1aXJlKCcuL19pdGVyLWNyZWF0ZScpKCRSZWdFeHBTdHJpbmdJdGVyYXRvciwgJ1JlZ0V4cCBTdHJpbmcnLCBmdW5jdGlvbiBuZXh0KCl7XHJcbiAgdmFyIG1hdGNoID0gdGhpcy5fci5leGVjKHRoaXMuX3MpO1xyXG4gIHJldHVybiB7dmFsdWU6IG1hdGNoLCBkb25lOiBtYXRjaCA9PT0gbnVsbH07XHJcbn0pO1xyXG5cclxuJGV4cG9ydCgkZXhwb3J0LlAsICdTdHJpbmcnLCB7XHJcbiAgbWF0Y2hBbGw6IGZ1bmN0aW9uIG1hdGNoQWxsKHJlZ2V4cCl7XHJcbiAgICBkZWZpbmVkKHRoaXMpO1xyXG4gICAgaWYoIWlzUmVnRXhwKHJlZ2V4cCkpdGhyb3cgVHlwZUVycm9yKHJlZ2V4cCArICcgaXMgbm90IGEgcmVnZXhwIScpO1xyXG4gICAgdmFyIFMgICAgID0gU3RyaW5nKHRoaXMpXHJcbiAgICAgICwgZmxhZ3MgPSAnZmxhZ3MnIGluIFJlZ0V4cFByb3RvID8gU3RyaW5nKHJlZ2V4cC5mbGFncykgOiBnZXRGbGFncy5jYWxsKHJlZ2V4cClcclxuICAgICAgLCByeCAgICA9IG5ldyBSZWdFeHAocmVnZXhwLnNvdXJjZSwgfmZsYWdzLmluZGV4T2YoJ2cnKSA/IGZsYWdzIDogJ2cnICsgZmxhZ3MpO1xyXG4gICAgcngubGFzdEluZGV4ID0gdG9MZW5ndGgocmVnZXhwLmxhc3RJbmRleCk7XHJcbiAgICByZXR1cm4gbmV3ICRSZWdFeHBTdHJpbmdJdGVyYXRvcihyeCwgUyk7XHJcbiAgfVxyXG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnN0cmluZy5tYXRjaC1hbGwuanNcbiAqKiBtb2R1bGUgaWQgPSAyNTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInJlcXVpcmUoJy4vX3drcy1kZWZpbmUnKSgnYXN5bmNJdGVyYXRvcicpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczcuc3ltYm9sLmFzeW5jLWl0ZXJhdG9yLmpzXG4gKiogbW9kdWxlIGlkID0gMjU2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJyZXF1aXJlKCcuL193a3MtZGVmaW5lJykoJ29ic2VydmFibGUnKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnN5bWJvbC5vYnNlcnZhYmxlLmpzXG4gKiogbW9kdWxlIGlkID0gMjU3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yc1xudmFyICRleHBvcnQgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBvd25LZXlzICAgICAgICA9IHJlcXVpcmUoJy4vX293bi1rZXlzJylcbiAgLCB0b0lPYmplY3QgICAgICA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIGdPUEQgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKVxuICAsIGNyZWF0ZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fY3JlYXRlLXByb3BlcnR5Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0Jywge1xuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9iamVjdCl7XG4gICAgdmFyIE8gICAgICAgPSB0b0lPYmplY3Qob2JqZWN0KVxuICAgICAgLCBnZXREZXNjID0gZ09QRC5mXG4gICAgICAsIGtleXMgICAgPSBvd25LZXlzKE8pXG4gICAgICAsIHJlc3VsdCAgPSB7fVxuICAgICAgLCBpICAgICAgID0gMFxuICAgICAgLCBrZXksIEQ7XG4gICAgd2hpbGUoa2V5cy5sZW5ndGggPiBpKWNyZWF0ZVByb3BlcnR5KHJlc3VsdCwga2V5ID0ga2V5c1tpKytdLCBnZXREZXNjKE8sIGtleSkpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcnMuanNcbiAqKiBtb2R1bGUgaWQgPSAyNThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLW9iamVjdC12YWx1ZXMtZW50cmllc1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICR2YWx1ZXMgPSByZXF1aXJlKCcuL19vYmplY3QtdG8tYXJyYXknKShmYWxzZSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0Jywge1xuICB2YWx1ZXM6IGZ1bmN0aW9uIHZhbHVlcyhpdCl7XG4gICAgcmV0dXJuICR2YWx1ZXMoaXQpO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC52YWx1ZXMuanNcbiAqKiBtb2R1bGUgaWQgPSAyNTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBnZXRLZXlzICAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpXG4gICwgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgaXNFbnVtICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpLmY7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGlzRW50cmllcyl7XG4gIHJldHVybiBmdW5jdGlvbihpdCl7XG4gICAgdmFyIE8gICAgICA9IHRvSU9iamVjdChpdClcbiAgICAgICwga2V5cyAgID0gZ2V0S2V5cyhPKVxuICAgICAgLCBsZW5ndGggPSBrZXlzLmxlbmd0aFxuICAgICAgLCBpICAgICAgPSAwXG4gICAgICAsIHJlc3VsdCA9IFtdXG4gICAgICAsIGtleTtcbiAgICB3aGlsZShsZW5ndGggPiBpKWlmKGlzRW51bS5jYWxsKE8sIGtleSA9IGtleXNbaSsrXSkpe1xuICAgICAgcmVzdWx0LnB1c2goaXNFbnRyaWVzID8gW2tleSwgT1trZXldXSA6IE9ba2V5XSk7XG4gICAgfSByZXR1cm4gcmVzdWx0O1xuICB9O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC10by1hcnJheS5qc1xuICoqIG1vZHVsZSBpZCA9IDI2MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtb2JqZWN0LXZhbHVlcy1lbnRyaWVzXG52YXIgJGV4cG9ydCAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRlbnRyaWVzID0gcmVxdWlyZSgnLi9fb2JqZWN0LXRvLWFycmF5JykodHJ1ZSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0Jywge1xuICBlbnRyaWVzOiBmdW5jdGlvbiBlbnRyaWVzKGl0KXtcbiAgICByZXR1cm4gJGVudHJpZXMoaXQpO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5lbnRyaWVzLmpzXG4gKiogbW9kdWxlIGlkID0gMjYxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbnZhciAkZXhwb3J0ICAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxyXG4gICwgdG9PYmplY3QgICAgICAgID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcclxuICAsIGFGdW5jdGlvbiAgICAgICA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKVxyXG4gICwgJGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XHJcblxyXG4vLyBCLjIuMi4yIE9iamVjdC5wcm90b3R5cGUuX19kZWZpbmVHZXR0ZXJfXyhQLCBnZXR0ZXIpXHJcbnJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgJGV4cG9ydCgkZXhwb3J0LlAgKyByZXF1aXJlKCcuL19vYmplY3QtZm9yY2VkLXBhbScpLCAnT2JqZWN0Jywge1xyXG4gIF9fZGVmaW5lR2V0dGVyX186IGZ1bmN0aW9uIF9fZGVmaW5lR2V0dGVyX18oUCwgZ2V0dGVyKXtcclxuICAgICRkZWZpbmVQcm9wZXJ0eS5mKHRvT2JqZWN0KHRoaXMpLCBQLCB7Z2V0OiBhRnVuY3Rpb24oZ2V0dGVyKSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlfSk7XHJcbiAgfVxyXG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5kZWZpbmUtZ2V0dGVyLmpzXG4gKiogbW9kdWxlIGlkID0gMjYyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBGb3JjZWQgcmVwbGFjZW1lbnQgcHJvdG90eXBlIGFjY2Vzc29ycyBtZXRob2RzXHJcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fbGlicmFyeScpfHwgIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcclxuICB2YXIgSyA9IE1hdGgucmFuZG9tKCk7XHJcbiAgLy8gSW4gRkYgdGhyb3dzIG9ubHkgZGVmaW5lIG1ldGhvZHNcclxuICBfX2RlZmluZVNldHRlcl9fLmNhbGwobnVsbCwgSywgZnVuY3Rpb24oKXsgLyogZW1wdHkgKi99KTtcclxuICBkZWxldGUgcmVxdWlyZSgnLi9fZ2xvYmFsJylbS107XHJcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWZvcmNlZC1wYW0uanNcbiAqKiBtb2R1bGUgaWQgPSAyNjNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxudmFyICRleHBvcnQgICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXHJcbiAgLCB0b09iamVjdCAgICAgICAgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxyXG4gICwgYUZ1bmN0aW9uICAgICAgID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpXHJcbiAgLCAkZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcclxuXHJcbi8vIEIuMi4yLjMgT2JqZWN0LnByb3RvdHlwZS5fX2RlZmluZVNldHRlcl9fKFAsIHNldHRlcilcclxucmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAkZXhwb3J0KCRleHBvcnQuUCArIHJlcXVpcmUoJy4vX29iamVjdC1mb3JjZWQtcGFtJyksICdPYmplY3QnLCB7XHJcbiAgX19kZWZpbmVTZXR0ZXJfXzogZnVuY3Rpb24gX19kZWZpbmVTZXR0ZXJfXyhQLCBzZXR0ZXIpe1xyXG4gICAgJGRlZmluZVByb3BlcnR5LmYodG9PYmplY3QodGhpcyksIFAsIHtzZXQ6IGFGdW5jdGlvbihzZXR0ZXIpLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWV9KTtcclxuICB9XHJcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0LmRlZmluZS1zZXR0ZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAyNjRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxudmFyICRleHBvcnQgICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXHJcbiAgLCB0b09iamVjdCAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxyXG4gICwgdG9QcmltaXRpdmUgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJylcclxuICAsIGdldFByb3RvdHlwZU9mICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKVxyXG4gICwgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mO1xyXG5cclxuLy8gQi4yLjIuNCBPYmplY3QucHJvdG90eXBlLl9fbG9va3VwR2V0dGVyX18oUClcclxucmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAkZXhwb3J0KCRleHBvcnQuUCArIHJlcXVpcmUoJy4vX29iamVjdC1mb3JjZWQtcGFtJyksICdPYmplY3QnLCB7XHJcbiAgX19sb29rdXBHZXR0ZXJfXzogZnVuY3Rpb24gX19sb29rdXBHZXR0ZXJfXyhQKXtcclxuICAgIHZhciBPID0gdG9PYmplY3QodGhpcylcclxuICAgICAgLCBLID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSlcclxuICAgICAgLCBEO1xyXG4gICAgZG8ge1xyXG4gICAgICBpZihEID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIEspKXJldHVybiBELmdldDtcclxuICAgIH0gd2hpbGUoTyA9IGdldFByb3RvdHlwZU9mKE8pKTtcclxuICB9XHJcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0Lmxvb2t1cC1nZXR0ZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAyNjVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxudmFyICRleHBvcnQgICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXHJcbiAgLCB0b09iamVjdCAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxyXG4gICwgdG9QcmltaXRpdmUgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJylcclxuICAsIGdldFByb3RvdHlwZU9mICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKVxyXG4gICwgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mO1xyXG5cclxuLy8gQi4yLjIuNSBPYmplY3QucHJvdG90eXBlLl9fbG9va3VwU2V0dGVyX18oUClcclxucmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAkZXhwb3J0KCRleHBvcnQuUCArIHJlcXVpcmUoJy4vX29iamVjdC1mb3JjZWQtcGFtJyksICdPYmplY3QnLCB7XHJcbiAgX19sb29rdXBTZXR0ZXJfXzogZnVuY3Rpb24gX19sb29rdXBTZXR0ZXJfXyhQKXtcclxuICAgIHZhciBPID0gdG9PYmplY3QodGhpcylcclxuICAgICAgLCBLID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSlcclxuICAgICAgLCBEO1xyXG4gICAgZG8ge1xyXG4gICAgICBpZihEID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIEspKXJldHVybiBELnNldDtcclxuICAgIH0gd2hpbGUoTyA9IGdldFByb3RvdHlwZU9mKE8pKTtcclxuICB9XHJcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0Lmxvb2t1cC1zZXR0ZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAyNjZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXZpZEJydWFudC9NYXAtU2V0LnByb3RvdHlwZS50b0pTT05cbnZhciAkZXhwb3J0ICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuUiwgJ01hcCcsIHt0b0pTT046IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24tdG8tanNvbicpKCdNYXAnKX0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczcubWFwLnRvLWpzb24uanNcbiAqKiBtb2R1bGUgaWQgPSAyNjdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXZpZEJydWFudC9NYXAtU2V0LnByb3RvdHlwZS50b0pTT05cbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpXG4gICwgZnJvbSAgICA9IHJlcXVpcmUoJy4vX2FycmF5LWZyb20taXRlcmFibGUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oTkFNRSl7XG4gIHJldHVybiBmdW5jdGlvbiB0b0pTT04oKXtcbiAgICBpZihjbGFzc29mKHRoaXMpICE9IE5BTUUpdGhyb3cgVHlwZUVycm9yKE5BTUUgKyBcIiN0b0pTT04gaXNuJ3QgZ2VuZXJpY1wiKTtcbiAgICByZXR1cm4gZnJvbSh0aGlzKTtcbiAgfTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19jb2xsZWN0aW9uLXRvLWpzb24uanNcbiAqKiBtb2R1bGUgaWQgPSAyNjhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBmb3JPZiA9IHJlcXVpcmUoJy4vX2Zvci1vZicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0ZXIsIElURVJBVE9SKXtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3JPZihpdGVyLCBmYWxzZSwgcmVzdWx0LnB1c2gsIHJlc3VsdCwgSVRFUkFUT1IpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fYXJyYXktZnJvbS1pdGVyYWJsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDI2OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL0RhdmlkQnJ1YW50L01hcC1TZXQucHJvdG90eXBlLnRvSlNPTlxudmFyICRleHBvcnQgID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5SLCAnU2V0Jywge3RvSlNPTjogcmVxdWlyZSgnLi9fY29sbGVjdGlvbi10by1qc29uJykoJ1NldCcpfSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5zZXQudG8tanNvbi5qc1xuICoqIG1vZHVsZSBpZCA9IDI3MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL2xqaGFyYi9wcm9wb3NhbC1nbG9iYWxcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnU3lzdGVtJywge2dsb2JhbDogcmVxdWlyZSgnLi9fZ2xvYmFsJyl9KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnN5c3RlbS5nbG9iYWwuanNcbiAqKiBtb2R1bGUgaWQgPSAyNzFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9samhhcmIvcHJvcG9zYWwtaXMtZXJyb3JcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBjb2YgICAgID0gcmVxdWlyZSgnLi9fY29mJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnRXJyb3InLCB7XG4gIGlzRXJyb3I6IGZ1bmN0aW9uIGlzRXJyb3IoaXQpe1xuICAgIHJldHVybiBjb2YoaXQpID09PSAnRXJyb3InO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LmVycm9yLmlzLWVycm9yLmpzXG4gKiogbW9kdWxlIGlkID0gMjcyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9CcmVuZGFuRWljaC80Mjk0ZDVjMjEyYTZkMjI1NDcwM1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBpYWRkaDogZnVuY3Rpb24gaWFkZGgoeDAsIHgxLCB5MCwgeTEpe1xuICAgIHZhciAkeDAgPSB4MCA+Pj4gMFxuICAgICAgLCAkeDEgPSB4MSA+Pj4gMFxuICAgICAgLCAkeTAgPSB5MCA+Pj4gMDtcbiAgICByZXR1cm4gJHgxICsgKHkxID4+PiAwKSArICgoJHgwICYgJHkwIHwgKCR4MCB8ICR5MCkgJiB+KCR4MCArICR5MCA+Pj4gMCkpID4+PiAzMSkgfCAwO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGguaWFkZGguanNcbiAqKiBtb2R1bGUgaWQgPSAyNzNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL0JyZW5kYW5FaWNoLzQyOTRkNWMyMTJhNmQyMjU0NzAzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGlzdWJoOiBmdW5jdGlvbiBpc3ViaCh4MCwgeDEsIHkwLCB5MSl7XG4gICAgdmFyICR4MCA9IHgwID4+PiAwXG4gICAgICAsICR4MSA9IHgxID4+PiAwXG4gICAgICAsICR5MCA9IHkwID4+PiAwO1xuICAgIHJldHVybiAkeDEgLSAoeTEgPj4+IDApIC0gKCh+JHgwICYgJHkwIHwgfigkeDAgXiAkeTApICYgJHgwIC0gJHkwID4+PiAwKSA+Pj4gMzEpIHwgMDtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLmlzdWJoLmpzXG4gKiogbW9kdWxlIGlkID0gMjc0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9CcmVuZGFuRWljaC80Mjk0ZDVjMjEyYTZkMjI1NDcwM1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBpbXVsaDogZnVuY3Rpb24gaW11bGgodSwgdil7XG4gICAgdmFyIFVJTlQxNiA9IDB4ZmZmZlxuICAgICAgLCAkdSA9ICt1XG4gICAgICAsICR2ID0gK3ZcbiAgICAgICwgdTAgPSAkdSAmIFVJTlQxNlxuICAgICAgLCB2MCA9ICR2ICYgVUlOVDE2XG4gICAgICAsIHUxID0gJHUgPj4gMTZcbiAgICAgICwgdjEgPSAkdiA+PiAxNlxuICAgICAgLCB0ICA9ICh1MSAqIHYwID4+PiAwKSArICh1MCAqIHYwID4+PiAxNik7XG4gICAgcmV0dXJuIHUxICogdjEgKyAodCA+PiAxNikgKyAoKHUwICogdjEgPj4+IDApICsgKHQgJiBVSU5UMTYpID4+IDE2KTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLmltdWxoLmpzXG4gKiogbW9kdWxlIGlkID0gMjc1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9CcmVuZGFuRWljaC80Mjk0ZDVjMjEyYTZkMjI1NDcwM1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICB1bXVsaDogZnVuY3Rpb24gdW11bGgodSwgdil7XG4gICAgdmFyIFVJTlQxNiA9IDB4ZmZmZlxuICAgICAgLCAkdSA9ICt1XG4gICAgICAsICR2ID0gK3ZcbiAgICAgICwgdTAgPSAkdSAmIFVJTlQxNlxuICAgICAgLCB2MCA9ICR2ICYgVUlOVDE2XG4gICAgICAsIHUxID0gJHUgPj4+IDE2XG4gICAgICAsIHYxID0gJHYgPj4+IDE2XG4gICAgICAsIHQgID0gKHUxICogdjAgPj4+IDApICsgKHUwICogdjAgPj4+IDE2KTtcbiAgICByZXR1cm4gdTEgKiB2MSArICh0ID4+PiAxNikgKyAoKHUwICogdjEgPj4+IDApICsgKHQgJiBVSU5UMTYpID4+PiAxNik7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC51bXVsaC5qc1xuICoqIG1vZHVsZSBpZCA9IDI3NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIG1ldGFkYXRhICAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19tZXRhZGF0YScpXG4gICwgYW5PYmplY3QgICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgdG9NZXRhS2V5ICAgICAgICAgICAgICAgICA9IG1ldGFkYXRhLmtleVxuICAsIG9yZGluYXJ5RGVmaW5lT3duTWV0YWRhdGEgPSBtZXRhZGF0YS5zZXQ7XG5cbm1ldGFkYXRhLmV4cCh7ZGVmaW5lTWV0YWRhdGE6IGZ1bmN0aW9uIGRlZmluZU1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlLCB0YXJnZXQsIHRhcmdldEtleSl7XG4gIG9yZGluYXJ5RGVmaW5lT3duTWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUsIGFuT2JqZWN0KHRhcmdldCksIHRvTWV0YUtleSh0YXJnZXRLZXkpKTtcbn19KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuZGVmaW5lLW1ldGFkYXRhLmpzXG4gKiogbW9kdWxlIGlkID0gMjc3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgTWFwICAgICA9IHJlcXVpcmUoJy4vZXM2Lm1hcCcpXG4gICwgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgc2hhcmVkICA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCdtZXRhZGF0YScpXG4gICwgc3RvcmUgICA9IHNoYXJlZC5zdG9yZSB8fCAoc2hhcmVkLnN0b3JlID0gbmV3IChyZXF1aXJlKCcuL2VzNi53ZWFrLW1hcCcpKSk7XG5cbnZhciBnZXRPckNyZWF0ZU1ldGFkYXRhTWFwID0gZnVuY3Rpb24odGFyZ2V0LCB0YXJnZXRLZXksIGNyZWF0ZSl7XG4gIHZhciB0YXJnZXRNZXRhZGF0YSA9IHN0b3JlLmdldCh0YXJnZXQpO1xuICBpZighdGFyZ2V0TWV0YWRhdGEpe1xuICAgIGlmKCFjcmVhdGUpcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBzdG9yZS5zZXQodGFyZ2V0LCB0YXJnZXRNZXRhZGF0YSA9IG5ldyBNYXApO1xuICB9XG4gIHZhciBrZXlNZXRhZGF0YSA9IHRhcmdldE1ldGFkYXRhLmdldCh0YXJnZXRLZXkpO1xuICBpZigha2V5TWV0YWRhdGEpe1xuICAgIGlmKCFjcmVhdGUpcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB0YXJnZXRNZXRhZGF0YS5zZXQodGFyZ2V0S2V5LCBrZXlNZXRhZGF0YSA9IG5ldyBNYXApO1xuICB9IHJldHVybiBrZXlNZXRhZGF0YTtcbn07XG52YXIgb3JkaW5hcnlIYXNPd25NZXRhZGF0YSA9IGZ1bmN0aW9uKE1ldGFkYXRhS2V5LCBPLCBQKXtcbiAgdmFyIG1ldGFkYXRhTWFwID0gZ2V0T3JDcmVhdGVNZXRhZGF0YU1hcChPLCBQLCBmYWxzZSk7XG4gIHJldHVybiBtZXRhZGF0YU1hcCA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBtZXRhZGF0YU1hcC5oYXMoTWV0YWRhdGFLZXkpO1xufTtcbnZhciBvcmRpbmFyeUdldE93bk1ldGFkYXRhID0gZnVuY3Rpb24oTWV0YWRhdGFLZXksIE8sIFApe1xuICB2YXIgbWV0YWRhdGFNYXAgPSBnZXRPckNyZWF0ZU1ldGFkYXRhTWFwKE8sIFAsIGZhbHNlKTtcbiAgcmV0dXJuIG1ldGFkYXRhTWFwID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBtZXRhZGF0YU1hcC5nZXQoTWV0YWRhdGFLZXkpO1xufTtcbnZhciBvcmRpbmFyeURlZmluZU93bk1ldGFkYXRhID0gZnVuY3Rpb24oTWV0YWRhdGFLZXksIE1ldGFkYXRhVmFsdWUsIE8sIFApe1xuICBnZXRPckNyZWF0ZU1ldGFkYXRhTWFwKE8sIFAsIHRydWUpLnNldChNZXRhZGF0YUtleSwgTWV0YWRhdGFWYWx1ZSk7XG59O1xudmFyIG9yZGluYXJ5T3duTWV0YWRhdGFLZXlzID0gZnVuY3Rpb24odGFyZ2V0LCB0YXJnZXRLZXkpe1xuICB2YXIgbWV0YWRhdGFNYXAgPSBnZXRPckNyZWF0ZU1ldGFkYXRhTWFwKHRhcmdldCwgdGFyZ2V0S2V5LCBmYWxzZSlcbiAgICAsIGtleXMgICAgICAgID0gW107XG4gIGlmKG1ldGFkYXRhTWFwKW1ldGFkYXRhTWFwLmZvckVhY2goZnVuY3Rpb24oXywga2V5KXsga2V5cy5wdXNoKGtleSk7IH0pO1xuICByZXR1cm4ga2V5cztcbn07XG52YXIgdG9NZXRhS2V5ID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgaXQgPT0gJ3N5bWJvbCcgPyBpdCA6IFN0cmluZyhpdCk7XG59O1xudmFyIGV4cCA9IGZ1bmN0aW9uKE8pe1xuICAkZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCBPKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzdG9yZTogc3RvcmUsXG4gIG1hcDogZ2V0T3JDcmVhdGVNZXRhZGF0YU1hcCxcbiAgaGFzOiBvcmRpbmFyeUhhc093bk1ldGFkYXRhLFxuICBnZXQ6IG9yZGluYXJ5R2V0T3duTWV0YWRhdGEsXG4gIHNldDogb3JkaW5hcnlEZWZpbmVPd25NZXRhZGF0YSxcbiAga2V5czogb3JkaW5hcnlPd25NZXRhZGF0YUtleXMsXG4gIGtleTogdG9NZXRhS2V5LFxuICBleHA6IGV4cFxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX21ldGFkYXRhLmpzXG4gKiogbW9kdWxlIGlkID0gMjc4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgbWV0YWRhdGEgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX21ldGFkYXRhJylcbiAgLCBhbk9iamVjdCAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCB0b01ldGFLZXkgICAgICAgICAgICAgID0gbWV0YWRhdGEua2V5XG4gICwgZ2V0T3JDcmVhdGVNZXRhZGF0YU1hcCA9IG1ldGFkYXRhLm1hcFxuICAsIHN0b3JlICAgICAgICAgICAgICAgICAgPSBtZXRhZGF0YS5zdG9yZTtcblxubWV0YWRhdGEuZXhwKHtkZWxldGVNZXRhZGF0YTogZnVuY3Rpb24gZGVsZXRlTWV0YWRhdGEobWV0YWRhdGFLZXksIHRhcmdldCAvKiwgdGFyZ2V0S2V5ICovKXtcbiAgdmFyIHRhcmdldEtleSAgID0gYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiB0b01ldGFLZXkoYXJndW1lbnRzWzJdKVxuICAgICwgbWV0YWRhdGFNYXAgPSBnZXRPckNyZWF0ZU1ldGFkYXRhTWFwKGFuT2JqZWN0KHRhcmdldCksIHRhcmdldEtleSwgZmFsc2UpO1xuICBpZihtZXRhZGF0YU1hcCA9PT0gdW5kZWZpbmVkIHx8ICFtZXRhZGF0YU1hcFsnZGVsZXRlJ10obWV0YWRhdGFLZXkpKXJldHVybiBmYWxzZTtcbiAgaWYobWV0YWRhdGFNYXAuc2l6ZSlyZXR1cm4gdHJ1ZTtcbiAgdmFyIHRhcmdldE1ldGFkYXRhID0gc3RvcmUuZ2V0KHRhcmdldCk7XG4gIHRhcmdldE1ldGFkYXRhWydkZWxldGUnXSh0YXJnZXRLZXkpO1xuICByZXR1cm4gISF0YXJnZXRNZXRhZGF0YS5zaXplIHx8IHN0b3JlWydkZWxldGUnXSh0YXJnZXQpO1xufX0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5kZWxldGUtbWV0YWRhdGEuanNcbiAqKiBtb2R1bGUgaWQgPSAyNzlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBtZXRhZGF0YSAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKVxuICAsIGFuT2JqZWN0ICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIGdldFByb3RvdHlwZU9mICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJylcbiAgLCBvcmRpbmFyeUhhc093bk1ldGFkYXRhID0gbWV0YWRhdGEuaGFzXG4gICwgb3JkaW5hcnlHZXRPd25NZXRhZGF0YSA9IG1ldGFkYXRhLmdldFxuICAsIHRvTWV0YUtleSAgICAgICAgICAgICAgPSBtZXRhZGF0YS5rZXk7XG5cbnZhciBvcmRpbmFyeUdldE1ldGFkYXRhID0gZnVuY3Rpb24oTWV0YWRhdGFLZXksIE8sIFApe1xuICB2YXIgaGFzT3duID0gb3JkaW5hcnlIYXNPd25NZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUCk7XG4gIGlmKGhhc093bilyZXR1cm4gb3JkaW5hcnlHZXRPd25NZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUCk7XG4gIHZhciBwYXJlbnQgPSBnZXRQcm90b3R5cGVPZihPKTtcbiAgcmV0dXJuIHBhcmVudCAhPT0gbnVsbCA/IG9yZGluYXJ5R2V0TWV0YWRhdGEoTWV0YWRhdGFLZXksIHBhcmVudCwgUCkgOiB1bmRlZmluZWQ7XG59O1xuXG5tZXRhZGF0YS5leHAoe2dldE1ldGFkYXRhOiBmdW5jdGlvbiBnZXRNZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0IC8qLCB0YXJnZXRLZXkgKi8pe1xuICByZXR1cm4gb3JkaW5hcnlHZXRNZXRhZGF0YShtZXRhZGF0YUtleSwgYW5PYmplY3QodGFyZ2V0KSwgYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiB0b01ldGFLZXkoYXJndW1lbnRzWzJdKSk7XG59fSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0LmdldC1tZXRhZGF0YS5qc1xuICoqIG1vZHVsZSBpZCA9IDI4MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIFNldCAgICAgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9lczYuc2V0JylcbiAgLCBmcm9tICAgICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2FycmF5LWZyb20taXRlcmFibGUnKVxuICAsIG1ldGFkYXRhICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKVxuICAsIGFuT2JqZWN0ICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBnZXRQcm90b3R5cGVPZiAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKVxuICAsIG9yZGluYXJ5T3duTWV0YWRhdGFLZXlzID0gbWV0YWRhdGEua2V5c1xuICAsIHRvTWV0YUtleSAgICAgICAgICAgICAgID0gbWV0YWRhdGEua2V5O1xuXG52YXIgb3JkaW5hcnlNZXRhZGF0YUtleXMgPSBmdW5jdGlvbihPLCBQKXtcbiAgdmFyIG9LZXlzICA9IG9yZGluYXJ5T3duTWV0YWRhdGFLZXlzKE8sIFApXG4gICAgLCBwYXJlbnQgPSBnZXRQcm90b3R5cGVPZihPKTtcbiAgaWYocGFyZW50ID09PSBudWxsKXJldHVybiBvS2V5cztcbiAgdmFyIHBLZXlzICA9IG9yZGluYXJ5TWV0YWRhdGFLZXlzKHBhcmVudCwgUCk7XG4gIHJldHVybiBwS2V5cy5sZW5ndGggPyBvS2V5cy5sZW5ndGggPyBmcm9tKG5ldyBTZXQob0tleXMuY29uY2F0KHBLZXlzKSkpIDogcEtleXMgOiBvS2V5cztcbn07XG5cbm1ldGFkYXRhLmV4cCh7Z2V0TWV0YWRhdGFLZXlzOiBmdW5jdGlvbiBnZXRNZXRhZGF0YUtleXModGFyZ2V0IC8qLCB0YXJnZXRLZXkgKi8pe1xuICByZXR1cm4gb3JkaW5hcnlNZXRhZGF0YUtleXMoYW5PYmplY3QodGFyZ2V0KSwgYXJndW1lbnRzLmxlbmd0aCA8IDIgPyB1bmRlZmluZWQgOiB0b01ldGFLZXkoYXJndW1lbnRzWzFdKSk7XG59fSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0LmdldC1tZXRhZGF0YS1rZXlzLmpzXG4gKiogbW9kdWxlIGlkID0gMjgxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgbWV0YWRhdGEgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX21ldGFkYXRhJylcbiAgLCBhbk9iamVjdCAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBvcmRpbmFyeUdldE93bk1ldGFkYXRhID0gbWV0YWRhdGEuZ2V0XG4gICwgdG9NZXRhS2V5ICAgICAgICAgICAgICA9IG1ldGFkYXRhLmtleTtcblxubWV0YWRhdGEuZXhwKHtnZXRPd25NZXRhZGF0YTogZnVuY3Rpb24gZ2V0T3duTWV0YWRhdGEobWV0YWRhdGFLZXksIHRhcmdldCAvKiwgdGFyZ2V0S2V5ICovKXtcbiAgcmV0dXJuIG9yZGluYXJ5R2V0T3duTWV0YWRhdGEobWV0YWRhdGFLZXksIGFuT2JqZWN0KHRhcmdldClcbiAgICAsIGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdW5kZWZpbmVkIDogdG9NZXRhS2V5KGFyZ3VtZW50c1syXSkpO1xufX0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtb3duLW1ldGFkYXRhLmpzXG4gKiogbW9kdWxlIGlkID0gMjgyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgbWV0YWRhdGEgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19tZXRhZGF0YScpXG4gICwgYW5PYmplY3QgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIG9yZGluYXJ5T3duTWV0YWRhdGFLZXlzID0gbWV0YWRhdGEua2V5c1xuICAsIHRvTWV0YUtleSAgICAgICAgICAgICAgID0gbWV0YWRhdGEua2V5O1xuXG5tZXRhZGF0YS5leHAoe2dldE93bk1ldGFkYXRhS2V5czogZnVuY3Rpb24gZ2V0T3duTWV0YWRhdGFLZXlzKHRhcmdldCAvKiwgdGFyZ2V0S2V5ICovKXtcbiAgcmV0dXJuIG9yZGluYXJ5T3duTWV0YWRhdGFLZXlzKGFuT2JqZWN0KHRhcmdldCksIGFyZ3VtZW50cy5sZW5ndGggPCAyID8gdW5kZWZpbmVkIDogdG9NZXRhS2V5KGFyZ3VtZW50c1sxXSkpO1xufX0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtb3duLW1ldGFkYXRhLWtleXMuanNcbiAqKiBtb2R1bGUgaWQgPSAyODNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBtZXRhZGF0YSAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKVxuICAsIGFuT2JqZWN0ICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIGdldFByb3RvdHlwZU9mICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJylcbiAgLCBvcmRpbmFyeUhhc093bk1ldGFkYXRhID0gbWV0YWRhdGEuaGFzXG4gICwgdG9NZXRhS2V5ICAgICAgICAgICAgICA9IG1ldGFkYXRhLmtleTtcblxudmFyIG9yZGluYXJ5SGFzTWV0YWRhdGEgPSBmdW5jdGlvbihNZXRhZGF0YUtleSwgTywgUCl7XG4gIHZhciBoYXNPd24gPSBvcmRpbmFyeUhhc093bk1ldGFkYXRhKE1ldGFkYXRhS2V5LCBPLCBQKTtcbiAgaWYoaGFzT3duKXJldHVybiB0cnVlO1xuICB2YXIgcGFyZW50ID0gZ2V0UHJvdG90eXBlT2YoTyk7XG4gIHJldHVybiBwYXJlbnQgIT09IG51bGwgPyBvcmRpbmFyeUhhc01ldGFkYXRhKE1ldGFkYXRhS2V5LCBwYXJlbnQsIFApIDogZmFsc2U7XG59O1xuXG5tZXRhZGF0YS5leHAoe2hhc01ldGFkYXRhOiBmdW5jdGlvbiBoYXNNZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0IC8qLCB0YXJnZXRLZXkgKi8pe1xuICByZXR1cm4gb3JkaW5hcnlIYXNNZXRhZGF0YShtZXRhZGF0YUtleSwgYW5PYmplY3QodGFyZ2V0KSwgYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiB0b01ldGFLZXkoYXJndW1lbnRzWzJdKSk7XG59fSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0Lmhhcy1tZXRhZGF0YS5qc1xuICoqIG1vZHVsZSBpZCA9IDI4NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIG1ldGFkYXRhICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19tZXRhZGF0YScpXG4gICwgYW5PYmplY3QgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgb3JkaW5hcnlIYXNPd25NZXRhZGF0YSA9IG1ldGFkYXRhLmhhc1xuICAsIHRvTWV0YUtleSAgICAgICAgICAgICAgPSBtZXRhZGF0YS5rZXk7XG5cbm1ldGFkYXRhLmV4cCh7aGFzT3duTWV0YWRhdGE6IGZ1bmN0aW9uIGhhc093bk1ldGFkYXRhKG1ldGFkYXRhS2V5LCB0YXJnZXQgLyosIHRhcmdldEtleSAqLyl7XG4gIHJldHVybiBvcmRpbmFyeUhhc093bk1ldGFkYXRhKG1ldGFkYXRhS2V5LCBhbk9iamVjdCh0YXJnZXQpXG4gICAgLCBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IHRvTWV0YUtleShhcmd1bWVudHNbMl0pKTtcbn19KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuaGFzLW93bi1tZXRhZGF0YS5qc1xuICoqIG1vZHVsZSBpZCA9IDI4NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIG1ldGFkYXRhICAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19tZXRhZGF0YScpXG4gICwgYW5PYmplY3QgICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgYUZ1bmN0aW9uICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKVxuICAsIHRvTWV0YUtleSAgICAgICAgICAgICAgICAgPSBtZXRhZGF0YS5rZXlcbiAgLCBvcmRpbmFyeURlZmluZU93bk1ldGFkYXRhID0gbWV0YWRhdGEuc2V0O1xuXG5tZXRhZGF0YS5leHAoe21ldGFkYXRhOiBmdW5jdGlvbiBtZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSl7XG4gIHJldHVybiBmdW5jdGlvbiBkZWNvcmF0b3IodGFyZ2V0LCB0YXJnZXRLZXkpe1xuICAgIG9yZGluYXJ5RGVmaW5lT3duTWV0YWRhdGEoXG4gICAgICBtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSxcbiAgICAgICh0YXJnZXRLZXkgIT09IHVuZGVmaW5lZCA/IGFuT2JqZWN0IDogYUZ1bmN0aW9uKSh0YXJnZXQpLFxuICAgICAgdG9NZXRhS2V5KHRhcmdldEtleSlcbiAgICApO1xuICB9O1xufX0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5tZXRhZGF0YS5qc1xuICoqIG1vZHVsZSBpZCA9IDI4NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3J3YWxkcm9uL3RjMzktbm90ZXMvYmxvYi9tYXN0ZXIvZXM2LzIwMTQtMDkvc2VwdC0yNS5tZCM1MTAtZ2xvYmFsYXNhcC1mb3ItZW5xdWV1aW5nLWEtbWljcm90YXNrXHJcbnZhciAkZXhwb3J0ICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxyXG4gICwgbWljcm90YXNrID0gcmVxdWlyZSgnLi9fbWljcm90YXNrJykoKVxyXG4gICwgcHJvY2VzcyAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykucHJvY2Vzc1xyXG4gICwgaXNOb2RlICAgID0gcmVxdWlyZSgnLi9fY29mJykocHJvY2VzcykgPT0gJ3Byb2Nlc3MnO1xyXG5cclxuJGV4cG9ydCgkZXhwb3J0LkcsIHtcclxuICBhc2FwOiBmdW5jdGlvbiBhc2FwKGZuKXtcclxuICAgIHZhciBkb21haW4gPSBpc05vZGUgJiYgcHJvY2Vzcy5kb21haW47XHJcbiAgICBtaWNyb3Rhc2soZG9tYWluID8gZG9tYWluLmJpbmQoZm4pIDogZm4pO1xyXG4gIH1cclxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5hc2FwLmpzXG4gKiogbW9kdWxlIGlkID0gMjg3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96ZW5wYXJzaW5nL2VzLW9ic2VydmFibGVcclxudmFyICRleHBvcnQgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcclxuICAsIGdsb2JhbCAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcclxuICAsIGNvcmUgICAgICAgID0gcmVxdWlyZSgnLi9fY29yZScpXHJcbiAgLCBtaWNyb3Rhc2sgICA9IHJlcXVpcmUoJy4vX21pY3JvdGFzaycpKClcclxuICAsIE9CU0VSVkFCTEUgID0gcmVxdWlyZSgnLi9fd2tzJykoJ29ic2VydmFibGUnKVxyXG4gICwgYUZ1bmN0aW9uICAgPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJylcclxuICAsIGFuT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcclxuICAsIGFuSW5zdGFuY2UgID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKVxyXG4gICwgcmVkZWZpbmVBbGwgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKVxyXG4gICwgaGlkZSAgICAgICAgPSByZXF1aXJlKCcuL19oaWRlJylcclxuICAsIGZvck9mICAgICAgID0gcmVxdWlyZSgnLi9fZm9yLW9mJylcclxuICAsIFJFVFVSTiAgICAgID0gZm9yT2YuUkVUVVJOO1xyXG5cclxudmFyIGdldE1ldGhvZCA9IGZ1bmN0aW9uKGZuKXtcclxuICByZXR1cm4gZm4gPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGFGdW5jdGlvbihmbik7XHJcbn07XHJcblxyXG52YXIgY2xlYW51cFN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uKHN1YnNjcmlwdGlvbil7XHJcbiAgdmFyIGNsZWFudXAgPSBzdWJzY3JpcHRpb24uX2M7XHJcbiAgaWYoY2xlYW51cCl7XHJcbiAgICBzdWJzY3JpcHRpb24uX2MgPSB1bmRlZmluZWQ7XHJcbiAgICBjbGVhbnVwKCk7XHJcbiAgfVxyXG59O1xyXG5cclxudmFyIHN1YnNjcmlwdGlvbkNsb3NlZCA9IGZ1bmN0aW9uKHN1YnNjcmlwdGlvbil7XHJcbiAgcmV0dXJuIHN1YnNjcmlwdGlvbi5fbyA9PT0gdW5kZWZpbmVkO1xyXG59O1xyXG5cclxudmFyIGNsb3NlU3Vic2NyaXB0aW9uID0gZnVuY3Rpb24oc3Vic2NyaXB0aW9uKXtcclxuICBpZighc3Vic2NyaXB0aW9uQ2xvc2VkKHN1YnNjcmlwdGlvbikpe1xyXG4gICAgc3Vic2NyaXB0aW9uLl9vID0gdW5kZWZpbmVkO1xyXG4gICAgY2xlYW51cFN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pO1xyXG4gIH1cclxufTtcclxuXHJcbnZhciBTdWJzY3JpcHRpb24gPSBmdW5jdGlvbihvYnNlcnZlciwgc3Vic2NyaWJlcil7XHJcbiAgYW5PYmplY3Qob2JzZXJ2ZXIpO1xyXG4gIHRoaXMuX2MgPSB1bmRlZmluZWQ7XHJcbiAgdGhpcy5fbyA9IG9ic2VydmVyO1xyXG4gIG9ic2VydmVyID0gbmV3IFN1YnNjcmlwdGlvbk9ic2VydmVyKHRoaXMpO1xyXG4gIHRyeSB7XHJcbiAgICB2YXIgY2xlYW51cCAgICAgID0gc3Vic2NyaWJlcihvYnNlcnZlcilcclxuICAgICAgLCBzdWJzY3JpcHRpb24gPSBjbGVhbnVwO1xyXG4gICAgaWYoY2xlYW51cCAhPSBudWxsKXtcclxuICAgICAgaWYodHlwZW9mIGNsZWFudXAudW5zdWJzY3JpYmUgPT09ICdmdW5jdGlvbicpY2xlYW51cCA9IGZ1bmN0aW9uKCl7IHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpOyB9O1xyXG4gICAgICBlbHNlIGFGdW5jdGlvbihjbGVhbnVwKTtcclxuICAgICAgdGhpcy5fYyA9IGNsZWFudXA7XHJcbiAgICB9XHJcbiAgfSBjYXRjaChlKXtcclxuICAgIG9ic2VydmVyLmVycm9yKGUpO1xyXG4gICAgcmV0dXJuO1xyXG4gIH0gaWYoc3Vic2NyaXB0aW9uQ2xvc2VkKHRoaXMpKWNsZWFudXBTdWJzY3JpcHRpb24odGhpcyk7XHJcbn07XHJcblxyXG5TdWJzY3JpcHRpb24ucHJvdG90eXBlID0gcmVkZWZpbmVBbGwoe30sIHtcclxuICB1bnN1YnNjcmliZTogZnVuY3Rpb24gdW5zdWJzY3JpYmUoKXsgY2xvc2VTdWJzY3JpcHRpb24odGhpcyk7IH1cclxufSk7XHJcblxyXG52YXIgU3Vic2NyaXB0aW9uT2JzZXJ2ZXIgPSBmdW5jdGlvbihzdWJzY3JpcHRpb24pe1xyXG4gIHRoaXMuX3MgPSBzdWJzY3JpcHRpb247XHJcbn07XHJcblxyXG5TdWJzY3JpcHRpb25PYnNlcnZlci5wcm90b3R5cGUgPSByZWRlZmluZUFsbCh7fSwge1xyXG4gIG5leHQ6IGZ1bmN0aW9uIG5leHQodmFsdWUpe1xyXG4gICAgdmFyIHN1YnNjcmlwdGlvbiA9IHRoaXMuX3M7XHJcbiAgICBpZighc3Vic2NyaXB0aW9uQ2xvc2VkKHN1YnNjcmlwdGlvbikpe1xyXG4gICAgICB2YXIgb2JzZXJ2ZXIgPSBzdWJzY3JpcHRpb24uX287XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgdmFyIG0gPSBnZXRNZXRob2Qob2JzZXJ2ZXIubmV4dCk7XHJcbiAgICAgICAgaWYobSlyZXR1cm4gbS5jYWxsKG9ic2VydmVyLCB2YWx1ZSk7XHJcbiAgICAgIH0gY2F0Y2goZSl7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGNsb3NlU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbik7XHJcbiAgICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICAgIHRocm93IGU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSxcclxuICBlcnJvcjogZnVuY3Rpb24gZXJyb3IodmFsdWUpe1xyXG4gICAgdmFyIHN1YnNjcmlwdGlvbiA9IHRoaXMuX3M7XHJcbiAgICBpZihzdWJzY3JpcHRpb25DbG9zZWQoc3Vic2NyaXB0aW9uKSl0aHJvdyB2YWx1ZTtcclxuICAgIHZhciBvYnNlcnZlciA9IHN1YnNjcmlwdGlvbi5fbztcclxuICAgIHN1YnNjcmlwdGlvbi5fbyA9IHVuZGVmaW5lZDtcclxuICAgIHRyeSB7XHJcbiAgICAgIHZhciBtID0gZ2V0TWV0aG9kKG9ic2VydmVyLmVycm9yKTtcclxuICAgICAgaWYoIW0pdGhyb3cgdmFsdWU7XHJcbiAgICAgIHZhbHVlID0gbS5jYWxsKG9ic2VydmVyLCB2YWx1ZSk7XHJcbiAgICB9IGNhdGNoKGUpe1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNsZWFudXBTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKTtcclxuICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICB0aHJvdyBlO1xyXG4gICAgICB9XHJcbiAgICB9IGNsZWFudXBTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKTtcclxuICAgIHJldHVybiB2YWx1ZTtcclxuICB9LFxyXG4gIGNvbXBsZXRlOiBmdW5jdGlvbiBjb21wbGV0ZSh2YWx1ZSl7XHJcbiAgICB2YXIgc3Vic2NyaXB0aW9uID0gdGhpcy5fcztcclxuICAgIGlmKCFzdWJzY3JpcHRpb25DbG9zZWQoc3Vic2NyaXB0aW9uKSl7XHJcbiAgICAgIHZhciBvYnNlcnZlciA9IHN1YnNjcmlwdGlvbi5fbztcclxuICAgICAgc3Vic2NyaXB0aW9uLl9vID0gdW5kZWZpbmVkO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHZhciBtID0gZ2V0TWV0aG9kKG9ic2VydmVyLmNvbXBsZXRlKTtcclxuICAgICAgICB2YWx1ZSA9IG0gPyBtLmNhbGwob2JzZXJ2ZXIsIHZhbHVlKSA6IHVuZGVmaW5lZDtcclxuICAgICAgfSBjYXRjaChlKXtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgY2xlYW51cFN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pO1xyXG4gICAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgICB0aHJvdyBlO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBjbGVhbnVwU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbik7XHJcbiAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuICB9XHJcbn0pO1xyXG5cclxudmFyICRPYnNlcnZhYmxlID0gZnVuY3Rpb24gT2JzZXJ2YWJsZShzdWJzY3JpYmVyKXtcclxuICBhbkluc3RhbmNlKHRoaXMsICRPYnNlcnZhYmxlLCAnT2JzZXJ2YWJsZScsICdfZicpLl9mID0gYUZ1bmN0aW9uKHN1YnNjcmliZXIpO1xyXG59O1xyXG5cclxucmVkZWZpbmVBbGwoJE9ic2VydmFibGUucHJvdG90eXBlLCB7XHJcbiAgc3Vic2NyaWJlOiBmdW5jdGlvbiBzdWJzY3JpYmUob2JzZXJ2ZXIpe1xyXG4gICAgcmV0dXJuIG5ldyBTdWJzY3JpcHRpb24ob2JzZXJ2ZXIsIHRoaXMuX2YpO1xyXG4gIH0sXHJcbiAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChmbil7XHJcbiAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICByZXR1cm4gbmV3IChjb3JlLlByb21pc2UgfHwgZ2xvYmFsLlByb21pc2UpKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XHJcbiAgICAgIGFGdW5jdGlvbihmbik7XHJcbiAgICAgIHZhciBzdWJzY3JpcHRpb24gPSB0aGF0LnN1YnNjcmliZSh7XHJcbiAgICAgICAgbmV4dCA6IGZ1bmN0aW9uKHZhbHVlKXtcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmbih2YWx1ZSk7XHJcbiAgICAgICAgICB9IGNhdGNoKGUpe1xyXG4gICAgICAgICAgICByZWplY3QoZSk7XHJcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZXJyb3I6IHJlamVjdCxcclxuICAgICAgICBjb21wbGV0ZTogcmVzb2x2ZVxyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH1cclxufSk7XHJcblxyXG5yZWRlZmluZUFsbCgkT2JzZXJ2YWJsZSwge1xyXG4gIGZyb206IGZ1bmN0aW9uIGZyb20oeCl7XHJcbiAgICB2YXIgQyA9IHR5cGVvZiB0aGlzID09PSAnZnVuY3Rpb24nID8gdGhpcyA6ICRPYnNlcnZhYmxlO1xyXG4gICAgdmFyIG1ldGhvZCA9IGdldE1ldGhvZChhbk9iamVjdCh4KVtPQlNFUlZBQkxFXSk7XHJcbiAgICBpZihtZXRob2Qpe1xyXG4gICAgICB2YXIgb2JzZXJ2YWJsZSA9IGFuT2JqZWN0KG1ldGhvZC5jYWxsKHgpKTtcclxuICAgICAgcmV0dXJuIG9ic2VydmFibGUuY29uc3RydWN0b3IgPT09IEMgPyBvYnNlcnZhYmxlIDogbmV3IEMoZnVuY3Rpb24ob2JzZXJ2ZXIpe1xyXG4gICAgICAgIHJldHVybiBvYnNlcnZhYmxlLnN1YnNjcmliZShvYnNlcnZlcik7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyBDKGZ1bmN0aW9uKG9ic2VydmVyKXtcclxuICAgICAgdmFyIGRvbmUgPSBmYWxzZTtcclxuICAgICAgbWljcm90YXNrKGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgaWYoIWRvbmUpe1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYoZm9yT2YoeCwgZmFsc2UsIGZ1bmN0aW9uKGl0KXtcclxuICAgICAgICAgICAgICBvYnNlcnZlci5uZXh0KGl0KTtcclxuICAgICAgICAgICAgICBpZihkb25lKXJldHVybiBSRVRVUk47XHJcbiAgICAgICAgICAgIH0pID09PSBSRVRVUk4pcmV0dXJuO1xyXG4gICAgICAgICAgfSBjYXRjaChlKXtcclxuICAgICAgICAgICAgaWYoZG9uZSl0aHJvdyBlO1xyXG4gICAgICAgICAgICBvYnNlcnZlci5lcnJvcihlKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfSBvYnNlcnZlci5jb21wbGV0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgIHJldHVybiBmdW5jdGlvbigpeyBkb25lID0gdHJ1ZTsgfTtcclxuICAgIH0pO1xyXG4gIH0sXHJcbiAgb2Y6IGZ1bmN0aW9uIG9mKCl7XHJcbiAgICBmb3IodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aCwgaXRlbXMgPSBBcnJheShsKTsgaSA8IGw7KWl0ZW1zW2ldID0gYXJndW1lbnRzW2krK107XHJcbiAgICByZXR1cm4gbmV3ICh0eXBlb2YgdGhpcyA9PT0gJ2Z1bmN0aW9uJyA/IHRoaXMgOiAkT2JzZXJ2YWJsZSkoZnVuY3Rpb24ob2JzZXJ2ZXIpe1xyXG4gICAgICB2YXIgZG9uZSA9IGZhbHNlO1xyXG4gICAgICBtaWNyb3Rhc2soZnVuY3Rpb24oKXtcclxuICAgICAgICBpZighZG9uZSl7XHJcbiAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgICAgICBvYnNlcnZlci5uZXh0KGl0ZW1zW2ldKTtcclxuICAgICAgICAgICAgaWYoZG9uZSlyZXR1cm47XHJcbiAgICAgICAgICB9IG9ic2VydmVyLmNvbXBsZXRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCl7IGRvbmUgPSB0cnVlOyB9O1xyXG4gICAgfSk7XHJcbiAgfVxyXG59KTtcclxuXHJcbmhpZGUoJE9ic2VydmFibGUucHJvdG90eXBlLCBPQlNFUlZBQkxFLCBmdW5jdGlvbigpeyByZXR1cm4gdGhpczsgfSk7XHJcblxyXG4kZXhwb3J0KCRleHBvcnQuRywge09ic2VydmFibGU6ICRPYnNlcnZhYmxlfSk7XHJcblxyXG5yZXF1aXJlKCcuL19zZXQtc3BlY2llcycpKCdPYnNlcnZhYmxlJyk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5vYnNlcnZhYmxlLmpzXG4gKiogbW9kdWxlIGlkID0gMjg4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBpZTktIHNldFRpbWVvdXQgJiBzZXRJbnRlcnZhbCBhZGRpdGlvbmFsIHBhcmFtZXRlcnMgZml4XG52YXIgZ2xvYmFsICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgJGV4cG9ydCAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgaW52b2tlICAgICA9IHJlcXVpcmUoJy4vX2ludm9rZScpXG4gICwgcGFydGlhbCAgICA9IHJlcXVpcmUoJy4vX3BhcnRpYWwnKVxuICAsIG5hdmlnYXRvciAgPSBnbG9iYWwubmF2aWdhdG9yXG4gICwgTVNJRSAgICAgICA9ICEhbmF2aWdhdG9yICYmIC9NU0lFIC5cXC4vLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7IC8vIDwtIGRpcnR5IGllOS0gY2hlY2tcbnZhciB3cmFwID0gZnVuY3Rpb24oc2V0KXtcbiAgcmV0dXJuIE1TSUUgPyBmdW5jdGlvbihmbiwgdGltZSAvKiwgLi4uYXJncyAqLyl7XG4gICAgcmV0dXJuIHNldChpbnZva2UoXG4gICAgICBwYXJ0aWFsLFxuICAgICAgW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpLFxuICAgICAgdHlwZW9mIGZuID09ICdmdW5jdGlvbicgPyBmbiA6IEZ1bmN0aW9uKGZuKVxuICAgICksIHRpbWUpO1xuICB9IDogc2V0O1xufTtcbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5CICsgJGV4cG9ydC5GICogTVNJRSwge1xuICBzZXRUaW1lb3V0OiAgd3JhcChnbG9iYWwuc2V0VGltZW91dCksXG4gIHNldEludGVydmFsOiB3cmFwKGdsb2JhbC5zZXRJbnRlcnZhbClcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy93ZWIudGltZXJzLmpzXG4gKiogbW9kdWxlIGlkID0gMjg5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgcGF0aCAgICAgID0gcmVxdWlyZSgnLi9fcGF0aCcpXG4gICwgaW52b2tlICAgID0gcmVxdWlyZSgnLi9faW52b2tlJylcbiAgLCBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKC8qIC4uLnBhcmdzICovKXtcbiAgdmFyIGZuICAgICA9IGFGdW5jdGlvbih0aGlzKVxuICAgICwgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICwgcGFyZ3MgID0gQXJyYXkobGVuZ3RoKVxuICAgICwgaSAgICAgID0gMFxuICAgICwgXyAgICAgID0gcGF0aC5fXG4gICAgLCBob2xkZXIgPSBmYWxzZTtcbiAgd2hpbGUobGVuZ3RoID4gaSlpZigocGFyZ3NbaV0gPSBhcmd1bWVudHNbaSsrXSkgPT09IF8paG9sZGVyID0gdHJ1ZTtcbiAgcmV0dXJuIGZ1bmN0aW9uKC8qIC4uLmFyZ3MgKi8pe1xuICAgIHZhciB0aGF0ID0gdGhpc1xuICAgICAgLCBhTGVuID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgLCBqID0gMCwgayA9IDAsIGFyZ3M7XG4gICAgaWYoIWhvbGRlciAmJiAhYUxlbilyZXR1cm4gaW52b2tlKGZuLCBwYXJncywgdGhhdCk7XG4gICAgYXJncyA9IHBhcmdzLnNsaWNlKCk7XG4gICAgaWYoaG9sZGVyKWZvcig7bGVuZ3RoID4gajsgaisrKWlmKGFyZ3Nbal0gPT09IF8pYXJnc1tqXSA9IGFyZ3VtZW50c1trKytdO1xuICAgIHdoaWxlKGFMZW4gPiBrKWFyZ3MucHVzaChhcmd1bWVudHNbaysrXSk7XG4gICAgcmV0dXJuIGludm9rZShmbiwgYXJncywgdGhhdCk7XG4gIH07XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fcGFydGlhbC5qc1xuICoqIG1vZHVsZSBpZCA9IDI5MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX3BhdGguanNcbiAqKiBtb2R1bGUgaWQgPSAyOTFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkdGFzayAgID0gcmVxdWlyZSgnLi9fdGFzaycpO1xuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LkIsIHtcbiAgc2V0SW1tZWRpYXRlOiAgICR0YXNrLnNldCxcbiAgY2xlYXJJbW1lZGlhdGU6ICR0YXNrLmNsZWFyXG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvd2ViLmltbWVkaWF0ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDI5MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyICRpdGVyYXRvcnMgICAgPSByZXF1aXJlKCcuL2VzNi5hcnJheS5pdGVyYXRvcicpXG4gICwgcmVkZWZpbmUgICAgICA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJylcbiAgLCBnbG9iYWwgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBoaWRlICAgICAgICAgID0gcmVxdWlyZSgnLi9faGlkZScpXG4gICwgSXRlcmF0b3JzICAgICA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpXG4gICwgd2tzICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3drcycpXG4gICwgSVRFUkFUT1IgICAgICA9IHdrcygnaXRlcmF0b3InKVxuICAsIFRPX1NUUklOR19UQUcgPSB3a3MoJ3RvU3RyaW5nVGFnJylcbiAgLCBBcnJheVZhbHVlcyAgID0gSXRlcmF0b3JzLkFycmF5O1xuXG5mb3IodmFyIGNvbGxlY3Rpb25zID0gWydOb2RlTGlzdCcsICdET01Ub2tlbkxpc3QnLCAnTWVkaWFMaXN0JywgJ1N0eWxlU2hlZXRMaXN0JywgJ0NTU1J1bGVMaXN0J10sIGkgPSAwOyBpIDwgNTsgaSsrKXtcbiAgdmFyIE5BTUUgICAgICAgPSBjb2xsZWN0aW9uc1tpXVxuICAgICwgQ29sbGVjdGlvbiA9IGdsb2JhbFtOQU1FXVxuICAgICwgcHJvdG8gICAgICA9IENvbGxlY3Rpb24gJiYgQ29sbGVjdGlvbi5wcm90b3R5cGVcbiAgICAsIGtleTtcbiAgaWYocHJvdG8pe1xuICAgIGlmKCFwcm90b1tJVEVSQVRPUl0paGlkZShwcm90bywgSVRFUkFUT1IsIEFycmF5VmFsdWVzKTtcbiAgICBpZighcHJvdG9bVE9fU1RSSU5HX1RBR10paGlkZShwcm90bywgVE9fU1RSSU5HX1RBRywgTkFNRSk7XG4gICAgSXRlcmF0b3JzW05BTUVdID0gQXJyYXlWYWx1ZXM7XG4gICAgZm9yKGtleSBpbiAkaXRlcmF0b3JzKWlmKCFwcm90b1trZXldKXJlZGVmaW5lKHByb3RvLCBrZXksICRpdGVyYXRvcnNba2V5XSwgdHJ1ZSk7XG4gIH1cbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDI5M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogaHR0cHM6Ly9yYXcuZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9tYXN0ZXIvTElDRU5TRSBmaWxlLiBBblxuICogYWRkaXRpb25hbCBncmFudCBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluXG4gKiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxuIShmdW5jdGlvbihnbG9iYWwpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG4gIHZhciB1bmRlZmluZWQ7IC8vIE1vcmUgY29tcHJlc3NpYmxlIHRoYW4gdm9pZCAwLlxuICB2YXIgJFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbCA6IHt9O1xuICB2YXIgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiO1xuICB2YXIgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xuXG4gIHZhciBpbk1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCI7XG4gIHZhciBydW50aW1lID0gZ2xvYmFsLnJlZ2VuZXJhdG9yUnVudGltZTtcbiAgaWYgKHJ1bnRpbWUpIHtcbiAgICBpZiAoaW5Nb2R1bGUpIHtcbiAgICAgIC8vIElmIHJlZ2VuZXJhdG9yUnVudGltZSBpcyBkZWZpbmVkIGdsb2JhbGx5IGFuZCB3ZSdyZSBpbiBhIG1vZHVsZSxcbiAgICAgIC8vIG1ha2UgdGhlIGV4cG9ydHMgb2JqZWN0IGlkZW50aWNhbCB0byByZWdlbmVyYXRvclJ1bnRpbWUuXG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IHJ1bnRpbWU7XG4gICAgfVxuICAgIC8vIERvbid0IGJvdGhlciBldmFsdWF0aW5nIHRoZSByZXN0IG9mIHRoaXMgZmlsZSBpZiB0aGUgcnVudGltZSB3YXNcbiAgICAvLyBhbHJlYWR5IGRlZmluZWQgZ2xvYmFsbHkuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRGVmaW5lIHRoZSBydW50aW1lIGdsb2JhbGx5IChhcyBleHBlY3RlZCBieSBnZW5lcmF0ZWQgY29kZSkgYXMgZWl0aGVyXG4gIC8vIG1vZHVsZS5leHBvcnRzIChpZiB3ZSdyZSBpbiBhIG1vZHVsZSkgb3IgYSBuZXcsIGVtcHR5IG9iamVjdC5cbiAgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWUgPSBpbk1vZHVsZSA/IG1vZHVsZS5leHBvcnRzIDoge307XG5cbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIC8vIElmIG91dGVyRm4gcHJvdmlkZWQsIHRoZW4gb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IuXG4gICAgdmFyIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUoKG91dGVyRm4gfHwgR2VuZXJhdG9yKS5wcm90b3R5cGUpO1xuICAgIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pO1xuXG4gICAgLy8gVGhlIC5faW52b2tlIG1ldGhvZCB1bmlmaWVzIHRoZSBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcy5cbiAgICBnZW5lcmF0b3IuX2ludm9rZSA9IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG5cbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICB9XG4gIHJ1bnRpbWUud3JhcCA9IHdyYXA7XG5cbiAgLy8gVHJ5L2NhdGNoIGhlbHBlciB0byBtaW5pbWl6ZSBkZW9wdGltaXphdGlvbnMuIFJldHVybnMgYSBjb21wbGV0aW9uXG4gIC8vIHJlY29yZCBsaWtlIGNvbnRleHQudHJ5RW50cmllc1tpXS5jb21wbGV0aW9uLiBUaGlzIGludGVyZmFjZSBjb3VsZFxuICAvLyBoYXZlIGJlZW4gKGFuZCB3YXMgcHJldmlvdXNseSkgZGVzaWduZWQgdG8gdGFrZSBhIGNsb3N1cmUgdG8gYmVcbiAgLy8gaW52b2tlZCB3aXRob3V0IGFyZ3VtZW50cywgYnV0IGluIGFsbCB0aGUgY2FzZXMgd2UgY2FyZSBhYm91dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYW4gZXhpc3RpbmcgbWV0aG9kIHdlIHdhbnQgdG8gY2FsbCwgc28gdGhlcmUncyBubyBuZWVkXG4gIC8vIHRvIGNyZWF0ZSBhIG5ldyBmdW5jdGlvbiBvYmplY3QuIFdlIGNhbiBldmVuIGdldCBhd2F5IHdpdGggYXNzdW1pbmdcbiAgLy8gdGhlIG1ldGhvZCB0YWtlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgc2luY2UgdGhhdCBoYXBwZW5zIHRvIGJlIHRydWVcbiAgLy8gaW4gZXZlcnkgY2FzZSwgc28gd2UgZG9uJ3QgaGF2ZSB0byB0b3VjaCB0aGUgYXJndW1lbnRzIG9iamVjdC4gVGhlXG4gIC8vIG9ubHkgYWRkaXRpb25hbCBhbGxvY2F0aW9uIHJlcXVpcmVkIGlzIHRoZSBjb21wbGV0aW9uIHJlY29yZCwgd2hpY2hcbiAgLy8gaGFzIGEgc3RhYmxlIHNoYXBlIGFuZCBzbyBob3BlZnVsbHkgc2hvdWxkIGJlIGNoZWFwIHRvIGFsbG9jYXRlLlxuICBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJub3JtYWxcIiwgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKSB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IGVyciB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0ID0gXCJzdXNwZW5kZWRTdGFydFwiO1xuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCA9IFwic3VzcGVuZGVkWWllbGRcIjtcbiAgdmFyIEdlblN0YXRlRXhlY3V0aW5nID0gXCJleGVjdXRpbmdcIjtcbiAgdmFyIEdlblN0YXRlQ29tcGxldGVkID0gXCJjb21wbGV0ZWRcIjtcblxuICAvLyBSZXR1cm5pbmcgdGhpcyBvYmplY3QgZnJvbSB0aGUgaW5uZXJGbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzXG4gIC8vIGJyZWFraW5nIG91dCBvZiB0aGUgZGlzcGF0Y2ggc3dpdGNoIHN0YXRlbWVudC5cbiAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTtcblxuICAvLyBEdW1teSBjb25zdHJ1Y3RvciBmdW5jdGlvbnMgdGhhdCB3ZSB1c2UgYXMgdGhlIC5jb25zdHJ1Y3RvciBhbmRcbiAgLy8gLmNvbnN0cnVjdG9yLnByb3RvdHlwZSBwcm9wZXJ0aWVzIGZvciBmdW5jdGlvbnMgdGhhdCByZXR1cm4gR2VuZXJhdG9yXG4gIC8vIG9iamVjdHMuIEZvciBmdWxsIHNwZWMgY29tcGxpYW5jZSwgeW91IG1heSB3aXNoIHRvIGNvbmZpZ3VyZSB5b3VyXG4gIC8vIG1pbmlmaWVyIG5vdCB0byBtYW5nbGUgdGhlIG5hbWVzIG9mIHRoZXNlIHR3byBmdW5jdGlvbnMuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fVxuXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9IEdlbmVyYXRvci5wcm90b3R5cGU7XG4gIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdwLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb247XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlW3RvU3RyaW5nVGFnU3ltYm9sXSA9IEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuXG4gIC8vIEhlbHBlciBmb3IgZGVmaW5pbmcgdGhlIC5uZXh0LCAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMgb2YgdGhlXG4gIC8vIEl0ZXJhdG9yIGludGVyZmFjZSBpbiB0ZXJtcyBvZiBhIHNpbmdsZSAuX2ludm9rZSBtZXRob2QuXG4gIGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHtcbiAgICBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgIHByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIHJ1bnRpbWUuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXCJmdW5jdGlvblwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gY3RvclxuICAgICAgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxuICAgICAgICAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXG4gICAgICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS5cbiAgICAgICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICAgICA6IGZhbHNlO1xuICB9O1xuXG4gIHJ1bnRpbWUubWFyayA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICAgICAgaWYgKCEodG9TdHJpbmdUYWdTeW1ib2wgaW4gZ2VuRnVuKSkge1xuICAgICAgICBnZW5GdW5bdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuICAgICAgfVxuICAgIH1cbiAgICBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCk7XG4gICAgcmV0dXJuIGdlbkZ1bjtcbiAgfTtcblxuICAvLyBXaXRoaW4gdGhlIGJvZHkgb2YgYW55IGFzeW5jIGZ1bmN0aW9uLCBgYXdhaXQgeGAgaXMgdHJhbnNmb3JtZWQgdG9cbiAgLy8gYHlpZWxkIHJlZ2VuZXJhdG9yUnVudGltZS5hd3JhcCh4KWAsIHNvIHRoYXQgdGhlIHJ1bnRpbWUgY2FuIHRlc3RcbiAgLy8gYHZhbHVlIGluc3RhbmNlb2YgQXdhaXRBcmd1bWVudGAgdG8gZGV0ZXJtaW5lIGlmIHRoZSB5aWVsZGVkIHZhbHVlIGlzXG4gIC8vIG1lYW50IHRvIGJlIGF3YWl0ZWQuIFNvbWUgbWF5IGNvbnNpZGVyIHRoZSBuYW1lIG9mIHRoaXMgbWV0aG9kIHRvb1xuICAvLyBjdXRlc3ksIGJ1dCB0aGV5IGFyZSBjdXJtdWRnZW9ucy5cbiAgcnVudGltZS5hd3JhcCA9IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBuZXcgQXdhaXRBcmd1bWVudChhcmcpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIEF3YWl0QXJndW1lbnQoYXJnKSB7XG4gICAgdGhpcy5hcmcgPSBhcmc7XG4gIH1cblxuICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHJlamVjdChyZWNvcmQuYXJnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWNvcmQuYXJnO1xuICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEF3YWl0QXJndW1lbnQpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlLmFyZykudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGludm9rZShcInRocm93XCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24odW53cmFwcGVkKSB7XG4gICAgICAgICAgLy8gV2hlbiBhIHlpZWxkZWQgUHJvbWlzZSBpcyByZXNvbHZlZCwgaXRzIGZpbmFsIHZhbHVlIGJlY29tZXNcbiAgICAgICAgICAvLyB0aGUgLnZhbHVlIG9mIHRoZSBQcm9taXNlPHt2YWx1ZSxkb25lfT4gcmVzdWx0IGZvciB0aGVcbiAgICAgICAgICAvLyBjdXJyZW50IGl0ZXJhdGlvbi4gSWYgdGhlIFByb21pc2UgaXMgcmVqZWN0ZWQsIGhvd2V2ZXIsIHRoZVxuICAgICAgICAgIC8vIHJlc3VsdCBmb3IgdGhpcyBpdGVyYXRpb24gd2lsbCBiZSByZWplY3RlZCB3aXRoIHRoZSBzYW1lXG4gICAgICAgICAgLy8gcmVhc29uLiBOb3RlIHRoYXQgcmVqZWN0aW9ucyBvZiB5aWVsZGVkIFByb21pc2VzIGFyZSBub3RcbiAgICAgICAgICAvLyB0aHJvd24gYmFjayBpbnRvIHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24sIGFzIGlzIHRoZSBjYXNlXG4gICAgICAgICAgLy8gd2hlbiBhbiBhd2FpdGVkIFByb21pc2UgaXMgcmVqZWN0ZWQuIFRoaXMgZGlmZmVyZW5jZSBpblxuICAgICAgICAgIC8vIGJlaGF2aW9yIGJldHdlZW4geWllbGQgYW5kIGF3YWl0IGlzIGltcG9ydGFudCwgYmVjYXVzZSBpdFxuICAgICAgICAgIC8vIGFsbG93cyB0aGUgY29uc3VtZXIgdG8gZGVjaWRlIHdoYXQgdG8gZG8gd2l0aCB0aGUgeWllbGRlZFxuICAgICAgICAgIC8vIHJlamVjdGlvbiAoc3dhbGxvdyBpdCBhbmQgY29udGludWUsIG1hbnVhbGx5IC50aHJvdyBpdCBiYWNrXG4gICAgICAgICAgLy8gaW50byB0aGUgZ2VuZXJhdG9yLCBhYmFuZG9uIGl0ZXJhdGlvbiwgd2hhdGV2ZXIpLiBXaXRoXG4gICAgICAgICAgLy8gYXdhaXQsIGJ5IGNvbnRyYXN0LCB0aGVyZSBpcyBubyBvcHBvcnR1bml0eSB0byBleGFtaW5lIHRoZVxuICAgICAgICAgIC8vIHJlamVjdGlvbiByZWFzb24gb3V0c2lkZSB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uLCBzbyB0aGVcbiAgICAgICAgICAvLyBvbmx5IG9wdGlvbiBpcyB0byB0aHJvdyBpdCBmcm9tIHRoZSBhd2FpdCBleHByZXNzaW9uLCBhbmRcbiAgICAgICAgICAvLyBsZXQgdGhlIGdlbmVyYXRvciBmdW5jdGlvbiBoYW5kbGUgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQ7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9LCByZWplY3QpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJiBwcm9jZXNzLmRvbWFpbikge1xuICAgICAgaW52b2tlID0gcHJvY2Vzcy5kb21haW4uYmluZChpbnZva2UpO1xuICAgIH1cblxuICAgIHZhciBwcmV2aW91c1Byb21pc2U7XG5cbiAgICBmdW5jdGlvbiBlbnF1ZXVlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmV2aW91c1Byb21pc2UgPVxuICAgICAgICAvLyBJZiBlbnF1ZXVlIGhhcyBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byB3YWl0IHVudGlsXG4gICAgICAgIC8vIGFsbCBwcmV2aW91cyBQcm9taXNlcyBoYXZlIGJlZW4gcmVzb2x2ZWQgYmVmb3JlIGNhbGxpbmcgaW52b2tlLFxuICAgICAgICAvLyBzbyB0aGF0IHJlc3VsdHMgYXJlIGFsd2F5cyBkZWxpdmVyZWQgaW4gdGhlIGNvcnJlY3Qgb3JkZXIuIElmXG4gICAgICAgIC8vIGVucXVldWUgaGFzIG5vdCBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gaXQgaXMgaW1wb3J0YW50IHRvXG4gICAgICAgIC8vIGNhbGwgaW52b2tlIGltbWVkaWF0ZWx5LCB3aXRob3V0IHdhaXRpbmcgb24gYSBjYWxsYmFjayB0byBmaXJlLFxuICAgICAgICAvLyBzbyB0aGF0IHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gaGFzIHRoZSBvcHBvcnR1bml0eSB0byBkb1xuICAgICAgICAvLyBhbnkgbmVjZXNzYXJ5IHNldHVwIGluIGEgcHJlZGljdGFibGUgd2F5LiBUaGlzIHByZWRpY3RhYmlsaXR5XG4gICAgICAgIC8vIGlzIHdoeSB0aGUgUHJvbWlzZSBjb25zdHJ1Y3RvciBzeW5jaHJvbm91c2x5IGludm9rZXMgaXRzXG4gICAgICAgIC8vIGV4ZWN1dG9yIGNhbGxiYWNrLCBhbmQgd2h5IGFzeW5jIGZ1bmN0aW9ucyBzeW5jaHJvbm91c2x5XG4gICAgICAgIC8vIGV4ZWN1dGUgY29kZSBiZWZvcmUgdGhlIGZpcnN0IGF3YWl0LiBTaW5jZSB3ZSBpbXBsZW1lbnQgc2ltcGxlXG4gICAgICAgIC8vIGFzeW5jIGZ1bmN0aW9ucyBpbiB0ZXJtcyBvZiBhc3luYyBnZW5lcmF0b3JzLCBpdCBpcyBlc3BlY2lhbGx5XG4gICAgICAgIC8vIGltcG9ydGFudCB0byBnZXQgdGhpcyByaWdodCwgZXZlbiB0aG91Z2ggaXQgcmVxdWlyZXMgY2FyZS5cbiAgICAgICAgcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcsXG4gICAgICAgICAgLy8gQXZvaWQgcHJvcGFnYXRpbmcgZmFpbHVyZXMgdG8gUHJvbWlzZXMgcmV0dXJuZWQgYnkgbGF0ZXJcbiAgICAgICAgICAvLyBpbnZvY2F0aW9ucyBvZiB0aGUgaXRlcmF0b3IuXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmdcbiAgICAgICAgKSA6IGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCk7XG4gICAgfVxuXG4gICAgLy8gRGVmaW5lIHRoZSB1bmlmaWVkIGhlbHBlciBtZXRob2QgdGhhdCBpcyB1c2VkIHRvIGltcGxlbWVudCAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIChzZWUgZGVmaW5lSXRlcmF0b3JNZXRob2RzKS5cbiAgICB0aGlzLl9pbnZva2UgPSBlbnF1ZXVlO1xuICB9XG5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKTtcblxuICAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXG4gIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxuICAvLyB0aGUgZmluYWwgcmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBpdGVyYXRvci5cbiAgcnVudGltZS5hc3luYyA9IGZ1bmN0aW9uKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcihcbiAgICAgIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpXG4gICAgKTtcblxuICAgIHJldHVybiBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbilcbiAgICAgID8gaXRlciAvLyBJZiBvdXRlckZuIGlzIGEgZ2VuZXJhdG9yLCByZXR1cm4gdGhlIGZ1bGwgaXRlcmF0b3IuXG4gICAgICA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkge1xuICAgIHZhciBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVDb21wbGV0ZWQpIHtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmUgZm9yZ2l2aW5nLCBwZXIgMjUuMy4zLjMuMyBvZiB0aGUgc3BlYzpcbiAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZVxuICAgICAgICByZXR1cm4gZG9uZVJlc3VsdCgpO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlO1xuICAgICAgICBpZiAoZGVsZWdhdGUpIHtcbiAgICAgICAgICBpZiAobWV0aG9kID09PSBcInJldHVyblwiIHx8XG4gICAgICAgICAgICAgIChtZXRob2QgPT09IFwidGhyb3dcIiAmJiBkZWxlZ2F0ZS5pdGVyYXRvclttZXRob2RdID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICAvLyBBIHJldHVybiBvciB0aHJvdyAod2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIHRocm93XG4gICAgICAgICAgICAvLyBtZXRob2QpIGFsd2F5cyB0ZXJtaW5hdGVzIHRoZSB5aWVsZCogbG9vcC5cbiAgICAgICAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICAgICAgICAvLyBJZiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIGEgcmV0dXJuIG1ldGhvZCwgZ2l2ZSBpdCBhXG4gICAgICAgICAgICAvLyBjaGFuY2UgdG8gY2xlYW4gdXAuXG4gICAgICAgICAgICB2YXIgcmV0dXJuTWV0aG9kID0gZGVsZWdhdGUuaXRlcmF0b3JbXCJyZXR1cm5cIl07XG4gICAgICAgICAgICBpZiAocmV0dXJuTWV0aG9kKSB7XG4gICAgICAgICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChyZXR1cm5NZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBhcmcpO1xuICAgICAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSByZXR1cm4gbWV0aG9kIHRocmV3IGFuIGV4Y2VwdGlvbiwgbGV0IHRoYXRcbiAgICAgICAgICAgICAgICAvLyBleGNlcHRpb24gcHJldmFpbCBvdmVyIHRoZSBvcmlnaW5hbCByZXR1cm4gb3IgdGhyb3cuXG4gICAgICAgICAgICAgICAgbWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgICAgICAgIGFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgICAgICAvLyBDb250aW51ZSB3aXRoIHRoZSBvdXRlciByZXR1cm4sIG5vdyB0aGF0IHRoZSBkZWxlZ2F0ZVxuICAgICAgICAgICAgICAvLyBpdGVyYXRvciBoYXMgYmVlbiB0ZXJtaW5hdGVkLlxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goXG4gICAgICAgICAgICBkZWxlZ2F0ZS5pdGVyYXRvclttZXRob2RdLFxuICAgICAgICAgICAgZGVsZWdhdGUuaXRlcmF0b3IsXG4gICAgICAgICAgICBhcmdcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICAgICAgICAvLyBMaWtlIHJldHVybmluZyBnZW5lcmF0b3IudGhyb3codW5jYXVnaHQpLCBidXQgd2l0aG91dCB0aGVcbiAgICAgICAgICAgIC8vIG92ZXJoZWFkIG9mIGFuIGV4dHJhIGZ1bmN0aW9uIGNhbGwuXG4gICAgICAgICAgICBtZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgICBhcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gRGVsZWdhdGUgZ2VuZXJhdG9yIHJhbiBhbmQgaGFuZGxlZCBpdHMgb3duIGV4Y2VwdGlvbnMgc29cbiAgICAgICAgICAvLyByZWdhcmRsZXNzIG9mIHdoYXQgdGhlIG1ldGhvZCB3YXMsIHdlIGNvbnRpbnVlIGFzIGlmIGl0IGlzXG4gICAgICAgICAgLy8gXCJuZXh0XCIgd2l0aCBhbiB1bmRlZmluZWQgYXJnLlxuICAgICAgICAgIG1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgIGFyZyA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcbiAgICAgICAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICAgICAgICBjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZTtcbiAgICAgICAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcbiAgICAgICAgICAgIHJldHVybiBpbmZvO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAvLyBTZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgICAgIGNvbnRleHQuc2VudCA9IGNvbnRleHQuX3NlbnQgPSBhcmc7XG5cbiAgICAgICAgfSBlbHNlIGlmIChtZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCkge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihhcmcpKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxuICAgICAgICAgICAgLy8gdGhlbiBsZXQgdGhhdCBjYXRjaCBibG9jayBoYW5kbGUgdGhlIGV4Y2VwdGlvbiBub3JtYWxseS5cbiAgICAgICAgICAgIG1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgICAgYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgaWYgKG1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGFyZyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nO1xuXG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgLy8gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBmcm9tIGlubmVyRm4sIHdlIGxlYXZlIHN0YXRlID09PVxuICAgICAgICAgIC8vIEdlblN0YXRlRXhlY3V0aW5nIGFuZCBsb29wIGJhY2sgZm9yIGFub3RoZXIgaW52b2NhdGlvbi5cbiAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZVxuICAgICAgICAgICAgPyBHZW5TdGF0ZUNvbXBsZXRlZFxuICAgICAgICAgICAgOiBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuXG4gICAgICAgICAgdmFyIGluZm8gPSB7XG4gICAgICAgICAgICB2YWx1ZTogcmVjb3JkLmFyZyxcbiAgICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAocmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkge1xuICAgICAgICAgICAgaWYgKGNvbnRleHQuZGVsZWdhdGUgJiYgbWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgICAgICAvLyBEZWxpYmVyYXRlbHkgZm9yZ2V0IHRoZSBsYXN0IHNlbnQgdmFsdWUgc28gdGhhdCB3ZSBkb24ndFxuICAgICAgICAgICAgICAvLyBhY2NpZGVudGFsbHkgcGFzcyBpdCBvbiB0byB0aGUgZGVsZWdhdGUuXG4gICAgICAgICAgICAgIGFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGluZm87XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgLy8gRGlzcGF0Y2ggdGhlIGV4Y2VwdGlvbiBieSBsb29waW5nIGJhY2sgYXJvdW5kIHRvIHRoZVxuICAgICAgICAgIC8vIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oYXJnKSBjYWxsIGFib3ZlLlxuICAgICAgICAgIG1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICBhcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIERlZmluZSBHZW5lcmF0b3IucHJvdG90eXBlLntuZXh0LHRocm93LHJldHVybn0gaW4gdGVybXMgb2YgdGhlXG4gIC8vIHVuaWZpZWQgLl9pbnZva2UgaGVscGVyIG1ldGhvZC5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEdwKTtcblxuICBHcFtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBHcFt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcIkdlbmVyYXRvclwiO1xuXG4gIEdwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XG4gIH07XG5cbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcbiAgICB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9O1xuXG4gICAgaWYgKDEgaW4gbG9jcykge1xuICAgICAgZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdO1xuICAgIH1cblxuICAgIGlmICgyIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xuICAgICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdO1xuICAgIH1cblxuICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcbiAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcbiAgICByZWNvcmQudHlwZSA9IFwibm9ybWFsXCI7XG4gICAgZGVsZXRlIHJlY29yZC5hcmc7XG4gICAgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBUaGUgcm9vdCBlbnRyeSBvYmplY3QgKGVmZmVjdGl2ZWx5IGEgdHJ5IHN0YXRlbWVudCB3aXRob3V0IGEgY2F0Y2hcbiAgICAvLyBvciBhIGZpbmFsbHkgYmxvY2spIGdpdmVzIHVzIGEgcGxhY2UgdG8gc3RvcmUgdmFsdWVzIHRocm93biBmcm9tXG4gICAgLy8gbG9jYXRpb25zIHdoZXJlIHRoZXJlIGlzIG5vIGVuY2xvc2luZyB0cnkgc3RhdGVtZW50LlxuICAgIHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXCJyb290XCIgfV07XG4gICAgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpO1xuICAgIHRoaXMucmVzZXQodHJ1ZSk7XG4gIH1cblxuICBydW50aW1lLmtleXMgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICBrZXlzLnJldmVyc2UoKTtcblxuICAgIC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXG4gICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcbiAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLCBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7XG4gICAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHQudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcblxuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiBhbiBpdGVyYXRvciB3aXRoIG5vIHZhbHVlcy5cbiAgICByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07XG4gIH1cbiAgcnVudGltZS52YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH1cblxuICBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcblxuICAgIHJlc2V0OiBmdW5jdGlvbihza2lwVGVtcFJlc2V0KSB7XG4gICAgICB0aGlzLnByZXYgPSAwO1xuICAgICAgdGhpcy5uZXh0ID0gMDtcbiAgICAgIC8vIFJlc2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpO1xuXG4gICAgICBpZiAoIXNraXBUZW1wUmVzZXQpIHtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSB7XG4gICAgICAgICAgLy8gTm90IHN1cmUgYWJvdXQgdGhlIG9wdGltYWwgb3JkZXIgb2YgdGhlc2UgY29uZGl0aW9uczpcbiAgICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09IFwidFwiICYmXG4gICAgICAgICAgICAgIGhhc093bi5jYWxsKHRoaXMsIG5hbWUpICYmXG4gICAgICAgICAgICAgICFpc05hTigrbmFtZS5zbGljZSgxKSkpIHtcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcblxuICAgICAgdmFyIHJvb3RFbnRyeSA9IHRoaXMudHJ5RW50cmllc1swXTtcbiAgICAgIHZhciByb290UmVjb3JkID0gcm9vdEVudHJ5LmNvbXBsZXRpb247XG4gICAgICBpZiAocm9vdFJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcm9vdFJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJ2YWw7XG4gICAgfSxcblxuICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbihleGNlcHRpb24pIHtcbiAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcbiAgICAgICAgcmVjb3JkLnR5cGUgPSBcInRocm93XCI7XG4gICAgICAgIHJlY29yZC5hcmcgPSBleGNlcHRpb247XG4gICAgICAgIGNvbnRleHQubmV4dCA9IGxvYztcbiAgICAgICAgcmV0dXJuICEhY2F1Z2h0O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgICAvLyBFeGNlcHRpb24gdGhyb3duIG91dHNpZGUgb2YgYW55IHRyeSBibG9jayB0aGF0IGNvdWxkIGhhbmRsZVxuICAgICAgICAgIC8vIGl0LCBzbyBzZXQgdGhlIGNvbXBsZXRpb24gdmFsdWUgb2YgdGhlIGVudGlyZSBmdW5jdGlvbiB0b1xuICAgICAgICAgIC8vIHRocm93IHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmV0dXJuIGhhbmRsZShcImVuZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7XG4gICAgICAgICAgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIik7XG4gICAgICAgICAgdmFyIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpO1xuXG4gICAgICAgICAgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNDYXRjaCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhYnJ1cHQ6IGZ1bmN0aW9uKHR5cGUsIGFyZykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmXG4gICAgICAgICAgICB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkgJiZcbiAgICAgICAgICAodHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgIHR5cGUgPT09IFwiY29udGludWVcIikgJiZcbiAgICAgICAgICBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJlxuICAgICAgICAgIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAvLyBJZ25vcmUgdGhlIGZpbmFsbHkgZW50cnkgaWYgY29udHJvbCBpcyBub3QganVtcGluZyB0byBhXG4gICAgICAgIC8vIGxvY2F0aW9uIG91dHNpZGUgdGhlIHRyeS9jYXRjaCBibG9jay5cbiAgICAgICAgZmluYWxseUVudHJ5ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307XG4gICAgICByZWNvcmQudHlwZSA9IHR5cGU7XG4gICAgICByZWNvcmQuYXJnID0gYXJnO1xuXG4gICAgICBpZiAoZmluYWxseUVudHJ5KSB7XG4gICAgICAgIHRoaXMubmV4dCA9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9LFxuXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uKHJlY29yZCwgYWZ0ZXJMb2MpIHtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgcmVjb3JkLnR5cGUgPT09IFwiY29udGludWVcIikge1xuICAgICAgICB0aGlzLm5leHQgPSByZWNvcmQuYXJnO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICB0aGlzLnJ2YWwgPSByZWNvcmQuYXJnO1xuICAgICAgICB0aGlzLm5leHQgPSBcImVuZFwiO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIiAmJiBhZnRlckxvYykge1xuICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZmluaXNoOiBmdW5jdGlvbihmaW5hbGx5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LmZpbmFsbHlMb2MgPT09IGZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB0aGlzLmNvbXBsZXRlKGVudHJ5LmNvbXBsZXRpb24sIGVudHJ5LmFmdGVyTG9jKTtcbiAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBcImNhdGNoXCI6IGZ1bmN0aW9uKHRyeUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IHRyeUxvYykge1xuICAgICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICB2YXIgdGhyb3duID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhyb3duO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBjb250ZXh0LmNhdGNoIG1ldGhvZCBtdXN0IG9ubHkgYmUgY2FsbGVkIHdpdGggYSBsb2NhdGlvblxuICAgICAgLy8gYXJndW1lbnQgdGhhdCBjb3JyZXNwb25kcyB0byBhIGtub3duIGNhdGNoIGJsb2NrLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpO1xuICAgIH0sXG5cbiAgICBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbihpdGVyYWJsZSwgcmVzdWx0TmFtZSwgbmV4dExvYykge1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IHtcbiAgICAgICAgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksXG4gICAgICAgIHJlc3VsdE5hbWU6IHJlc3VsdE5hbWUsXG4gICAgICAgIG5leHRMb2M6IG5leHRMb2NcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cbiAgfTtcbn0pKFxuICAvLyBBbW9uZyB0aGUgdmFyaW91cyB0cmlja3MgZm9yIG9idGFpbmluZyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsXG4gIC8vIG9iamVjdCwgdGhpcyBzZWVtcyB0byBiZSB0aGUgbW9zdCByZWxpYWJsZSB0ZWNobmlxdWUgdGhhdCBkb2VzIG5vdFxuICAvLyB1c2UgaW5kaXJlY3QgZXZhbCAod2hpY2ggdmlvbGF0ZXMgQ29udGVudCBTZWN1cml0eSBQb2xpY3kpLlxuICB0eXBlb2YgZ2xvYmFsID09PSBcIm9iamVjdFwiID8gZ2xvYmFsIDpcbiAgdHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIiA/IHdpbmRvdyA6XG4gIHR5cGVvZiBzZWxmID09PSBcIm9iamVjdFwiID8gc2VsZiA6IHRoaXNcbik7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanNcbiAqKiBtb2R1bGUgaWQgPSAyOTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBzZXRUaW1lb3V0KGRyYWluUXVldWUsIDApO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vbm9kZS1saWJzLWJyb3dzZXIvfi9wcm9jZXNzL2Jyb3dzZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAyOTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvY29yZS5yZWdleHAuZXNjYXBlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5SZWdFeHAuZXNjYXBlO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvZm4vcmVnZXhwL2VzY2FwZS5qc1xuICoqIG1vZHVsZSBpZCA9IDI5NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL2JlbmphbWluZ3IvUmV4RXhwLmVzY2FwZVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRyZSAgICAgPSByZXF1aXJlKCcuL19yZXBsYWNlcicpKC9bXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZ0V4cCcsIHtlc2NhcGU6IGZ1bmN0aW9uIGVzY2FwZShpdCl7IHJldHVybiAkcmUoaXQpOyB9fSk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvY29yZS5yZWdleHAuZXNjYXBlLmpzXG4gKiogbW9kdWxlIGlkID0gMjk3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHJlZ0V4cCwgcmVwbGFjZSl7XG4gIHZhciByZXBsYWNlciA9IHJlcGxhY2UgPT09IE9iamVjdChyZXBsYWNlKSA/IGZ1bmN0aW9uKHBhcnQpe1xuICAgIHJldHVybiByZXBsYWNlW3BhcnRdO1xuICB9IDogcmVwbGFjZTtcbiAgcmV0dXJuIGZ1bmN0aW9uKGl0KXtcbiAgICByZXR1cm4gU3RyaW5nKGl0KS5yZXBsYWNlKHJlZ0V4cCwgcmVwbGFjZXIpO1xuICB9O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX3JlcGxhY2VyLmpzXG4gKiogbW9kdWxlIGlkID0gMjk4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBTREtfVkVSU0lPTiwgTE9HX0xFVkVMIGluamVjdGVkIGZyb20gd2VicGFjayBidWlsZC5cblxuaW1wb3J0IHsgTEVWRUxTLCBlc3RhYmxpc2hMb2dnZXIsIGdldExvZ2dlciB9IGZyb20gJy4vbG9nJ1xuZXhwb3J0IHsgTEVWRUxTIGFzIExvZ0xldmVscyB9IGZyb20gJy4vbG9nJ1xuZXhwb3J0IHsgZ2V0TG9nZ2VyIGFzIGdldExvZ2dlciB9IGZyb20gJy4vbG9nJ1xuXG5pbXBvcnQgKiBhcyBzdWJzY3JpYmVyTGliIGZyb20gJy4vc3Vic2NyaWJlci9pbmRleCdcbmltcG9ydCAqIGFzIHB1Ymxpc2hlckxpYiBmcm9tICcuL3B1Ymxpc2hlci9pbmRleCdcbmltcG9ydCBQbGF5YmFja1ZpZXcgZnJvbSAnLi92aWV3L3BsYXliYWNrJ1xuaW1wb3J0IFB1Ymxpc2hlclZpZXcgZnJvbSAnLi92aWV3L3B1Ymxpc2gnXG5cbi8qKlxuICogU3Vic2NyaXB0aW9uIHJlbGF0ZWQgcmVmZXJlbmNlcy5cbiovXG5leHBvcnQgY29uc3QgUmVkNVByb1N1YnNjcmliZXIgPSBzdWJzY3JpYmVyTGliLlJlZDVQcm9TdWJzY3JpYmVyXG5leHBvcnQgY29uc3QgUlRDU3Vic2NyaWJlciA9IHN1YnNjcmliZXJMaWIuUlRDU3Vic2NyaWJlclxuZXhwb3J0IGNvbnN0IEhMU1N1YnNjcmliZXIgPSBzdWJzY3JpYmVyTGliLkhMU1N1YnNjcmliZXJcbmV4cG9ydCBjb25zdCBWaWRlb0pTU3Vic2NyaWJlciA9IHN1YnNjcmliZXJMaWIuVmlkZW9KU1N1YnNjcmliZXJcbmV4cG9ydCBjb25zdCBSNUxpdmVTdWJzY3JpYmVyID0gc3Vic2NyaWJlckxpYi5SNUxpdmVTdWJzY3JpYmVyXG5leHBvcnQgY29uc3QgUlRNUFN1YnNjcmliZXIgPSBzdWJzY3JpYmVyTGliLlJUTVBTdWJzY3JpYmVyXG5leHBvcnQgeyBQbGF5YmFja1ZpZXcgfVxuXG4vKipcbiAqIEJyb2FkY2FzdCByZWxhdGVkIHJlZmVyZW5jZXMuXG4gKi9cbmV4cG9ydCBjb25zdCBSZWQ1UHJvUHVibGlzaGVyID0gcHVibGlzaGVyTGliLlJlZDVQcm9QdWJsaXNoZXJcbmV4cG9ydCBjb25zdCBSVE1QUHVibGlzaGVyID0gcHVibGlzaGVyTGliLlJUTVBQdWJsaXNoZXJcbmV4cG9ydCBjb25zdCBSVENQdWJsaXNoZXIgPSBwdWJsaXNoZXJMaWIuUlRDUHVibGlzaGVyXG5leHBvcnQgeyBQdWJsaXNoZXJWaWV3IH1cblxuLyoqXG4gKiBFdmVudHNcbiAqL1xuZXhwb3J0IHsgY29tbW9uIGFzIFB1Ymxpc2hlckV2ZW50VHlwZXMgfSBmcm9tICcuL2V2ZW50L3B1Ymxpc2hlci1ldmVudCdcbmV4cG9ydCB7IHJ0YyBhcyBSVENQdWJsaXNoZXJFdmVudFR5cGVzIH0gZnJvbSAnLi9ldmVudC9wdWJsaXNoZXItZXZlbnQnXG5leHBvcnQgeyBmYWlsb3ZlciBhcyBGYWlsb3ZlclB1Ymxpc2hlckV2ZW50VHlwZXMgfSBmcm9tICcuL2V2ZW50L3B1Ymxpc2hlci1ldmVudCdcbmV4cG9ydCB7IGNvbW1vbiBhcyBTdWJzY3JpYmVyRXZlbnRUeXBlcyB9IGZyb20gJy4vZXZlbnQvc3Vic2NyaWJlci1ldmVudCdcbmV4cG9ydCB7IHJ0YyBhcyBSVENTdWJzY3JpYmVyRXZlbnRUeXBlcyB9IGZyb20gJy4vZXZlbnQvc3Vic2NyaWJlci1ldmVudCdcbmV4cG9ydCB7IGZhaWxvdmVyIGFzIEZhaWxvdmVyU3Vic2NyaWJlckV2ZW50VHlwZXMgfSBmcm9tICcuL2V2ZW50L3N1YnNjcmliZXItZXZlbnQnXG5cbmVzdGFibGlzaExvZ2dlcihgJHtMT0dfTEVWRUx9YCB8fCBMRVZFTFMuREVCVUcpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbmdldExvZ2dlcigpLmRlYnVnKGBSZWQ1IFBybyBTREsgVmVyc2lvbiAke1NES19WRVJTSU9OfWApIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuZXhwb3J0IGNvbnN0IHNldExvZ0xldmVsID0gKGxldmVsKSA9PiB7XG4gIGlmIChMRVZFTFMuaGFzT3duUHJvcGVydHkobGV2ZWwudG9VcHBlckNhc2UoKSkpIHtcbiAgICBlc3RhYmxpc2hMb2dnZXIobGV2ZWwpXG4gIH1cbn1cblxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvanMvaW5kZXguanNcbiAqKi8iLCIndXNlIHN0cmljdCdcblxuaW1wb3J0IHsgY3JlYXRlTG9nZ2VyIH0gZnJvbSAnYnJvd3Nlci1idW55YW4nXG5pbXBvcnQgeyBSYXdTdHJlYW0gfSBmcm9tICcuL2J1bnlhbi13cml0ZXInXG5cbmxldCBsb2dnZXJcbmNvbnN0IGZvcm1hdE1lc3NhZ2UgPSAoZGlzcGF0Y2hlcikgPT4ge1xuICByZXR1cm4gbWVzc2FnZSA9PiB7XG4gICAgcmV0dXJuIGAoJHtkaXNwYXRjaGVyfSkgJHttZXNzYWdlfWBcbiAgfVxufVxuY29uc3QgZGVjb3JhdGUgPSAobGV2ZWwpID0+IHtcbiAgcmV0dXJuIChzb3VyY2UsIG1lc3NhZ2UpID0+IHtcbiAgICBsb2dnZXJbbGV2ZWxdKGZvcm1hdE1lc3NhZ2Uoc291cmNlKShtZXNzYWdlKSlcbiAgfVxufVxuZXhwb3J0IGNvbnN0IExFVkVMUyA9IHtcbiAgVFJBQ0U6ICd0cmFjZScsXG4gIElORk86ICdpbmZvJyxcbiAgREVCVUc6ICdkZWJ1ZycsXG4gIFdBUk46ICd3YXJuJyxcbiAgRVJST1I6ICdlcnJvcicsXG4gIEZBVEFMOiAnZmF0YWwnXG59XG5cblxuZXhwb3J0IGNvbnN0IGVzdGFibGlzaExvZ2dlciA9IChsZXZlbCwgc3RyZWFtTGlzdCA9IHVuZGVmaW5lZCkgPT4ge1xuICBsZXQgc3RyZWFtcyA9IFtdXG4gIHN0cmVhbXMucHVzaCh7XG4gICAgbGV2ZWw6IGxldmVsLFxuICAgIHN0cmVhbTogbmV3IFJhd1N0cmVhbSgpLFxuICAgIHR5cGU6ICdyYXcnXG4gIH0pXG4gIGlmIChzdHJlYW1MaXN0KSB7XG4gICAgY29uc3QgbGlzdCA9IHN0cmVhbUxpc3QubWFwKGl0ZW0gPT4ge1xuICAgICAgaXRlbS5sZXZlbCA9IGxldmVsXG4gICAgfSlcbiAgICBzdHJlYW1zID0gc3RyZWFtcy5jb25jYXQobGlzdClcbiAgfVxuICBsb2dnZXIgPSBjcmVhdGVMb2dnZXIoe1xuICAgIGxldmVsOiBsZXZlbCxcbiAgICBuYW1lOiAncmVkNXByby1zZGsnLFxuICAgIHN0cmVhbXM6IHN0cmVhbXNcbiAgfSlcbn1cblxuZXhwb3J0IGNvbnN0IGdldExvZ2dlciA9ICgpID0+IHtcbiAgcmV0dXJuIGxvZ2dlclxufVxuXG5leHBvcnQgY29uc3QgdHJhY2UgPSBkZWNvcmF0ZShMRVZFTFMuVFJBQ0UpXG5leHBvcnQgY29uc3QgaW5mbyA9IGRlY29yYXRlKExFVkVMUy5JTkZPKVxuZXhwb3J0IGNvbnN0IGRlYnVnID0gZGVjb3JhdGUoTEVWRUxTLkRFQlVHKVxuZXhwb3J0IGNvbnN0IHdhcm4gPSBkZWNvcmF0ZShMRVZFTFMuV0FSTilcbmV4cG9ydCBjb25zdCBlcnJvciA9IGRlY29yYXRlKExFVkVMUy5FUlJPUilcbmV4cG9ydCBjb25zdCBmYXRhbCA9IGRlY29yYXRlKExFVkVMUy5GQVRBTClcblxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvanMvbG9nL2luZGV4LmpzXG4gKiovIiwiLyoqXG4gKiAhVGhpcyBpcyBhIHN0cmlwcGVkIGRvd24gdmVyc2lvbiBvZiBCdW55YW4gdGFyZ2V0ZWQgc3BlY2lmaWNhbGx5IGZvciB0aGUgYnJvd3NlclxuICpcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQgVHJlbnQgTWljay4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIENvcHlyaWdodCAoYykgMjAxNCBKb3llbnQgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoZSBidW55YW4gbG9nZ2luZyBsaWJyYXJ5IGZvciBub2RlLmpzLlxuICpcbiAqIC0qLSBtb2RlOiBqcyAtKi1cbiAqIHZpbTogZXhwYW5kdGFiOnRzPTQ6c3c9NFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFZFUlNJT04gPSAnMC4yLjMnO1xuXG4vLyBCdW55YW4gbG9nIGZvcm1hdCB2ZXJzaW9uLiBUaGlzIGJlY29tZXMgdGhlICd2JyBmaWVsZCBvbiBhbGwgbG9nIHJlY29yZHMuXG4vLyBgMGAgaXMgdW50aWwgSSByZWxlYXNlIGEgdmVyc2lvbiAnMS4wLjAnIG9mIG5vZGUtYnVueWFuLiBUaGVyZWFmdGVyLFxuLy8gc3RhcnRpbmcgd2l0aCBgMWAsIHRoaXMgd2lsbCBiZSBpbmNyZW1lbnRlZCBpZiB0aGVyZSBpcyBhbnkgYmFja3dhcmRcbi8vIGluY29tcGF0aWJsZSBjaGFuZ2UgdG8gdGhlIGxvZyByZWNvcmQgZm9ybWF0LiBEZXRhaWxzIHdpbGwgYmUgaW5cbi8vICdDSEFOR0VTLm1kJyAodGhlIGNoYW5nZSBsb2cpLlxudmFyIExPR19WRVJTSU9OID0gMDtcblxuLy8tLS0tIEludGVybmFsIHN1cHBvcnQgc3R1ZmZcblxuLyoqXG4gKiBBIHNoYWxsb3cgY29weSBvZiBhbiBvYmplY3QuIEJ1bnlhbiBsb2dnaW5nIGF0dGVtcHRzIHRvIG5ldmVyIGNhdXNlXG4gKiBleGNlcHRpb25zLCBzbyB0aGlzIGZ1bmN0aW9uIGF0dGVtcHRzIHRvIGhhbmRsZSBub24tb2JqZWN0cyBncmFjZWZ1bGx5LlxuICovXG5mdW5jdGlvbiBvYmpDb3B5KG9iaikge1xuICAgIGlmICh0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJyB8fCBvYmogPT09IG51bGwpIHsgIC8vIG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgcmV0dXJuIG9iai5zbGljZSgpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIChvYmopID09PSAnb2JqZWN0Jykge1xuICAgICAgICB2YXIgY29weSA9IHt9O1xuICAgICAgICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIGNvcHlba10gPSBvYmpba107XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbn1cblxudmFyIGZvcm1hdCA9IGZ1bmN0aW9uKGYpIHtcblxuICAgIGlmKGYgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICdudWxsJztcbiAgICB9XG5cbiAgICBpZih0eXBlb2YgZiAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGYudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgdmFyIGZvcm1hdFJlZ0V4cCA9IC8lW3NkaiVdL2c7XG5cbiAgICB2YXIgaSA9IDE7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICAgIHZhciBzdHIgPSBTdHJpbmcoZikucmVwbGFjZShmb3JtYXRSZWdFeHAsIGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgaWYgKHggPT09ICclJScpIHtcbiAgICAgICAgICAgIHJldHVybiAnJSc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPj0gbGVuKSB7XG4gICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHgpIHtcbiAgICAgICAgICAgIGNhc2UgJyVzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xuICAgICAgICAgICAgY2FzZSAnJWQnOiByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7XG4gICAgICAgICAgICBjYXNlICclaic6XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3NbaSsrXSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBmb3IgKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSkge1xuICAgICAgICBzdHIgKz0gJyAnICsgeDtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbn07XG5cbi8qKlxuICogR2F0aGVyIHNvbWUgY2FsbGVyIGluZm8gMyBzdGFjayBsZXZlbHMgdXAuXG4gKiBTZWUgPGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC93aWtpL0phdmFTY3JpcHRTdGFja1RyYWNlQXBpPi5cbiAqL1xuZnVuY3Rpb24gZ2V0Q2FsbGVyM0luZm8oKSB7XG4gICAgdmFyIG9iaiA9IHt9O1xuICAgIHZhciBzYXZlTGltaXQgPSBFcnJvci5zdGFja1RyYWNlTGltaXQ7XG4gICAgdmFyIHNhdmVQcmVwYXJlID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7XG4gICAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID0gMztcbiAgICAvL0Vycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIGdldENhbGxlcjNJbmZvKTtcblxuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gZnVuY3Rpb24gKF8sIHN0YWNrKSB7XG4gICAgICAgIHZhciBjYWxsZXIgPSBzdGFja1syXTtcbiAgICAgICAgb2JqLmZpbGUgPSBjYWxsZXIuZ2V0RmlsZU5hbWUoKTtcbiAgICAgICAgb2JqLmxpbmUgPSBjYWxsZXIuZ2V0TGluZU51bWJlcigpO1xuICAgICAgICB2YXIgZnVuYyA9IGNhbGxlci5nZXRGdW5jdGlvbk5hbWUoKTtcbiAgICAgICAgaWYgKGZ1bmMpIHtcbiAgICAgICAgICAgIG9iai5mdW5jID0gZnVuYztcbiAgICAgICAgfVxuICAgIH07XG4gICAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID0gc2F2ZUxpbWl0O1xuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gc2F2ZVByZXBhcmU7XG4gICAgcmV0dXJuIG9iajtcbn1cblxuXG5mdW5jdGlvbiBfaW5kZW50KHMsIGluZGVudCkge1xuICAgIGlmICghaW5kZW50KSB7XG4gICAgICAgIGluZGVudCA9ICcgICAgJztcbiAgICB9XG4gICAgdmFyIGxpbmVzID0gcy5zcGxpdCgvXFxyP1xcbi9nKTtcbiAgICByZXR1cm4gaW5kZW50ICsgbGluZXMuam9pbignXFxuJyArIGluZGVudCk7XG59XG5cblxuLyoqXG4gKiBXYXJuIGFib3V0IGFuIGJ1bnlhbiBwcm9jZXNzaW5nIGVycm9yLlxuICpcbiAqIEBwYXJhbSBtc2cge1N0cmluZ30gTWVzc2FnZSB3aXRoIHdoaWNoIHRvIHdhcm4uXG4gKiBAcGFyYW0gZGVkdXBLZXkge1N0cmluZ30gT3B0aW9uYWwuIEEgc2hvcnQgc3RyaW5nIGtleSBmb3IgdGhpcyB3YXJuaW5nIHRvXG4gKiAgICAgIGhhdmUgaXRzIHdhcm5pbmcgb25seSBwcmludGVkIG9uY2UuXG4gKi9cbmZ1bmN0aW9uIF93YXJuKG1zZywgZGVkdXBLZXkpIHtcbiAgICBpZiAoZGVkdXBLZXkpIHtcbiAgICAgICAgaWYgKF93YXJuZWRbZGVkdXBLZXldKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgX3dhcm5lZFtkZWR1cEtleV0gPSB0cnVlO1xuICAgIH1cbiAgICBjb25zb2xlLmVycm9yKG1zZyArICdcXG4nKTtcbn1cbmZ1bmN0aW9uIF9oYXZlV2FybmVkKGRlZHVwS2V5KSB7XG4gICAgcmV0dXJuIF93YXJuZWRbZGVkdXBLZXldO1xufVxudmFyIF93YXJuZWQgPSB7fTtcblxuXG5mdW5jdGlvbiBDb25zb2xlUmF3U3RyZWFtKCkge1xufVxuQ29uc29sZVJhd1N0cmVhbS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAocmVjKSB7XG4gICAgaWYgKHJlYy5sZXZlbCA8IElORk8pIHtcbiAgICAgICAgY29uc29sZS5sb2cocmVjKTtcbiAgICB9IGVsc2UgaWYgKHJlYy5sZXZlbCA8IFdBUk4pIHtcbiAgICAgICAgY29uc29sZS5pbmZvKHJlYyk7XG4gICAgfSBlbHNlIGlmIChyZWMubGV2ZWwgPCBFUlJPUikge1xuICAgICAgICBjb25zb2xlLndhcm4ocmVjKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKHJlYyk7XG4gICAgfVxuXG4gICAgaWYocmVjLmVyciAmJiByZWMuZXJyLnN0YWNrKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IocmVjLmVyci5zdGFjayk7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gQ29uc29sZUZvcm1hdHRlZFN0cmVhbSgpIHt9XG5Db25zb2xlRm9ybWF0dGVkU3RyZWFtLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChyZWMpIHtcblxuICAgIHZhciBsZXZlbENzcywgZGVmYXVsdENzcyA9ICdjb2xvcjogRGltR3JheScsIG1zZ0NzcyA9ICdjb2xvcjogU3RlZWxCbHVlJztcblxuICAgIGlmIChyZWMubGV2ZWwgPCBERUJVRykge1xuICAgICAgICBsZXZlbENzcyA9ICdjb2xvcjogRGVlcFBpbmsnO1xuICAgIH0gZWxzZSBpZiAocmVjLmxldmVsIDwgSU5GTykge1xuICAgICAgICBsZXZlbENzcyA9ICdjb2xvcjogR29sZGVuUm9kJztcbiAgICB9IGVsc2UgaWYgKHJlYy5sZXZlbCA8IFdBUk4pIHtcbiAgICAgICAgbGV2ZWxDc3MgPSAnY29sb3I6IERhcmtUdXJxdW9pc2UnO1xuICAgIH0gZWxzZSBpZiAocmVjLmxldmVsIDwgRVJST1IpIHtcbiAgICAgICAgbGV2ZWxDc3MgPSAnY29sb3I6IFB1cnBsZSc7XG4gICAgfSBlbHNlIGlmIChyZWMubGV2ZWwgPCBGQVRBTCkge1xuICAgICAgICBsZXZlbENzcyA9ICdjb2xvcjogQ3JpbXNvbic7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbGV2ZWxDc3MgPSAnY29sb3I6IEJsYWNrJztcbiAgICB9XG5cbiAgICB2YXIgbG9nZ2VyTmFtZSA9IHJlYy5jaGlsZE5hbWUgPyByZWMubmFtZSArICcvJyArIHJlYy5jaGlsZE5hbWUgOiByZWMubmFtZTtcblxuICAgIC8vZ2V0IGxldmVsIG5hbWUgYW5kIHBhZCBzdGFydCB3aXRoIHNwYWNzXG4gICAgdmFyIGxldmVsTmFtZSA9IG5hbWVGcm9tTGV2ZWxbcmVjLmxldmVsXS50b1VwcGVyQ2FzZSgpO1xuICAgIGxldmVsTmFtZSA9IEFycmF5KDYgLSBsZXZlbE5hbWUubGVuZ3RoKS5qb2luKCcgJykgKyBsZXZlbE5hbWU7XG5cbiAgICBmdW5jdGlvbiBwYWRaZXJvcyhudW1iZXIsIGxlbikge1xuICAgICAgICByZXR1cm4gQXJyYXkoKGxlbiArIDEpIC0gKG51bWJlciArICcnKS5sZW5ndGgpLmpvaW4oJzAnKSArIG51bWJlcjtcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZygnWyVzOiVzOiVzOiVzXSAlYyVzJWM6ICVzOiAlYyVzJyxcbiAgICAgICAgcGFkWmVyb3MocmVjLnRpbWUuZ2V0SG91cnMoKSwgMiksIHBhZFplcm9zKHJlYy50aW1lLmdldE1pbnV0ZXMoKSwgMiksXG4gICAgICAgIHBhZFplcm9zKHJlYy50aW1lLmdldFNlY29uZHMoKSwgMiksIHBhZFplcm9zKHJlYy50aW1lLmdldE1pbGxpc2Vjb25kcygpLCA0KSxcbiAgICAgICAgbGV2ZWxDc3MsIGxldmVsTmFtZSxcbiAgICAgICAgZGVmYXVsdENzcywgbG9nZ2VyTmFtZSxcbiAgICAgICAgbXNnQ3NzLCByZWMubXNnKTtcbiAgICBpZihyZWMuZXJyICYmIHJlYy5lcnIuc3RhY2spIHtcbiAgICAgICAgY29uc29sZS5sb2coJyVjJXMsJywgbGV2ZWxDc3MsIHJlYy5lcnIuc3RhY2spO1xuICAgIH1cbn07XG5cbi8vLS0tLSBMZXZlbHNcblxudmFyIFRSQUNFID0gMTA7XG52YXIgREVCVUcgPSAyMDtcbnZhciBJTkZPID0gMzA7XG52YXIgV0FSTiA9IDQwO1xudmFyIEVSUk9SID0gNTA7XG52YXIgRkFUQUwgPSA2MDtcblxudmFyIGxldmVsRnJvbU5hbWUgPSB7XG4gICAgJ3RyYWNlJzogVFJBQ0UsXG4gICAgJ2RlYnVnJzogREVCVUcsXG4gICAgJ2luZm8nOiBJTkZPLFxuICAgICd3YXJuJzogV0FSTixcbiAgICAnZXJyb3InOiBFUlJPUixcbiAgICAnZmF0YWwnOiBGQVRBTFxufTtcbnZhciBuYW1lRnJvbUxldmVsID0ge307XG5PYmplY3Qua2V5cyhsZXZlbEZyb21OYW1lKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgbmFtZUZyb21MZXZlbFtsZXZlbEZyb21OYW1lW25hbWVdXSA9IG5hbWU7XG59KTtcblxuXG4vKipcbiAqIFJlc29sdmUgYSBsZXZlbCBudW1iZXIsIG5hbWUgKHVwcGVyIG9yIGxvd2VyY2FzZSkgdG8gYSBsZXZlbCBudW1iZXIgdmFsdWUuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUxldmVsKG5hbWVPck51bSkge1xuICAgIHZhciBsZXZlbCA9ICh0eXBlb2YgKG5hbWVPck51bSkgPT09ICdzdHJpbmcnID8gbGV2ZWxGcm9tTmFtZVtuYW1lT3JOdW0udG9Mb3dlckNhc2UoKV0gOiBuYW1lT3JOdW0pO1xuICAgIHJldHVybiBsZXZlbDtcbn1cblxuXG4vLy0tLS0gTG9nZ2VyIGNsYXNzXG5cbi8qKlxuICogQ3JlYXRlIGEgTG9nZ2VyIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIHtPYmplY3R9IFNlZSBkb2N1bWVudGF0aW9uIGZvciBmdWxsIGRldGFpbHMuIEF0IG1pbmltdW1cbiAqICAgIHRoaXMgbXVzdCBpbmNsdWRlIGEgJ25hbWUnIHN0cmluZyBrZXkuIENvbmZpZ3VyYXRpb24ga2V5czpcbiAqICAgICAgLSBgc3RyZWFtc2A6IHNwZWNpZnkgdGhlIGxvZ2dlciBvdXRwdXQgc3RyZWFtcy4gVGhpcyBpcyBhbiBhcnJheSBvZlxuICogICAgICAgIG9iamVjdHMgd2l0aCB0aGVzZSBmaWVsZHM6XG4gKiAgICAgICAgICAtIGB0eXBlYDogVGhlIHN0cmVhbSB0eXBlLiBTZWUgUkVBRE1FLm1kIGZvciBmdWxsIGRldGFpbHMuXG4gKiAgICAgICAgICAgIE9mdGVuIHRoaXMgaXMgaW1wbGllZCBieSB0aGUgb3RoZXIgZmllbGRzLiBFeGFtcGxlcyBhcmVcbiAqICAgICAgICAgICAgJ2ZpbGUnLCAnc3RyZWFtJyBhbmQgXCJyYXdcIi5cbiAqICAgICAgICAgIC0gYGxldmVsYDogRGVmYXVsdHMgdG8gJ2luZm8nLlxuICogICAgICAgICAgLSBgcGF0aGAgb3IgYHN0cmVhbWA6IFRoZSBzcGVjaWZ5IHRoZSBmaWxlIHBhdGggb3Igd3JpdGVhYmxlXG4gKiAgICAgICAgICAgIHN0cmVhbSB0byB3aGljaCBsb2cgcmVjb3JkcyBhcmUgd3JpdHRlbi4gRS5nLlxuICogICAgICAgICAgICBgc3RyZWFtOiBwcm9jZXNzLnN0ZG91dGAuXG4gKiAgICAgICAgICAtIGBjbG9zZU9uRXhpdGAgKGJvb2xlYW4pOiBPcHRpb25hbC4gRGVmYXVsdCBpcyB0cnVlIGZvciBhXG4gKiAgICAgICAgICAgICdmaWxlJyBzdHJlYW0gd2hlbiBgcGF0aGAgaXMgZ2l2ZW4sIGZhbHNlIG90aGVyd2lzZS5cbiAqICAgICAgICBTZWUgUkVBRE1FLm1kIGZvciBmdWxsIGRldGFpbHMuXG4gKiAgICAgIC0gYGxldmVsYDogc2V0IHRoZSBsZXZlbCBmb3IgYSBzaW5nbGUgb3V0cHV0IHN0cmVhbSAoY2Fubm90IGJlIHVzZWRcbiAqICAgICAgICB3aXRoIGBzdHJlYW1zYClcbiAqICAgICAgLSBgc3RyZWFtYDogdGhlIG91dHB1dCBzdHJlYW0gZm9yIGEgbG9nZ2VyIHdpdGgganVzdCBvbmUsIGUuZy5cbiAqICAgICAgICBgcHJvY2Vzcy5zdGRvdXRgIChjYW5ub3QgYmUgdXNlZCB3aXRoIGBzdHJlYW1zYClcbiAqICAgICAgLSBgc2VyaWFsaXplcnNgOiBvYmplY3QgbWFwcGluZyBsb2cgcmVjb3JkIGZpZWxkIG5hbWVzIHRvXG4gKiAgICAgICAgc2VyaWFsaXppbmcgZnVuY3Rpb25zLiBTZWUgUkVBRE1FLm1kIGZvciBkZXRhaWxzLlxuICogICAgICAtIGBzcmNgOiBCb29sZWFuIChkZWZhdWx0IGZhbHNlKS4gU2V0IHRydWUgdG8gZW5hYmxlICdzcmMnIGF1dG9tYXRpY1xuICogICAgICAgIGZpZWxkIHdpdGggbG9nIGNhbGwgc291cmNlIGluZm8uXG4gKiAgICBBbGwgb3RoZXIga2V5cyBhcmUgbG9nIHJlY29yZCBmaWVsZHMuXG4gKlxuICogQW4gYWx0ZXJuYXRpdmUgKmludGVybmFsKiBjYWxsIHNpZ25hdHVyZSBpcyB1c2VkIGZvciBjcmVhdGluZyBhIGNoaWxkOlxuICogICAgbmV3IExvZ2dlcig8cGFyZW50IGxvZ2dlcj4sIDxjaGlsZCBvcHRpb25zPlssIDxjaGlsZCBvcHRzIGFyZSBzaW1wbGU+XSk7XG4gKlxuICogQHBhcmFtIF9jaGlsZFNpbXBsZSAoQm9vbGVhbikgQW4gYXNzZXJ0aW9uIHRoYXQgdGhlIGdpdmVuIGBfY2hpbGRPcHRpb25zYFxuICogICAgKGEpIG9ubHkgYWRkIGZpZWxkcyAobm8gY29uZmlnKSBhbmQgKGIpIG5vIHNlcmlhbGl6YXRpb24gaGFuZGxpbmcgaXNcbiAqICAgIHJlcXVpcmVkIGZvciB0aGVtLiBJT1csIHRoaXMgaXMgYSBmYXN0IHBhdGggZm9yIGZyZXF1ZW50IGNoaWxkXG4gKiAgICBjcmVhdGlvbi5cbiAqL1xuZnVuY3Rpb24gTG9nZ2VyKG9wdGlvbnMsIF9jaGlsZE9wdGlvbnMsIF9jaGlsZFNpbXBsZSkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBMb2dnZXIpKSB7XG4gICAgICAgIHJldHVybiBuZXcgTG9nZ2VyKG9wdGlvbnMsIF9jaGlsZE9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8vIElucHV0IGFyZyB2YWxpZGF0aW9uLlxuICAgIHZhciBwYXJlbnQ7XG4gICAgaWYgKF9jaGlsZE9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwYXJlbnQgPSBvcHRpb25zO1xuICAgICAgICBvcHRpb25zID0gX2NoaWxkT3B0aW9ucztcbiAgICAgICAgaWYgKCEocGFyZW50IGluc3RhbmNlb2YgTG9nZ2VyKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgICAnaW52YWxpZCBMb2dnZXIgY3JlYXRpb246IGRvIG5vdCBwYXNzIGEgc2Vjb25kIGFyZycpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb25zIChvYmplY3QpIGlzIHJlcXVpcmVkJyk7XG4gICAgfVxuICAgIGlmICghcGFyZW50KSB7XG4gICAgICAgIGlmICghb3B0aW9ucy5uYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb25zLm5hbWUgKHN0cmluZykgaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChvcHRpb25zLm5hbWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgICAgJ2ludmFsaWQgb3B0aW9ucy5uYW1lOiBjaGlsZCBjYW5ub3Qgc2V0IGxvZ2dlciBuYW1lJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuc3RyZWFtICYmIG9wdGlvbnMuc3RyZWFtcykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjYW5ub3QgbWl4IFwic3RyZWFtc1wiIGFuZCBcInN0cmVhbVwiIG9wdGlvbnMnKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuc3RyZWFtcyAmJiAhQXJyYXkuaXNBcnJheShvcHRpb25zLnN0cmVhbXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgb3B0aW9ucy5zdHJlYW1zOiBtdXN0IGJlIGFuIGFycmF5Jyk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnNlcmlhbGl6ZXJzICYmICh0eXBlb2YgKG9wdGlvbnMuc2VyaWFsaXplcnMpICE9PSAnb2JqZWN0JyB8fCBBcnJheS5pc0FycmF5KG9wdGlvbnMuc2VyaWFsaXplcnMpKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIG9wdGlvbnMuc2VyaWFsaXplcnM6IG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gICAgfVxuXG4gICAgdmFyIGZpZWxkcywgbmFtZSwgaTtcblxuICAgIC8vIEZhc3QgcGF0aCBmb3Igc2ltcGxlIGNoaWxkIGNyZWF0aW9uLlxuICAgIGlmIChwYXJlbnQgJiYgX2NoaWxkU2ltcGxlKSB7XG4gICAgICAgIC8vIGBfaXNTaW1wbGVDaGlsZGAgaXMgYSBzaWduYWwgdG8gc3RyZWFtIGNsb3NlIGhhbmRsaW5nIHRoYXQgdGhpcyBjaGlsZFxuICAgICAgICAvLyBvd25zIG5vbmUgb2YgaXRzIHN0cmVhbXMuXG4gICAgICAgIHRoaXMuX2lzU2ltcGxlQ2hpbGQgPSB0cnVlO1xuXG4gICAgICAgIHRoaXMuX2xldmVsID0gcGFyZW50Ll9sZXZlbDtcbiAgICAgICAgdGhpcy5zdHJlYW1zID0gcGFyZW50LnN0cmVhbXM7XG4gICAgICAgIHRoaXMuc2VyaWFsaXplcnMgPSBwYXJlbnQuc2VyaWFsaXplcnM7XG4gICAgICAgIHRoaXMuc3JjID0gcGFyZW50LnNyYztcbiAgICAgICAgZmllbGRzID0gdGhpcy5maWVsZHMgPSB7fTtcbiAgICAgICAgdmFyIHBhcmVudEZpZWxkTmFtZXMgPSBPYmplY3Qua2V5cyhwYXJlbnQuZmllbGRzKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHBhcmVudEZpZWxkTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG5hbWUgPSBwYXJlbnRGaWVsZE5hbWVzW2ldO1xuICAgICAgICAgICAgZmllbGRzW25hbWVdID0gcGFyZW50LmZpZWxkc1tuYW1lXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmFtZXMgPSBPYmplY3Qua2V5cyhvcHRpb25zKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBuYW1lID0gbmFtZXNbaV07XG4gICAgICAgICAgICBmaWVsZHNbbmFtZV0gPSBvcHRpb25zW25hbWVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBOdWxsIHZhbHVlcy5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgICB0aGlzLl9sZXZlbCA9IHBhcmVudC5fbGV2ZWw7XG4gICAgICAgIHRoaXMuc3RyZWFtcyA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGFyZW50LnN0cmVhbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzID0gb2JqQ29weShwYXJlbnQuc3RyZWFtc1tpXSk7XG4gICAgICAgICAgICBzLmNsb3NlT25FeGl0ID0gZmFsc2U7IC8vIERvbid0IG93biBwYXJlbnQgc3RyZWFtLlxuICAgICAgICAgICAgdGhpcy5zdHJlYW1zLnB1c2gocyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXJpYWxpemVycyA9IG9iakNvcHkocGFyZW50LnNlcmlhbGl6ZXJzKTtcbiAgICAgICAgdGhpcy5zcmMgPSBwYXJlbnQuc3JjO1xuICAgICAgICB0aGlzLmZpZWxkcyA9IG9iakNvcHkocGFyZW50LmZpZWxkcyk7XG4gICAgICAgIGlmIChvcHRpb25zLmxldmVsKSB7XG4gICAgICAgICAgICB0aGlzLmxldmVsKG9wdGlvbnMubGV2ZWwpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fbGV2ZWwgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgICAgIHRoaXMuc3RyZWFtcyA9IFtdO1xuICAgICAgICB0aGlzLnNlcmlhbGl6ZXJzID0gbnVsbDtcbiAgICAgICAgdGhpcy5zcmMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5maWVsZHMgPSB7fTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgKmNvbmZpZyogb3B0aW9ucyAoaS5lLiBvcHRpb25zIHRoYXQgYXJlIG5vdCBqdXN0IHBsYWluIGRhdGFcbiAgICAvLyBmb3IgbG9nIHJlY29yZHMpLlxuICAgIGlmIChvcHRpb25zLnN0cmVhbSkge1xuICAgICAgICBzZWxmLmFkZFN0cmVhbSh7XG4gICAgICAgICAgICB0eXBlOiAnc3RyZWFtJyxcbiAgICAgICAgICAgIHN0cmVhbTogb3B0aW9ucy5zdHJlYW0sXG4gICAgICAgICAgICBjbG9zZU9uRXhpdDogZmFsc2UsXG4gICAgICAgICAgICBsZXZlbDogb3B0aW9ucy5sZXZlbFxuICAgICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuc3RyZWFtcykge1xuICAgICAgICBvcHRpb25zLnN0cmVhbXMuZm9yRWFjaChmdW5jdGlvbiAocykge1xuICAgICAgICAgICAgc2VsZi5hZGRTdHJlYW0ocywgb3B0aW9ucy5sZXZlbCk7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAocGFyZW50ICYmIG9wdGlvbnMubGV2ZWwpIHtcbiAgICAgICAgdGhpcy5sZXZlbChvcHRpb25zLmxldmVsKTtcbiAgICB9IGVsc2UgaWYgKCFwYXJlbnQpIHtcblxuICAgICAgICAvKlxuICAgICAgICAgKiBJbiB0aGUgYnJvd3NlciB3ZSdsbCBiZSBlbWl0dGluZyB0byBjb25zb2xlLmxvZyBieSBkZWZhdWx0LlxuICAgICAgICAgKiBBbnkgY29uc29sZS5sb2cgd29ydGggaXRzIHNhbHQgdGhlc2UgZGF5cyBjYW4gbmljZWx5IHJlbmRlclxuICAgICAgICAgKiBhbmQgaW50cm9zcGVjdCBvYmplY3RzIChlLmcuIHRoZSBGaXJlZm94IGFuZCBDaHJvbWUgY29uc29sZSlcbiAgICAgICAgICogc28gbGV0J3MgZW1pdCB0aGUgcmF3IGxvZyByZWNvcmQuIEFyZSB0aGVyZSBicm93c2VycyBmb3Igd2hpY2hcbiAgICAgICAgICogdGhhdCBicmVha3MgdGhpbmdzP1xuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5hZGRTdHJlYW0oe1xuICAgICAgICAgICAgdHlwZTogJ3JhdycsXG4gICAgICAgICAgICBzdHJlYW06IG5ldyBDb25zb2xlUmF3U3RyZWFtKCksXG4gICAgICAgICAgICBjbG9zZU9uRXhpdDogZmFsc2UsXG4gICAgICAgICAgICBsZXZlbDogb3B0aW9ucy5sZXZlbFxuICAgICAgICB9KTtcblxuICAgIH1cbiAgICBpZiAob3B0aW9ucy5zZXJpYWxpemVycykge1xuICAgICAgICBzZWxmLmFkZFNlcmlhbGl6ZXJzKG9wdGlvbnMuc2VyaWFsaXplcnMpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5zcmMpIHtcbiAgICAgICAgdGhpcy5zcmMgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIEZpZWxkcy5cbiAgICAvLyBUaGVzZSBhcmUgdGhlIGRlZmF1bHQgZmllbGRzIGZvciBsb2cgcmVjb3JkcyAobWludXMgdGhlIGF0dHJpYnV0ZXNcbiAgICAvLyByZW1vdmVkIGluIHRoaXMgY29uc3RydWN0b3IpLiBUbyBhbGxvdyBzdG9yaW5nIHJhdyBsb2cgcmVjb3Jkc1xuICAgIC8vICh1bnJlbmRlcmVkKSwgYHRoaXMuZmllbGRzYCBtdXN0IG5ldmVyIGJlIG11dGF0ZWQuIENyZWF0ZSBhIGNvcHkgZm9yXG4gICAgLy8gYW55IGNoYW5nZXMuXG4gICAgZmllbGRzID0gb2JqQ29weShvcHRpb25zKTtcbiAgICBkZWxldGUgZmllbGRzLnN0cmVhbTtcbiAgICBkZWxldGUgZmllbGRzLmxldmVsO1xuICAgIGRlbGV0ZSBmaWVsZHMuc3RyZWFtcztcbiAgICBkZWxldGUgZmllbGRzLnNlcmlhbGl6ZXJzO1xuICAgIGRlbGV0ZSBmaWVsZHMuc3JjO1xuICAgIGlmICh0aGlzLnNlcmlhbGl6ZXJzKSB7XG4gICAgICAgIHRoaXMuX2FwcGx5U2VyaWFsaXplcnMoZmllbGRzKTtcbiAgICB9XG4gICAgT2JqZWN0LmtleXMoZmllbGRzKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHNlbGYuZmllbGRzW2tdID0gZmllbGRzW2tdO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIEFkZCBhIHN0cmVhbVxuICpcbiAqIEBwYXJhbSBzdHJlYW0ge09iamVjdH0uIE9iamVjdCB3aXRoIHRoZXNlIGZpZWxkczpcbiAqICAgIC0gYHR5cGVgOiBUaGUgc3RyZWFtIHR5cGUuIFNlZSBSRUFETUUubWQgZm9yIGZ1bGwgZGV0YWlscy5cbiAqICAgICAgT2Z0ZW4gdGhpcyBpcyBpbXBsaWVkIGJ5IHRoZSBvdGhlciBmaWVsZHMuIEV4YW1wbGVzIGFyZVxuICogICAgICAnZmlsZScsICdzdHJlYW0nIGFuZCBcInJhd1wiLlxuICogICAgLSBgcGF0aGAgb3IgYHN0cmVhbWA6IFRoZSBzcGVjaWZ5IHRoZSBmaWxlIHBhdGggb3Igd3JpdGVhYmxlXG4gKiAgICAgIHN0cmVhbSB0byB3aGljaCBsb2cgcmVjb3JkcyBhcmUgd3JpdHRlbi4gRS5nLlxuICogICAgICBgc3RyZWFtOiBwcm9jZXNzLnN0ZG91dGAuXG4gKiAgICAtIGBsZXZlbGA6IE9wdGlvbmFsLiBGYWxscyBiYWNrIHRvIGBkZWZhdWx0TGV2ZWxgLlxuICogICAgLSBgY2xvc2VPbkV4aXRgIChib29sZWFuKTogT3B0aW9uYWwuIERlZmF1bHQgaXMgdHJ1ZSBmb3IgYVxuICogICAgICAnZmlsZScgc3RyZWFtIHdoZW4gYHBhdGhgIGlzIGdpdmVuLCBmYWxzZSBvdGhlcndpc2UuXG4gKiAgICBTZWUgUkVBRE1FLm1kIGZvciBmdWxsIGRldGFpbHMuXG4gKiBAcGFyYW0gZGVmYXVsdExldmVsIHtOdW1iZXJ8U3RyaW5nfSBPcHRpb25hbC4gQSBsZXZlbCB0byB1c2UgaWZcbiAqICAgICAgYHN0cmVhbS5sZXZlbGAgaXMgbm90IHNldC4gSWYgbmVpdGhlciBpcyBnaXZlbiwgdGhpcyBkZWZhdWx0cyB0byBJTkZPLlxuICovXG5Mb2dnZXIucHJvdG90eXBlLmFkZFN0cmVhbSA9IGZ1bmN0aW9uIGFkZFN0cmVhbShzLCBkZWZhdWx0TGV2ZWwpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaWYgKGRlZmF1bHRMZXZlbCA9PT0gbnVsbCB8fCBkZWZhdWx0TGV2ZWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkZWZhdWx0TGV2ZWwgPSBJTkZPO1xuICAgIH1cblxuICAgIHMgPSBvYmpDb3B5KHMpO1xuXG4gICAgLy8gSW1wbGljaXQgJ3R5cGUnIGZyb20gb3RoZXIgYXJncy5cbiAgICBpZiAoIXMudHlwZSAmJiBzLnN0cmVhbSkge1xuICAgICAgICBzLnR5cGUgPSAncmF3JztcbiAgICB9XG4gICAgcy5yYXcgPSAocy50eXBlID09PSAncmF3Jyk7ICAvLyBQRVJGOiBBbGxvdyBmb3IgZmFzdGVyIGNoZWNrIGluIGBfZW1pdGAuXG5cbiAgICBpZiAocy5sZXZlbCkge1xuICAgICAgICBzLmxldmVsID0gcmVzb2x2ZUxldmVsKHMubGV2ZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHMubGV2ZWwgPSByZXNvbHZlTGV2ZWwoZGVmYXVsdExldmVsKTtcbiAgICB9XG4gICAgaWYgKHMubGV2ZWwgPCBzZWxmLl9sZXZlbCkge1xuICAgICAgICBzZWxmLl9sZXZlbCA9IHMubGV2ZWw7XG4gICAgfVxuXG4gICAgc3dpdGNoIChzLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnc3RyZWFtJzpcbiAgICAgICAgICAgIGlmICghcy5jbG9zZU9uRXhpdCkge1xuICAgICAgICAgICAgICAgIHMuY2xvc2VPbkV4aXQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdyYXcnOlxuICAgICAgICAgICAgaWYgKCFzLmNsb3NlT25FeGl0KSB7XG4gICAgICAgICAgICAgICAgcy5jbG9zZU9uRXhpdCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd1bmtub3duIHN0cmVhbSB0eXBlIFwiJyArIHMudHlwZSArICdcIicpO1xuICAgIH1cblxuICAgIHNlbGYuc3RyZWFtcy5wdXNoKHMpO1xuICAgIGRlbGV0ZSBzZWxmLmhhdmVOb25SYXdTdHJlYW1zOyAgLy8gcmVzZXRcbn07XG5cblxuLyoqXG4gKiBBZGQgc2VyaWFsaXplcnNcbiAqXG4gKiBAcGFyYW0gc2VyaWFsaXplcnMge09iamVjdH0gT3B0aW9uYWwuIE9iamVjdCBtYXBwaW5nIGxvZyByZWNvcmQgZmllbGQgbmFtZXNcbiAqICAgIHRvIHNlcmlhbGl6aW5nIGZ1bmN0aW9ucy4gU2VlIFJFQURNRS5tZCBmb3IgZGV0YWlscy5cbiAqL1xuTG9nZ2VyLnByb3RvdHlwZS5hZGRTZXJpYWxpemVycyA9IGZ1bmN0aW9uIGFkZFNlcmlhbGl6ZXJzKHNlcmlhbGl6ZXJzKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgaWYgKCFzZWxmLnNlcmlhbGl6ZXJzKSB7XG4gICAgICAgIHNlbGYuc2VyaWFsaXplcnMgPSB7fTtcbiAgICB9XG4gICAgT2JqZWN0LmtleXMoc2VyaWFsaXplcnMpLmZvckVhY2goZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgIHZhciBzZXJpYWxpemVyID0gc2VyaWFsaXplcnNbZmllbGRdO1xuICAgICAgICBpZiAodHlwZW9mIChzZXJpYWxpemVyKSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihmb3JtYXQoXG4gICAgICAgICAgICAgICAgJ2ludmFsaWQgc2VyaWFsaXplciBmb3IgXCIlc1wiIGZpZWxkOiBtdXN0IGJlIGEgZnVuY3Rpb24nLFxuICAgICAgICAgICAgICAgIGZpZWxkKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLnNlcmlhbGl6ZXJzW2ZpZWxkXSA9IHNlcmlhbGl6ZXI7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5cblxuLyoqXG4gKiBDcmVhdGUgYSBjaGlsZCBsb2dnZXIsIHR5cGljYWxseSB0byBhZGQgYSBmZXcgbG9nIHJlY29yZCBmaWVsZHMuXG4gKlxuICogVGhpcyBjYW4gYmUgdXNlZnVsIHdoZW4gcGFzc2luZyBhIGxvZ2dlciB0byBhIHN1Yi1jb21wb25lbnQsIGUuZy4gYVxuICogJ3d1enpsZScgY29tcG9uZW50IG9mIHlvdXIgc2VydmljZTpcbiAqXG4gKiAgICB2YXIgd3V6emxlTG9nID0gbG9nLmNoaWxkKHtjb21wb25lbnQ6ICd3dXp6bGUnfSlcbiAqICAgIHZhciB3dXp6bGUgPSBuZXcgV3V6emxlKHsuLi4sIGxvZzogd3V6emxlTG9nfSlcbiAqXG4gKiBUaGVuIGxvZyByZWNvcmRzIGZyb20gdGhlIHd1enpsZSBjb2RlIHdpbGwgaGF2ZSB0aGUgc2FtZSBzdHJ1Y3R1cmUgYXNcbiAqIHRoZSBhcHAgbG9nLCAqcGx1cyB0aGUgY29tcG9uZW50PSd3dXp6bGUnIGZpZWxkKi5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyB7T2JqZWN0fSBPcHRpb25hbC4gU2V0IG9mIG9wdGlvbnMgdG8gYXBwbHkgdG8gdGhlIGNoaWxkLlxuICogICAgQWxsIG9mIHRoZSBzYW1lIG9wdGlvbnMgZm9yIGEgbmV3IExvZ2dlciBhcHBseSBoZXJlLiBOb3RlczpcbiAqICAgICAgLSBUaGUgcGFyZW50J3Mgc3RyZWFtcyBhcmUgaW5oZXJpdGVkIGFuZCBjYW5ub3QgYmUgcmVtb3ZlZCBpbiB0aGlzXG4gKiAgICAgICAgY2FsbC4gQW55IGdpdmVuIGBzdHJlYW1zYCBhcmUgKmFkZGVkKiB0byB0aGUgc2V0IGluaGVyaXRlZCBmcm9tXG4gKiAgICAgICAgdGhlIHBhcmVudC5cbiAqICAgICAgLSBUaGUgcGFyZW50J3Mgc2VyaWFsaXplcnMgYXJlIGluaGVyaXRlZCwgdGhvdWdoIGNhbiBlZmZlY3RpdmVseSBiZVxuICogICAgICAgIG92ZXJ3cml0dGVuIGJ5IHVzaW5nIGR1cGxpY2F0ZSBrZXlzLlxuICogICAgICAtIENhbiB1c2UgYGxldmVsYCB0byBzZXQgdGhlIGxldmVsIG9mIHRoZSBzdHJlYW1zIGluaGVyaXRlZCBmcm9tXG4gKiAgICAgICAgdGhlIHBhcmVudC4gVGhlIGxldmVsIGZvciB0aGUgcGFyZW50IGlzIE5PVCBhZmZlY3RlZC5cbiAqIEBwYXJhbSBzaW1wbGUge0Jvb2xlYW59IE9wdGlvbmFsLiBTZXQgdG8gdHJ1ZSB0byBhc3NlcnQgdGhhdCBgb3B0aW9uc2BcbiAqICAgIChhKSBvbmx5IGFkZCBmaWVsZHMgKG5vIGNvbmZpZykgYW5kIChiKSBubyBzZXJpYWxpemF0aW9uIGhhbmRsaW5nIGlzXG4gKiAgICByZXF1aXJlZCBmb3IgdGhlbS4gSU9XLCB0aGlzIGlzIGEgZmFzdCBwYXRoIGZvciBmcmVxdWVudCBjaGlsZFxuICogICAgY3JlYXRpb24uIFNlZSAndG9vbHMvdGltZWNoaWxkLmpzJyBmb3IgbnVtYmVycy5cbiAqL1xuTG9nZ2VyLnByb3RvdHlwZS5jaGlsZCA9IGZ1bmN0aW9uIChvcHRpb25zLCBzaW1wbGUpIHtcbiAgICByZXR1cm4gbmV3ICh0aGlzLmNvbnN0cnVjdG9yKSh0aGlzLCBvcHRpb25zIHx8IHt9LCBzaW1wbGUpO1xufTtcblxuLyoqXG4gKiBHZXQvc2V0IHRoZSBsZXZlbCBvZiBhbGwgc3RyZWFtcyBvbiB0aGlzIGxvZ2dlci5cbiAqXG4gKiBHZXQgVXNhZ2U6XG4gKiAgICAvLyBSZXR1cm5zIHRoZSBjdXJyZW50IGxvZyBsZXZlbCAobG93ZXN0IGxldmVsIG9mIGFsbCBpdHMgc3RyZWFtcykuXG4gKiAgICBsb2cubGV2ZWwoKSAtPiBJTkZPXG4gKlxuICogU2V0IFVzYWdlOlxuICogICAgbG9nLmxldmVsKElORk8pICAgICAgIC8vIHNldCBhbGwgc3RyZWFtcyB0byBsZXZlbCBJTkZPXG4gKiAgICBsb2cubGV2ZWwoJ2luZm8nKSAgICAgLy8gY2FuIHVzZSAnaW5mbycgZXQgYWwgYWxpYXNlc1xuICovXG5Mb2dnZXIucHJvdG90eXBlLmxldmVsID0gZnVuY3Rpb24gbGV2ZWwodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGV2ZWw7XG4gICAgfVxuICAgIHZhciBuZXdMZXZlbCA9IHJlc29sdmVMZXZlbCh2YWx1ZSk7XG4gICAgdmFyIGxlbiA9IHRoaXMuc3RyZWFtcy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB0aGlzLnN0cmVhbXNbaV0ubGV2ZWwgPSBuZXdMZXZlbDtcbiAgICB9XG4gICAgdGhpcy5fbGV2ZWwgPSBuZXdMZXZlbDtcbn07XG5cblxuLyoqXG4gKiBHZXQvc2V0IHRoZSBsZXZlbCBvZiBhIHBhcnRpY3VsYXIgc3RyZWFtIG9uIHRoaXMgbG9nZ2VyLlxuICpcbiAqIEdldCBVc2FnZTpcbiAqICAgIC8vIFJldHVybnMgYW4gYXJyYXkgb2YgdGhlIGxldmVscyBvZiBlYWNoIHN0cmVhbS5cbiAqICAgIGxvZy5sZXZlbHMoKSAtPiBbVFJBQ0UsIElORk9dXG4gKlxuICogICAgLy8gUmV0dXJucyBhIGxldmVsIG9mIHRoZSBpZGVudGlmaWVkIHN0cmVhbS5cbiAqICAgIGxvZy5sZXZlbHMoMCkgLT4gVFJBQ0UgICAgICAvLyBsZXZlbCBvZiBzdHJlYW0gYXQgaW5kZXggMFxuICogICAgbG9nLmxldmVscygnZm9vJykgICAgICAgICAgIC8vIGxldmVsIG9mIHN0cmVhbSB3aXRoIG5hbWUgJ2ZvbydcbiAqXG4gKiBTZXQgVXNhZ2U6XG4gKiAgICBsb2cubGV2ZWxzKDAsIElORk8pICAgICAgICAgLy8gc2V0IGxldmVsIG9mIHN0cmVhbSAwIHRvIElORk9cbiAqICAgIGxvZy5sZXZlbHMoMCwgJ2luZm8nKSAgICAgICAvLyBjYW4gdXNlICdpbmZvJyBldCBhbCBhbGlhc2VzXG4gKiAgICBsb2cubGV2ZWxzKCdmb28nLCBXQVJOKSAgICAgLy8gc2V0IHN0cmVhbSBuYW1lZCAnZm9vJyB0byBXQVJOXG4gKlxuICogU3RyZWFtIG5hbWVzOiBXaGVuIHN0cmVhbXMgYXJlIGRlZmluZWQsIHRoZXkgY2FuIG9wdGlvbmFsbHkgYmUgZ2l2ZW5cbiAqIGEgbmFtZS4gRm9yIGV4YW1wbGUsXG4gKiAgICAgICBsb2cgPSBuZXcgTG9nZ2VyKHtcbiAqICAgICAgICAgc3RyZWFtczogW1xuICogICAgICAgICAgIHtcbiAqICAgICAgICAgICAgIG5hbWU6ICdmb28nLFxuICogICAgICAgICAgICAgcGF0aDogJy92YXIvbG9nL215LXNlcnZpY2UvZm9vLmxvZydcbiAqICAgICAgICAgICAgIGxldmVsOiAndHJhY2UnXG4gKiAgICAgICAgICAgfSxcbiAqICAgICAgICAgLi4uXG4gKlxuICogQHBhcmFtIG5hbWUge1N0cmluZ3xOdW1iZXJ9IFRoZSBzdHJlYW0gaW5kZXggb3IgbmFtZS5cbiAqIEBwYXJhbSB2YWx1ZSB7TnVtYmVyfFN0cmluZ30gVGhlIGxldmVsIHZhbHVlIChJTkZPKSBvciBhbGlhcyAoJ2luZm8nKS5cbiAqICAgIElmIG5vdCBnaXZlbiwgdGhpcyBpcyBhICdnZXQnIG9wZXJhdGlvbi5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGVyZSBpcyBubyBzdHJlYW0gd2l0aCB0aGUgZ2l2ZW4gbmFtZS5cbiAqL1xuTG9nZ2VyLnByb3RvdHlwZS5sZXZlbHMgPSBmdW5jdGlvbiBsZXZlbHMobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAobmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cmVhbXMubWFwKFxuICAgICAgICAgICAgZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcy5sZXZlbDtcbiAgICAgICAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgc3RyZWFtO1xuICAgIGlmICh0eXBlb2YgKG5hbWUpID09PSAnbnVtYmVyJykge1xuICAgICAgICBzdHJlYW0gPSB0aGlzLnN0cmVhbXNbbmFtZV07XG4gICAgICAgIGlmIChzdHJlYW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHN0cmVhbSBpbmRleDogJyArIG5hbWUpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGxlbiA9IHRoaXMuc3RyZWFtcy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzID0gdGhpcy5zdHJlYW1zW2ldO1xuICAgICAgICAgICAgaWYgKHMubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICAgICAgICAgIHN0cmVhbSA9IHM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzdHJlYW0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihmb3JtYXQoJ25vIHN0cmVhbSB3aXRoIG5hbWUgXCIlc1wiJywgbmFtZSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBzdHJlYW0ubGV2ZWw7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG5ld0xldmVsID0gcmVzb2x2ZUxldmVsKHZhbHVlKTtcbiAgICAgICAgc3RyZWFtLmxldmVsID0gbmV3TGV2ZWw7XG4gICAgICAgIGlmIChuZXdMZXZlbCA8IHRoaXMuX2xldmVsKSB7XG4gICAgICAgICAgICB0aGlzLl9sZXZlbCA9IG5ld0xldmVsO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuXG4vKipcbiAqIEFwcGx5IHJlZ2lzdGVyZWQgc2VyaWFsaXplcnMgdG8gdGhlIGFwcHJvcHJpYXRlIGtleXMgaW4gdGhlIGdpdmVuIGZpZWxkcy5cbiAqXG4gKiBQcmUtY29uZGl0aW9uOiBUaGlzIGlzIG9ubHkgY2FsbGVkIGlmIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBzZXJpYWxpemVyLlxuICpcbiAqIEBwYXJhbSBmaWVsZHMgKE9iamVjdCkgVGhlIGxvZyByZWNvcmQgZmllbGRzLlxuICogQHBhcmFtIGV4Y2x1ZGVGaWVsZHMgKE9iamVjdCkgT3B0aW9uYWwgbWFwcGluZyBvZiBrZXlzIHRvIGB0cnVlYCBmb3JcbiAqICAgIGtleXMgdG8gTk9UIGFwcGx5IGEgc2VyaWFsaXplci5cbiAqL1xuTG9nZ2VyLnByb3RvdHlwZS5fYXBwbHlTZXJpYWxpemVycyA9IGZ1bmN0aW9uIChmaWVsZHMsIGV4Y2x1ZGVGaWVsZHMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBDaGVjayBlYWNoIHNlcmlhbGl6ZXIgYWdhaW5zdCB0aGVzZSAocHJlc3VtaW5nIG51bWJlciBvZiBzZXJpYWxpemVyc1xuICAgIC8vIGlzIHR5cGljYWxseSBsZXNzIHRoYW4gbnVtYmVyIG9mIGZpZWxkcykuXG4gICAgT2JqZWN0LmtleXModGhpcy5zZXJpYWxpemVycykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBpZiAoZmllbGRzW25hbWVdID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIChleGNsdWRlRmllbGRzICYmIGV4Y2x1ZGVGaWVsZHNbbmFtZV0pKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZpZWxkc1tuYW1lXSA9IHNlbGYuc2VyaWFsaXplcnNbbmFtZV0oZmllbGRzW25hbWVdKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBfd2Fybihmb3JtYXQoJ2J1bnlhbjogRVJST1I6IEV4Y2VwdGlvbiB0aHJvd24gZnJvbSB0aGUgXCIlc1wiICcgK1xuICAgICAgICAgICAgICAgICAgICAnQnVueWFuIHNlcmlhbGl6ZXIuIFRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbi4gVGhpcyBpcyBhIGJ1ZycgK1xuICAgICAgICAgICAgICAgICAgICAnaW4gdGhhdCBzZXJpYWxpemVyIGZ1bmN0aW9uLlxcbiVzJyxcbiAgICAgICAgICAgICAgICBuYW1lLCBlcnIuc3RhY2sgfHwgZXJyKSk7XG4gICAgICAgICAgICBmaWVsZHNbbmFtZV0gPSBmb3JtYXQoJyhFcnJvciBpbiBCdW55YW4gbG9nIFwiJXNcIiBzZXJpYWxpemVyIGJyb2tlIGZpZWxkLiBTZWUgc3RkZXJyIGZvciBkZXRhaWxzLiknLCBuYW1lKTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxuXG4vKipcbiAqIEVtaXQgYSBsb2cgcmVjb3JkLlxuICpcbiAqIEBwYXJhbSByZWMge2xvZyByZWNvcmR9XG4gKiBAcGFyYW0gbm9lbWl0IHtCb29sZWFufSBPcHRpb25hbC4gU2V0IHRvIHRydWUgdG8gc2tpcCBlbWlzc2lvblxuICogICAgICBhbmQganVzdCByZXR1cm4gdGhlIEpTT04gc3RyaW5nLlxuICovXG5Mb2dnZXIucHJvdG90eXBlLl9lbWl0ID0gZnVuY3Rpb24gKHJlYywgbm9lbWl0KSB7XG4gICAgdmFyIGk7XG5cbiAgICAvLyBMYXppbHkgZGV0ZXJtaW5lIGlmIHRoaXMgTG9nZ2VyIGhhcyBub24tJ3Jhdycgc3RyZWFtcy4gSWYgdGhlcmUgYXJlXG4gICAgLy8gYW55LCB0aGVuIHdlIG5lZWQgdG8gc3RyaW5naWZ5IHRoZSBsb2cgcmVjb3JkLlxuICAgIGlmICh0aGlzLmhhdmVOb25SYXdTdHJlYW1zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5oYXZlTm9uUmF3U3RyZWFtcyA9IGZhbHNlO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5zdHJlYW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc3RyZWFtc1tpXS5yYXcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhdmVOb25SYXdTdHJlYW1zID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFN0cmluZ2lmeSB0aGUgb2JqZWN0LiBBdHRlbXB0IHRvIHdhcm4vcmVjb3ZlciBvbiBlcnJvci5cbiAgICB2YXIgc3RyO1xuICAgIGlmIChub2VtaXQgfHwgdGhpcy5oYXZlTm9uUmF3U3RyZWFtcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc3RyID0gSlNPTi5zdHJpbmdpZnkocmVjLCBzYWZlQ3ljbGVzKCkpICsgJ1xcbic7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHZhciBkZWR1cEtleSA9IGUuc3RhY2suc3BsaXQoL1xcbi9nLCAyKS5qb2luKCdcXG4nKTtcbiAgICAgICAgICAgIF93YXJuKCdidW55YW46IEVSUk9SOiBFeGNlcHRpb24gaW4gJyArXG4gICAgICAgICAgICAgICAgICAgICdgSlNPTi5zdHJpbmdpZnkocmVjKWAuIFlvdSBjYW4gaW5zdGFsbCB0aGUgJyArXG4gICAgICAgICAgICAgICAgICAgICdcInNhZmUtanNvbi1zdHJpbmdpZnlcIiBtb2R1bGUgdG8gaGF2ZSBCdW55YW4gZmFsbGJhY2sgJyArXG4gICAgICAgICAgICAgICAgICAgICd0byBzYWZlciBzdHJpbmdpZmljYXRpb24uIFJlY29yZDpcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgX2luZGVudChmb3JtYXQoJyVzXFxuJXMnLCByZWMsIGUuc3RhY2spKSxcbiAgICAgICAgICAgICAgICBkZWR1cEtleSk7XG4gICAgICAgICAgICBzdHIgPSBmb3JtYXQoJyhFeGNlcHRpb24gaW4gSlNPTi5zdHJpbmdpZnkocmVjKTogJWouIFNlZSBzdGRlcnIgZm9yIGRldGFpbHMuKVxcbicsIGUubWVzc2FnZSk7XG5cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChub2VtaXQpIHtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG5cblxuICAgIHZhciBsZXZlbCA9IHJlYy5sZXZlbDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5zdHJlYW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzID0gdGhpcy5zdHJlYW1zW2ldO1xuICAgICAgICBpZiAocy5sZXZlbCA8PSBsZXZlbCkge1xuICAgICAgICAgICAgcy5zdHJlYW0ud3JpdGUocy5yYXcgPyByZWMgOiBzdHIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cjtcbn07XG5cblxuLyoqXG4gKiBCdWlsZCBhIGxvZyBlbWl0dGVyIGZ1bmN0aW9uIGZvciBsZXZlbCBtaW5MZXZlbC4gSS5lLiB0aGlzIGlzIHRoZVxuICogY3JlYXRvciBvZiBgbG9nLmluZm9gLCBgbG9nLmVycm9yYCwgZXRjLlxuICovXG5mdW5jdGlvbiBta0xvZ0VtaXR0ZXIobWluTGV2ZWwpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbG9nID0gdGhpcztcblxuICAgICAgICBmdW5jdGlvbiBta1JlY29yZChhcmdzKSB7XG4gICAgICAgICAgICB2YXIgZXhjbHVkZUZpZWxkcztcbiAgICAgICAgICAgIGlmIChhcmdzWzBdIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBgbG9nLjxsZXZlbD4oZXJyLCAuLi4pYFxuICAgICAgICAgICAgICAgIGZpZWxkcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlIHRoaXMgTG9nZ2VyJ3MgZXJyIHNlcmlhbGl6ZXIsIGlmIGRlZmluZWQuXG4gICAgICAgICAgICAgICAgICAgIGVycjogKGxvZy5zZXJpYWxpemVycyAmJiBsb2cuc2VyaWFsaXplcnMuZXJyID8gbG9nLnNlcmlhbGl6ZXJzLmVycihhcmdzWzBdKSA6IExvZ2dlci5zdGRTZXJpYWxpemVycy5lcnIoYXJnc1swXSkpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBleGNsdWRlRmllbGRzID0ge2VycjogdHJ1ZX07XG4gICAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIG1zZ0FyZ3MgPSBbZmllbGRzLmVyci5tZXNzYWdlXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtc2dBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncywgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgKGFyZ3NbMF0pICE9PSAnb2JqZWN0JyAmJiBhcmdzWzBdICE9PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgQXJyYXkuaXNBcnJheShhcmdzWzBdKSkge1xuICAgICAgICAgICAgICAgIC8vIGBsb2cuPGxldmVsPihtc2csIC4uLilgXG4gICAgICAgICAgICAgICAgZmllbGRzID0gbnVsbDtcbiAgICAgICAgICAgICAgICBtc2dBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncyk7XG4gICAgICAgICAgICB9IGVsc2UgeyAgLy8gYGxvZy48bGV2ZWw+KGZpZWxkcywgbXNnLCAuLi4pYFxuICAgICAgICAgICAgICAgIGZpZWxkcyA9IGFyZ3NbMF07XG4gICAgICAgICAgICAgICAgbXNnQXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MsIDEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBCdWlsZCB1cCB0aGUgcmVjb3JkIG9iamVjdC5cbiAgICAgICAgICAgIHZhciByZWMgPSBvYmpDb3B5KGxvZy5maWVsZHMpO1xuICAgICAgICAgICAgcmVjLmxldmVsID0gbWluTGV2ZWw7XG4gICAgICAgICAgICB2YXIgcmVjRmllbGRzID0gKGZpZWxkcyA/IG9iakNvcHkoZmllbGRzKSA6IG51bGwpO1xuICAgICAgICAgICAgaWYgKHJlY0ZpZWxkcykge1xuICAgICAgICAgICAgICAgIGlmIChsb2cuc2VyaWFsaXplcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nLl9hcHBseVNlcmlhbGl6ZXJzKHJlY0ZpZWxkcywgZXhjbHVkZUZpZWxkcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHJlY0ZpZWxkcykuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgICAgICAgICByZWNba10gPSByZWNGaWVsZHNba107XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWMubGV2ZWxOYW1lID0gbmFtZUZyb21MZXZlbFttaW5MZXZlbF07XG4gICAgICAgICAgICByZWMubXNnID0gZm9ybWF0LmFwcGx5KGxvZywgbXNnQXJncyk7XG4gICAgICAgICAgICBpZiAoIXJlYy50aW1lKSB7XG4gICAgICAgICAgICAgICAgcmVjLnRpbWUgPSAobmV3IERhdGUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBHZXQgY2FsbCBzb3VyY2UgaW5mb1xuICAgICAgICAgICAgaWYgKGxvZy5zcmMgJiYgIXJlYy5zcmMpIHtcbiAgICAgICAgICAgICAgICByZWMuc3JjID0gZ2V0Q2FsbGVyM0luZm8oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlYy52ID0gTE9HX1ZFUlNJT047XG5cbiAgICAgICAgICAgIHJldHVybiByZWM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZmllbGRzID0gbnVsbDtcbiAgICAgICAgdmFyIG1zZ0FyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIHZhciByZWMgPSBudWxsO1xuICAgICAgICBpZiAoIXRoaXMuX2VtaXQpIHtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBTaG93IHRoaXMgaW52YWxpZCBCdW55YW4gdXNhZ2Ugd2FybmluZyAqb25jZSouXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogU2VlIDxodHRwczovL2dpdGh1Yi5jb20vdHJlbnRtL25vZGUtYnVueWFuL2lzc3Vlcy8xMDA+IGZvclxuICAgICAgICAgICAgICogYW4gZXhhbXBsZSBvZiBob3cgdGhpcyBjYW4gaGFwcGVuLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YXIgZGVkdXBLZXkgPSAndW5ib3VuZCc7XG4gICAgICAgICAgICBpZiAoIV9oYXZlV2FybmVkW2RlZHVwS2V5XSkge1xuICAgICAgICAgICAgICAgIHZhciBjYWxsZXIgPSBnZXRDYWxsZXIzSW5mbygpO1xuICAgICAgICAgICAgICAgIF93YXJuKGZvcm1hdCgnYnVueWFuIHVzYWdlIGVycm9yOiAlczolczogYXR0ZW1wdCB0byBsb2cgd2l0aCBhbiB1bmJvdW5kIGxvZyBtZXRob2Q6IGB0aGlzYCBpczogJXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGVyLmZpbGUsIGNhbGxlci5saW5lLCB0aGlzLnRvU3RyaW5nKCkpLFxuICAgICAgICAgICAgICAgICAgICBkZWR1cEtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgeyAgIC8vIGBsb2cuPGxldmVsPigpYFxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLl9sZXZlbCA8PSBtaW5MZXZlbCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fbGV2ZWwgPiBtaW5MZXZlbCkge1xuICAgICAgICAgICAgLyogcGFzcyB0aHJvdWdoICovXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWMgPSBta1JlY29yZChtc2dBcmdzKTtcbiAgICAgICAgICAgIHRoaXMuX2VtaXQocmVjKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cblxuLyoqXG4gKiBUaGUgZnVuY3Rpb25zIGJlbG93IGxvZyBhIHJlY29yZCBhdCBhIHNwZWNpZmljIGxldmVsLlxuICpcbiAqIFVzYWdlczpcbiAqICAgIGxvZy48bGV2ZWw+KCkgIC0+IGJvb2xlYW4gaXMtdHJhY2UtZW5hYmxlZFxuICogICAgbG9nLjxsZXZlbD4oPEVycm9yPiBlcnIsIFs8c3RyaW5nPiBtc2csIC4uLl0pXG4gKiAgICBsb2cuPGxldmVsPig8c3RyaW5nPiBtc2csIC4uLilcbiAqICAgIGxvZy48bGV2ZWw+KDxvYmplY3Q+IGZpZWxkcywgPHN0cmluZz4gbXNnLCAuLi4pXG4gKlxuICogd2hlcmUgPGxldmVsPiBpcyB0aGUgbG93ZXJjYXNlIHZlcnNpb24gb2YgdGhlIGxvZyBsZXZlbC4gRS5nLjpcbiAqXG4gKiAgICBsb2cuaW5mbygpXG4gKlxuICogQHBhcmFtcyBmaWVsZHMge09iamVjdH0gT3B0aW9uYWwgc2V0IG9mIGFkZGl0aW9uYWwgZmllbGRzIHRvIGxvZy5cbiAqIEBwYXJhbXMgbXNnIHtTdHJpbmd9IExvZyBtZXNzYWdlLiBUaGlzIGNhbiBiZSBmb2xsb3dlZCBieSBhZGRpdGlvbmFsXG4gKiAgICBhcmd1bWVudHMgdGhhdCBhcmUgaGFuZGxlZCBsaWtlXG4gKiAgICBbdXRpbC5mb3JtYXRdKGh0dHA6Ly9ub2RlanMub3JnL2RvY3MvbGF0ZXN0L2FwaS9hbGwuaHRtbCN1dGlsLmZvcm1hdCkuXG4gKi9cbkxvZ2dlci5wcm90b3R5cGUudHJhY2UgPSBta0xvZ0VtaXR0ZXIoVFJBQ0UpO1xuTG9nZ2VyLnByb3RvdHlwZS5kZWJ1ZyA9IG1rTG9nRW1pdHRlcihERUJVRyk7XG5Mb2dnZXIucHJvdG90eXBlLmluZm8gPSBta0xvZ0VtaXR0ZXIoSU5GTyk7XG5Mb2dnZXIucHJvdG90eXBlLndhcm4gPSBta0xvZ0VtaXR0ZXIoV0FSTik7XG5Mb2dnZXIucHJvdG90eXBlLmVycm9yID0gbWtMb2dFbWl0dGVyKEVSUk9SKTtcbkxvZ2dlci5wcm90b3R5cGUuZmF0YWwgPSBta0xvZ0VtaXR0ZXIoRkFUQUwpO1xuXG5cbi8vLS0tLSBTdGFuZGFyZCBzZXJpYWxpemVyc1xuLy8gQSBzZXJpYWxpemVyIGlzIGEgZnVuY3Rpb24gdGhhdCBzZXJpYWxpemVzIGEgSmF2YVNjcmlwdCBvYmplY3QgdG8gYVxuLy8gSlNPTiByZXByZXNlbnRhdGlvbiBmb3IgbG9nZ2luZy4gVGhlcmUgaXMgYSBzdGFuZGFyZCBzZXQgb2YgcHJlc3VtZWRcbi8vIGludGVyZXN0aW5nIG9iamVjdHMgaW4gbm9kZS5qcy1sYW5kLlxuXG5Mb2dnZXIuc3RkU2VyaWFsaXplcnMgPSB7fTtcblxuLypcbiAqIFRoaXMgZnVuY3Rpb24gZHVtcHMgbG9uZyBzdGFjayB0cmFjZXMgZm9yIGV4Y2VwdGlvbnMgaGF2aW5nIGEgY2F1c2UoKVxuICogbWV0aG9kLiBUaGUgZXJyb3IgY2xhc3NlcyBmcm9tXG4gKiBbdmVycm9yXShodHRwczovL2dpdGh1Yi5jb20vZGF2ZXBhY2hlY28vbm9kZS12ZXJyb3IpIGFuZFxuICogW3Jlc3RpZnkgdjIuMF0oaHR0cHM6Ly9naXRodWIuY29tL21jYXZhZ2Uvbm9kZS1yZXN0aWZ5KSBhcmUgZXhhbXBsZXMuXG4gKlxuICogQmFzZWQgb24gYGR1bXBFeGNlcHRpb25gIGluXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZGF2ZXBhY2hlY28vbm9kZS1leHRzcHJpbnRmL2Jsb2IvbWFzdGVyL2xpYi9leHRzcHJpbnRmLmpzXG4gKi9cbmZ1bmN0aW9uIGdldEZ1bGxFcnJvclN0YWNrKGV4KSB7XG4gICAgdmFyIHJldCA9IGV4LnN0YWNrIHx8IGV4LnRvU3RyaW5nKCk7XG4gICAgaWYgKGV4LmNhdXNlICYmIHR5cGVvZiAoZXguY2F1c2UpID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciBjZXggPSBleC5jYXVzZSgpO1xuICAgICAgICBpZiAoY2V4KSB7XG4gICAgICAgICAgICByZXQgKz0gJ1xcbkNhdXNlZCBieTogJyArIGdldEZ1bGxFcnJvclN0YWNrKGNleCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIChyZXQpO1xufVxuXG4vLyBTZXJpYWxpemUgYW4gRXJyb3Igb2JqZWN0XG4vLyAoQ29yZSBlcnJvciBwcm9wZXJ0aWVzIGFyZSBlbnVtZXJhYmxlIGluIG5vZGUgMC40LCBub3QgaW4gMC42KS5cbkxvZ2dlci5zdGRTZXJpYWxpemVycy5lcnIgPSBmdW5jdGlvbihlcnIpIHtcbiAgICBpZiAoIWVyciB8fCAhZXJyLnN0YWNrKSB7XG4gICAgICAgIHJldHVybiBlcnI7XG4gICAgfVxuXG4gICAgdmFyIG9iaiA9IHtcbiAgICAgICAgbWVzc2FnZTogZXJyLm1lc3NhZ2UsXG4gICAgICAgIG5hbWU6IGVyci5uYW1lLFxuICAgICAgICBzdGFjazogZ2V0RnVsbEVycm9yU3RhY2soZXJyKSxcbiAgICAgICAgY29kZTogZXJyLmNvZGUsXG4gICAgICAgIHNpZ25hbDogZXJyLnNpZ25hbFxuICAgIH07XG4gICAgcmV0dXJuIG9iajtcbn07XG5cblxuLy8gQSBKU09OIHN0cmluZ2lmaWVyIHRoYXQgaGFuZGxlcyBjeWNsZXMgc2FmZWx5LlxuLy8gVXNhZ2U6IEpTT04uc3RyaW5naWZ5KG9iaiwgc2FmZUN5Y2xlcygpKVxuZnVuY3Rpb24gc2FmZUN5Y2xlcygpIHtcbiAgICB2YXIgc2VlbiA9IFtdO1xuICAgIHJldHVybiBmdW5jdGlvbiAoa2V5LCB2YWwpIHtcbiAgICAgICAgaWYgKCF2YWwgfHwgdHlwZW9mICh2YWwpICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2Vlbi5pbmRleE9mKHZhbCkgIT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICAgICAgICB9XG4gICAgICAgIHNlZW4ucHVzaCh2YWwpO1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH07XG59XG5cbi8vLS0tLSBFeHBvcnRzXG5cbm1vZHVsZS5leHBvcnRzID0gTG9nZ2VyO1xuXG5tb2R1bGUuZXhwb3J0cy5UUkFDRSA9IFRSQUNFO1xubW9kdWxlLmV4cG9ydHMuREVCVUcgPSBERUJVRztcbm1vZHVsZS5leHBvcnRzLklORk8gPSBJTkZPO1xubW9kdWxlLmV4cG9ydHMuV0FSTiA9IFdBUk47XG5tb2R1bGUuZXhwb3J0cy5FUlJPUiA9IEVSUk9SO1xubW9kdWxlLmV4cG9ydHMuRkFUQUwgPSBGQVRBTDtcbm1vZHVsZS5leHBvcnRzLnJlc29sdmVMZXZlbCA9IHJlc29sdmVMZXZlbDtcbm1vZHVsZS5leHBvcnRzLmxldmVsRnJvbU5hbWUgPSBsZXZlbEZyb21OYW1lO1xubW9kdWxlLmV4cG9ydHMubmFtZUZyb21MZXZlbCA9IG5hbWVGcm9tTGV2ZWw7XG5cbm1vZHVsZS5leHBvcnRzLlZFUlNJT04gPSBWRVJTSU9OO1xubW9kdWxlLmV4cG9ydHMuTE9HX1ZFUlNJT04gPSBMT0dfVkVSU0lPTjtcblxubW9kdWxlLmV4cG9ydHMuY3JlYXRlTG9nZ2VyID0gZnVuY3Rpb24gY3JlYXRlTG9nZ2VyKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IExvZ2dlcihvcHRpb25zKTtcbn07XG5cbi8vIFVzZWZ1bCBmb3IgY3VzdG9tIGB0eXBlID09ICdyYXcnYCBzdHJlYW1zIHRoYXQgbWF5IGRvIEpTT04gc3RyaW5naWZpY2F0aW9uXG4vLyBvZiBsb2cgcmVjb3JkcyB0aGVtc2VsdmVzLiBVc2FnZTpcbi8vICAgIHZhciBzdHIgPSBKU09OLnN0cmluZ2lmeShyZWMsIGJ1bnlhbi5zYWZlQ3ljbGVzKCkpO1xubW9kdWxlLmV4cG9ydHMuc2FmZUN5Y2xlcyA9IHNhZmVDeWNsZXM7XG5cbi8vc3RyZWFtc1xubW9kdWxlLmV4cG9ydHMuQ29uc29sZUZvcm1hdHRlZFN0cmVhbSA9IENvbnNvbGVGb3JtYXR0ZWRTdHJlYW07XG5tb2R1bGUuZXhwb3J0cy5Db25zb2xlUmF3U3RyZWFtID0gQ29uc29sZVJhd1N0cmVhbTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9icm93c2VyLWJ1bnlhbi9saWIvYnVueWFuLmpzXG4gKiogbW9kdWxlIGlkID0gMzAxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCdcblxuaW1wb3J0IHsgbmFtZUZyb21MZXZlbCB9IGZyb20gJ2Jyb3dzZXItYnVueWFuJ1xuXG5leHBvcnQgY2xhc3MgUmF3U3RyZWFtIHtcbiAgd3JpdGUgKHJlYykge1xuICAgIGNvbnNvbGUubG9nKCdbJXNdICVzOiAlcycsXG4gICAgICAvLyAgICAgICAgICAgICAgICByZWMudGltZS50b0lTT1N0cmluZygpLFxuICAgICAgcmVjLm5hbWUsXG4gICAgICBuYW1lRnJvbUxldmVsW3JlYy5sZXZlbF0sXG4gICAgICByZWMubXNnXG4gICAgKVxuICB9XG59XG5cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL2pzL2xvZy9idW55YW4td3JpdGVyLmpzXG4gKiovIiwiZXhwb3J0IGNvbnN0IGNvbW1vbiA9IE9iamVjdC5mcmVlemUoe1xuICBDT05ORUNUX1NVQ0NFU1M6ICdDb25uZWN0LlN1Y2Nlc3MnLFxuICBDT05ORUNUX0ZBSUxVUkU6ICdDb25uZWN0LkZhaWx1cmUnLFxuICBQVUJMSVNIX1NUQVJUOiAnUHVibGlzaC5TdGFydCcsXG4gIFBVQkxJU0hfRkFJTDogJ1B1Ymxpc2guRmFpbCcsXG4gIFBVQkxJU0hfSU5WQUxJRF9OQU1FOiAnUHVibGlzaC5JbnZhbGlkTmFtZScsXG4gIFVOUFVCTElTSF9TVUNDRVNTOiAnVW5wdWJsaXNoLlN1Y2Nlc3MnXG59KVxuXG5leHBvcnQgY29uc3QgZmFpbG92ZXIgPSBPYmplY3QuZnJlZXplKHtcbiAgUFVCTElTSEVSX1JFSkVDVDogJ1B1Ymxpc2hlci5SZWplY3QnLFxuICBQVUJMSVNIRVJfQUNDRVBUOiAnUHVibGlzaGVyLkFjY2VwdCdcbn0pXG5cbmV4cG9ydCBjb25zdCBydGMgPSBPYmplY3QuZnJlZXplKHtcbiAgTUVESUFfU1RSRUFNX0FWQUlMQUJMRTogJ1dlYlJUQy5NZWRpYVN0cmVhbS5BdmFpbGFibGUnLFxuICBQRUVSX0NPTk5FQ1RJT05fQVZBSUxBQkxFOiAnV2ViUlRDLlBlZXJDb25uZWN0aW9uLkF2YWlsYWJsZScsXG4gIE9GRkVSX1NUQVJUOiAnV2ViUlRDLk9mZmVyLlN0YXJ0JyxcbiAgT0ZGRVJfRU5EOiAnV2ViUlRDLk9mZmVyLkVuZCcsXG4gIElDRV9UUklDS0xFX0NPTVBMRVRFOiAnV2ViUlRDLkljZVRyaWNrbGUuQ29tcGxldGUnXG59KVxuXG5leHBvcnQgY29uc3QgcnRtcCA9IE9iamVjdC5mcmVlemUoe1xuICBFTUJFRF9TVUNDRVNTOiAnRmxhc2hQbGF5ZXIuRW1iZWQuU3VjY2VzcycsXG4gIEVNQkVEX0ZBSUxVUkU6ICdGbGFzaFBsYXllci5FbWJlZC5GYWlsdXJlJ1xufSlcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL2pzL2V2ZW50L3B1Ymxpc2hlci1ldmVudC5qc1xuICoqLyIsImV4cG9ydCBjb25zdCBjb21tb24gPSBPYmplY3QuZnJlZXplKHtcbiAgQ09OTkVDVF9TVUNDRVNTOiAnQ29ubmVjdC5TdWNjZXNzJyxcbiAgQ09OTkVDVF9GQUlMVVJFOiAnQ29ubmVjdC5GYWlsdXJlJyxcbiAgU1VCU0NSSUJFX1NUQVJUOiAnU3Vic2NyaWJlLlN0YXJ0JyxcbiAgU1VCU0NSSUJFX1NUT1A6ICdTdWJzY3JpYmUuU3RvcCcsXG4gIFNVQlNDUklCRV9GQUlMOiAnU3Vic2NyaWJlLkZhaWwnLFxuICBTVUJTQ1JJQkVfSU5WQUxJRF9OQU1FOiAnU3Vic2NyaWJlLkludmFsaWROYW1lJ1xufSlcblxuZXhwb3J0IGNvbnN0IGZhaWxvdmVyID0gT2JqZWN0LmZyZWV6ZSh7XG4gIFNVQlNDUklCRVJfUkVKRUNUOiAnU3Vic2NyaWJlci5SZWplY3QnLFxuICBTVUJTQ1JJQkVSX0FDQ0VQVDogJ1N1YnNjcmliZXIuQWNjZXB0J1xufSlcblxuZXhwb3J0IGNvbnN0IHJ0YyA9IE9iamVjdC5mcmVlemUoe1xuICBQRUVSX0NPTk5FQ1RJT05fQVZBSUxBQkxFOiAnV2ViUlRDLlBlZXJDb25uZWN0aW9uLkF2YWlsYWJsZScsXG4gIE9GRkVSX1NUQVJUOiAnV2ViUlRDLk9mZmVyLlN0YXJ0JyxcbiAgT0ZGRVJfRU5EOiAnV2ViUlRDLk9mZmVyLkVuZCcsXG4gIEFOU1dFUl9TVEFSVDogJ1dlYlJUQy5BbnN3ZXIuU3RhcnQnLFxuICBBTlNXRVJfRU5EOiAnV2ViUlRDLkFuc3dlci5FbmQnLFxuICBDQU5ESURBVEVfU1RBUlQ6ICdXZWJSVEMuQ2FuZGlkYXRlLlN0YXJ0JyxcbiAgQ0FORElEQVRFX0VORDogJ1dlYlJUQy5DYW5kaWRhdGUuRW5kJyxcbiAgSUNFX1RSSUNLTEVfQ09NUExFVEU6ICdXZWJSVEMuSWNlVHJpY2tsZS5Db21wbGV0ZSdcbn0pXG5cbmV4cG9ydCBjb25zdCBydG1wID0gT2JqZWN0LmZyZWV6ZSh7XG4gIEVNQkVEX1NVQ0NFU1M6ICdGbGFzaFBsYXllci5FbWJlZC5TdWNjZXNzJyxcbiAgRU1CRURfRkFJTFVSRTogJ0ZsYXNoUGxheWVyLkVtYmVkLkZhaWx1cmUnXG59KVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvanMvZXZlbnQvc3Vic2NyaWJlci1ldmVudC5qc1xuICoqLyIsIi8qKlxuICogTWFpbiBlbnRyeSBmb3IgZmFpbG92ZXIgc3VwcG9ydCBvZiBhbGwgc3Vic2NyaWJlciBpbXBsZW1lbnRhdGlvbnMuXG4gKi9cbid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJy4uL2NvcmUvZXZlbnQtZW1pdHRlcidcbmltcG9ydCBSVENTdWJzY3JpYmVyIGZyb20gJy4vcmVkNXByby1ydGMnXG5pbXBvcnQgSExTU3Vic2NyaWJlciBmcm9tICcuL3JlZDVwcm8taGxzJ1xuaW1wb3J0IFJUTVBTdWJzY3JpYmVyUHJveHkgZnJvbSAnLi9yZWQ1cHJvLXJ0bXAnXG5pbXBvcnQgUjVMaXZlU3Vic2NyaWJlciBmcm9tICcuL3JlZDVwcm8tcnRtcC1saXZlJ1xuaW1wb3J0IFZpZGVvSlNTdWJzY3JpYmVyIGZyb20gJy4vcmVkNXByby1ydG1wLXZpZGVvanMnXG5cbmltcG9ydCBJbXBsRmFjdG9yeU9yZGVyIGZyb20gJy4uL3V0aWwvaW1wbC1mYWN0b3J5LW9yZGVyJ1xuaW1wb3J0IHsgRGVmZXJyZWRQcm9taXNlIH0gZnJvbSAnLi4vdXRpbC9wcm9taXNlJ1xuaW1wb3J0IHsgUGxheWJhY2tUeXBlcyB9IGZyb20gJy4uL2VudW0vcGxheWJhY2snXG5pbXBvcnQgeyBkZWJ1Zywgd2FybiB9IGZyb20gJy4uL2xvZydcblxuY29uc3QgTkFNRSA9ICdSNVByb1N1YnNjcmliZXInXG5jb25zdCBwbGF5YmFja0ZhY3RvcnkgPSBuZXcgSW1wbEZhY3RvcnlPcmRlcigpXG5cbmNvbnN0IHBsYXliYWNrSW1wbCA9IChmdW5jdGlvbiAoKSB7XG4gIGxldCBtYXAgPSBuZXcgTWFwKClcbiAgbWFwLnNldChQbGF5YmFja1R5cGVzLlJUTVAsIFJUTVBTdWJzY3JpYmVyUHJveHkpXG4gIG1hcC5zZXQoUGxheWJhY2tUeXBlcy5SVEMsIFJUQ1N1YnNjcmliZXIpXG4gIG1hcC5zZXQoUGxheWJhY2tUeXBlcy5ITFMsIEhMU1N1YnNjcmliZXIpXG4gIHJldHVybiBtYXBcbn0oKSlcblxuY2xhc3MgUmVkNVByb1N1YnNjcmliZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuXG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBzdXBlcigpXG4gICAgLy8gQ29uZmlndXJhdGlvbiBvcHRpb25zXG4gICAgdGhpcy5fb3B0aW9ucyA9IHVuZGVmaW5lZFxuICAgIC8vIFRoZSBwbGF5YmFjayB2aWV3XG4gICAgdGhpcy5fdmlldyA9IHVuZGVmaW5lZFxuICAgIC8vIFNlbGVjdGVkIGZhaWxvdmVyIHN1YnNjcmliZXIuXG4gICAgdGhpcy5fY3VycmVudFN1YnNjcmliZXIgPSB1bmRlZmluZWRcbiAgICAvLyBEZWZhdWx0IG9yZGVyLlxuICAgIHRoaXMuX29yZGVyID0gW1xuICAgICAgUGxheWJhY2tUeXBlcy5SVE1QLFxuICAgICAgUGxheWJhY2tUeXBlcy5SVEMsXG4gICAgICBQbGF5YmFja1R5cGVzLkhMU1xuICAgIF1cbiAgICB0aGlzLl9ib3VuZEJ1YmJsZVN1YnNjcmliZXJFdmVudCA9IHRoaXMuYnViYmxlU3Vic2NyaWJlckV2ZW50LmJpbmQodGhpcylcbiAgfVxuXG4gIGdldFBsYXliYWNrT3JkZXIgKCkge1xuICAgIHJldHVybiB0aGlzLl9vcmRlclxuICB9XG5cbiAgc2V0UGxheWJhY2tPcmRlciAob3JkZXIpIHtcbiAgICAvLyBBbGxvdyBmb3Igc3RyaW5nIHZhbHVlIHRvIGRlZmluZSBzaW5nbGUgaXRlbSBpbiBvcmRlci5cbiAgICBvcmRlciA9IHR5cGVvZiBvcmRlciA9PT0gJ3N0cmluZycgPyBbb3JkZXJdIDogb3JkZXJcblxuICAgIC8vIEZpbHRlciBvdXQgdmFsdWVzIG5vdCBhdmFpbGFibGUgaW4gZW51bWVyYXRpb24gb2YgcGxheWJhY2sgdHlwZXMuXG4gICAgY29uc3QgdCA9IG9yZGVyLmZpbHRlcihlbnRyeSA9PiB7XG4gICAgICBsZXQga2V5XG4gICAgICBmb3IgKGtleSBpbiBQbGF5YmFja1R5cGVzKSB7XG4gICAgICAgIGlmIChQbGF5YmFja1R5cGVzW2tleV0udG9Mb3dlckNhc2UoKSA9PT0gZW50cnkudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH0pLm1hcChlbnRyeSA9PiBlbnRyeS50b0xvd2VyQ2FzZSgpKVxuXG4gICAgLy8gRGVmaW5lIG5ldyBvcmRlci5cbiAgICB0aGlzLl9vcmRlciA9IFsuLi5uZXcgU2V0KHQpXVxuICAgIGRlYnVnKE5BTUUsIGBbb3JkZXJ1cGRhdGVdOiAke3RoaXMuX29yZGVyfWApXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHNldFZpZXcgKHBsYXliYWNrVmlldykge1xuICAgIHRoaXMuX3ZpZXcgPSBwbGF5YmFja1ZpZXdcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgZ2V0UGxheWJhY2tGcm9tT3JkZXIgKG9yZGVyLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHBsYXliYWNrRmFjdG9yeS5jcmVhdGUob3JkZXIsIHBsYXliYWNrSW1wbCwgb3B0aW9ucywgJ2luaXQnKVxuICB9XG5cbiAgaW5pdCAob3B0aW9ucykge1xuICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zXG4gICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWRQcm9taXNlKClcbiAgICBkZWJ1ZyhOQU1FLCAnW3BsYXldJylcbiAgICB0aGlzLmdldFBsYXliYWNrRnJvbU9yZGVyKHRoaXMuX29yZGVyLCB0aGlzLl9vcHRpb25zKVxuICAgICAgLnRoZW4oc3Vic2NyaWJlciA9PiB7XG4gICAgICAgIGRlYnVnKE5BTUUsIGBbcGxheXN1Y2Nlc3NdOiBzdWJzY3JpYmVyIGZvdW5kICR7c3Vic2NyaWJlci5nZXRUeXBlKCl9YClcbiAgICAgICAgc3Vic2NyaWJlci5vbignKicsIHRoaXMuX2JvdW5kQnViYmxlU3Vic2NyaWJlckV2ZW50KVxuICAgICAgICB0aGlzLl9jdXJyZW50U3Vic2NyaWJlciA9IHN1YnNjcmliZXJcbiAgICAgICAgdGhpcy5fY3VycmVudFN1YnNjcmliZXIuc2V0Vmlldyh0aGlzLl92aWV3KVxuICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHRoaXMuX2N1cnJlbnRTdWJzY3JpYmVyKVxuICAgICAgfSlcbiAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICB3YXJuKE5BTUUsIGBbcGxheWVycm9yXTogQ291bGQgbm90IGltcGxlbWVudCBhIHN1YnNjcmliZXI6ICR7ZXJyfWApXG4gICAgICAgIGRlZmVycmVkLnJlamVjdChlcnIpXG4gICAgICB9KVxuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlXG4gIH1cblxuICBzdG9wICgpIHtcbiAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZFByb21pc2UoKVxuICAgIGlmICghdGhpcy5fY3VycmVudFN1YnNjcmliZXIpIHtcbiAgICAgIHdhcm4oTkFNRSwgJ1tzdG9wXTogQ291bGQgbm90IGludm9rZSBzdG9wKCkgb24gdW5kZWZpbmVkIHN1YnNjcmliZXIuJylcbiAgICAgIGRlZmVycmVkLnJlamVjdCgnQSBjdXJyZW50IHN1YnNjcmliZXIgaXMgbm90IGF2YWlsYWJsZSB0byBpc3N1ZSBhIDpzdG9wKCkgY29tbWFuZCB0by4nKVxuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1ZyhOQU1FLCAnW3N0b3BdOiBJbnZva2luZyBzdG9wIG9uIGhlbGQgc3Vic2NyaWJlci4nKVxuICAgICAgdGhpcy5fY3VycmVudFN1YnNjcmliZXIuc3RvcCgpXG4gICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICBkZWJ1ZyhOQU1FLCAnW3N0b3BzdWNjZXNzXScpXG4gICAgICAgICAgdGhpcy5fY3VycmVudFN1YnNjcmliZXIub2ZmKCcqJywgdGhpcy5fYm91bmRCdWJibGVTdWJzY3JpYmVyRXZlbnQpXG4gICAgICAgICAgdGhpcy5fY3VycmVudFN1YnNjcmliZXIgPSB1bmRlZmluZWRcbiAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKClcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgZGVidWcoTkFNRSwgYFtzdG9wZXJyb3JdOiAke2Vycn1gKVxuICAgICAgICAgIGlmICh0aGlzLl9jdXJyZW50U3Vic2NyaWJlcikge1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudFN1YnNjcmliZXIub2ZmKCcqJywgdGhpcy5fYm91bmRCdWJibGVTdWJzY3JpYmVyRXZlbnQpXG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX2N1cnJlbnRTdWJzY3JpYmVyID0gdW5kZWZpbmVkXG4gICAgICAgICAgZGVmZXJyZWQucmVqZWN0KGVycilcbiAgICAgICAgfSlcbiAgICB9XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2VcbiAgfVxuXG4gIGJ1YmJsZVN1YnNjcmliZXJFdmVudCAoc3Vic2NyaWJlckV2ZW50KSB7XG4gICAgdGhpcy50cmlnZ2VyLmNhbGwodGhpcywgc3Vic2NyaWJlckV2ZW50KVxuICB9XG5cbiAgZ2V0IHBsYXliYWNrVHlwZXMgKCkge1xuICAgIHJldHVybiBQbGF5YmFja1R5cGVzXG4gIH1cblxuICBnZXQgY3VycmVudFN1YnNjcmliZXIgKCkge1xuICAgIHJldHVybiB0aGlzLl9jdXJyZW50U3Vic2NyaWJlclxuICB9XG5cbn1cblxuZXhwb3J0IHsgUmVkNVByb1N1YnNjcmliZXIsIFJUQ1N1YnNjcmliZXIsIEhMU1N1YnNjcmliZXIsIFZpZGVvSlNTdWJzY3JpYmVyLCBSNUxpdmVTdWJzY3JpYmVyIH1cbi8qKlxuICogVXNpbmcgdGhlIFJUTVBTdWJzY3JpYmVyIHdpbGwgZGV0ZXJtaW5lIHRoZSBSVE1QLWJhc2VkIFN1YnNjcmliZXJcbiAqIHRvIGJlIHVzZWQgYmFzZWQgb24gYG9wdGlvbnMudXNlVmlkZW9KU2AgcHJvcGVydHkuXG4gKlxuICogSWYgYG9wdGlvbnMudXNlVmlkZW9KU2AgaXMgbGVmdCB1bmRlZmluZWQsIGl0IHdpbGwgZGVmYXVsdCB0byBgdHJ1ZWBcbiAqIElmIGBvcHRpb25zLnVzZVZpZGVvSnNgIGlzIGRlZmluZWQsIGl0IGlzIHJlcXVpcmVkIHRvIGJlIGEgYm9vbGVhbiB2YWx1ZVxuICpcbiAqIHRydWU6IFZpZGVvSlNTdWJzY3JpYmVyIC0gdXRpbGl6ZXMgdGhlIHZpZGVvanMgbGliIGFuZCBjdXN0b20gU1dGLlxuICogZmFsc2U6IFI1TGl2ZVN1YnNjcmliZXIgLSB1dGlsaXplZCB0aGUgZGVmYXVsdCBcImxpdmVcIiBTV0Ygc2hpcHBlZCB3aXRoIFJlZDUgUHJvIGV4YW1wbGVzLlxuKi9cbmV4cG9ydCBjb25zdCBSVE1QU3Vic2NyaWJlciA9IFJUTVBTdWJzY3JpYmVyUHJveHlcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL2pzL3N1YnNjcmliZXIvaW5kZXguanNcbiAqKi8iLCJjb25zdCBXSUxEQ0FSRCA9ICcqJ1xuY29uc3QgV0lMRENBUkRfS0VZID0gJ1JFRDVQUk8nXG5cbmNsYXNzIEV2ZW50RW1pdHRlciB7XG5cbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHRoaXMuX2NhbGxiYWNrcyA9IHt9XG4gICAgdGhpcy5fY2FsbGJhY2tzW1dJTERDQVJEX0tFWV0gPSBbXVxuICB9XG5cbiAgX25vdGlmeSAoY2FsbGJhY2tzLCBldmVudCkge1xuICAgICAgbGV0IGksIGxlbmd0aCA9IGNhbGxiYWNrcy5sZW5ndGhcbiAgICAgIGZvcihpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNhbGxiYWNrc1tpXShldmVudClcbiAgICAgIH1cbiAgfVxuXG4gIG9uICh0eXBlLCBmbikge1xuICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICh0eXBlID09PSBXSUxEQ0FSRCkge1xuICAgICAgdGhpcy5fY2FsbGJhY2tzW1dJTERDQVJEX0tFWV0ucHVzaChmbilcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICh0aGlzLl9jYWxsYmFja3NbdHlwZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fY2FsbGJhY2tzW3R5cGVdID0gW11cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fY2FsbGJhY2tzW3R5cGVdLmluZGV4T2YoZm4pID09PSAtMSkge1xuICAgICAgdGhpcy5fY2FsbGJhY2tzW3R5cGVdLnB1c2goZm4pXG4gICAgfVxuICB9XG5cbiAgb2ZmICh0eXBlLCBmbikge1xuICAgIGxldCBtYXAgPSB0aGlzLl9jYWxsYmFja3NbdHlwZV1cbiAgICBpZiAodHlwZSA9PT0gV0lMRENBUkQpIHtcbiAgICAgIG1hcCA9IHRoaXMuX2NhbGxiYWNrc1tXSUxEQ0FSRF9LRVldXG4gICAgfVxuICAgIGlmIChtYXApIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gbWFwLmluZGV4T2YoZm4pXG4gICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgIG1hcC5zcGxpY2UoaW5kZXgsIDEpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdHJpZ2dlciAoZXZlbnQpIHtcbiAgICBjb25zdCB0eXBlID0gZXZlbnQudHlwZVxuICAgIGlmICh0aGlzLl9jYWxsYmFja3NbdHlwZV0pIHtcbiAgICAgIHRoaXMuX25vdGlmeSh0aGlzLl9jYWxsYmFja3NbdHlwZV0sIGV2ZW50KVxuICAgIH1cbiAgICB0aGlzLl9ub3RpZnkodGhpcy5fY2FsbGJhY2tzW1dJTERDQVJEX0tFWV0sIGV2ZW50KVxuICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgRXZlbnRFbWl0dGVyXG5cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL2pzL2NvcmUvZXZlbnQtZW1pdHRlci5qc1xuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJy4uL2NvcmUvZXZlbnQtZW1pdHRlcidcbmltcG9ydCB7IFN1YnNjcmliZXJFdmVudCB9IGZyb20gJy4uL2V2ZW50J1xuaW1wb3J0IFN1YnNjcmlwdGlvblNvY2tldEhlbHBlciBmcm9tICcuLi9oZWxwZXIvc29ja2V0LWhlbHBlci1zdWInXG5pbXBvcnQgU3Vic2NyaXB0aW9uUGVlckhlbHBlciBmcm9tICcuLi9oZWxwZXIvd2VicnRjLWhlbHBlci1zdWInXG5pbXBvcnQgeyBEZWZlcnJlZFByb21pc2UgfSBmcm9tICcuLi91dGlsL3Byb21pc2UnXG5pbXBvcnQgKiBhcyB3ZWJydGMgZnJvbSAnLi4vYWRhcHRlci93ZWJydGMnXG5pbXBvcnQgKiBhcyB3ZWJzb2NrZXQgZnJvbSAnLi4vYWRhcHRlci93ZWJzb2NrZXQnXG5pbXBvcnQgeyBTdWJzY3JpYmVyRXZlbnRUeXBlcywgUlRDU3Vic2NyaWJlckV2ZW50VHlwZXMgfSBmcm9tICcuLi9ldmVudCdcblxuaW1wb3J0IHsgZGVidWcsIHdhcm4sIGVycm9yIH0gZnJvbSAnLi4vbG9nJ1xuXG5jb25zdCBOQU1FID0gJ1I1UHJvUlRDU3Vic2NyaWJlcidcbmNvbnN0IGRlZmF1bHRTdHJlYW1UeXBlID0gJ3dlYnJ0YydcbmNvbnN0IGdlbmVyYXRlU3Vic2NyaXB0aW9uSWQgPSAoKSA9PiB7XG4gIGNvbnN0IGlkID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMHgxMDAwMCkudG9TdHJpbmcoMTYpXG4gIHJldHVybiBgc3Vic2NyaWJlci0ke2lkfWBcbn1cbmNvbnN0IGVuZHBvaW50RnJvbU9wdGlvbnMgPSAob3B0aW9ucykgPT4ge1xuICBjb25zdCBwcm90b2NvbCA9IG9wdGlvbnMud3Nwcm90b2NvbCB8fCBvcHRpb25zLnByb3RvY29sXG4gIGNvbnN0IHBvcnQgPSBvcHRpb25zLndzcG9ydCB8fCBvcHRpb25zLnBvcnRcbiAgY29uc3QgYXBwRW5kcG9pbnQgPSBvcHRpb25zLmNvbnRleHQgPyBbb3B0aW9ucy5hcHAsIG9wdGlvbnMuY29udGV4dF0uam9pbignLycpIDogb3B0aW9ucy5hcHBcbiAgcmV0dXJuIGAke3Byb3RvY29sfTovLyR7b3B0aW9ucy5ob3N0fToke3BvcnR9LyR7YXBwRW5kcG9pbnR9P2lkPSR7b3B0aW9ucy5zdWJzY3JpcHRpb25JZH1gXG59XG5cbmNsYXNzIFJUQ1N1YnNjcmliZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuXG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5fdmlldyA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX29wdGlvbnMgPSB1bmRlZmluZWRcbiAgICB0aGlzLl9wZWVySGVscGVyID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fc29ja2V0SGVscGVyID0gdW5kZWZpbmVkXG4gIH1cblxuICBpbml0IChvcHRpb25zKSB7XG4gICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWRQcm9taXNlKClcbiAgICBpZiAoIXdlYnJ0Yy5pc1N1cHBvcnRlZCgpIHx8ICF3ZWJzb2NrZXQuaXNTdXBwb3J0ZWQoKSkge1xuICAgICAgZGVmZXJyZWQucmVqZWN0KCdDYW5ub3QgY3JlYXRlIFdlYlJUQyBwbGF5YmFjayBpbnN0YW5jZS4gWW91ciBlbnZpcm9ubWVudCBkb2VzIG5vdCBzdXBwb3J0IFdlYlJUQyBhbmQvb3IgV2ViU29ja2V0cy4nKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9uc1xuICAgICAgdGhpcy5fb3B0aW9ucy5zdWJzY3JpcHRpb25JZCA9IHRoaXMuX29wdGlvbnMuc3Vic2NyaXB0aW9uSWQgfHwgZ2VuZXJhdGVTdWJzY3JpcHRpb25JZCgpXG4gICAgICB0aGlzLl9wZWVySGVscGVyID0gbmV3IFN1YnNjcmlwdGlvblBlZXJIZWxwZXIodGhpcylcbiAgICAgIHRoaXMuX3NvY2tldEhlbHBlciA9IG5ldyBTdWJzY3JpcHRpb25Tb2NrZXRIZWxwZXIodGhpcylcbiAgICAgIGRlZmVycmVkLnJlc29sdmUodGhpcylcbiAgICB9XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2VcbiAgfVxuXG4gIHNldFZpZXcgKHZpZXcpIHtcbiAgICB0aGlzLl92aWV3ID0gdmlld1xuICAgIC8vICBUT0RPOiBOb3JtYWxpemUgcmV0dXJucyB0byBlaXRoZXIgYWxsIGJlIGNoYWluYWJsZSBvciBub3QgYmUgY2hhaW5hYmxlXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHJlcXVlc3RBdmFpbGFiaWxpdHkgKHN0cmVhbU5hbWUsIHR5cGUpIHtcbiAgICBkZWJ1ZyhOQU1FLCAnW3JlcXVlc3RhdmFpbGFiaWxpdHldJylcbiAgICAvLyBtZXNzYWdlIG9uIHNvY2tldCByZXR1cm5zIC0+IG9uU3RyZWFtKFVuKUF2YWlsYWJsZVxuICAgIHRoaXMuX3NvY2tldEhlbHBlci5wb3N0KHtcbiAgICAgIGlzQXZhaWxhYmxlOiBzdHJlYW1OYW1lLFxuICAgICAgdHlwZTogdHlwZVxuICAgIH0pXG4gICAgLy8gIFRPRE86IE5vcm1hbGl6ZSByZXR1cm5zIHRvIGVpdGhlciBhbGwgYmUgY2hhaW5hYmxlIG9yIG5vdCBiZSBjaGFpbmFibGVcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgcmVxdWVzdE9mZmVyIChzdHJlYW1OYW1lLCBzdWJzY3JpcHRpb25JZCkge1xuICAgIGRlYnVnKE5BTUUsICdbcmVxdWVzdG9mZmVyXScpXG4gICAgdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoUlRDU3Vic2NyaWJlckV2ZW50VHlwZXMuT0ZGRVJfU1RBUlQsIHRoaXMpKVxuICAgIC8vIG1lc3NhZ2Ugb24gc29ja2V0IHJldHVybnMgLT4gb25TRFBPZmZlclxuICAgIHRoaXMuX3NvY2tldEhlbHBlci5wb3N0KHtcbiAgICAgIHJlcXVlc3RPZmZlcjogc3RyZWFtTmFtZSxcbiAgICAgIHJlcXVlc3RJZDogc3Vic2NyaXB0aW9uSWRcbiAgICB9KVxuICB9XG5cbiAgcmVxdWVzdEFuc3dlciAoc2RwKSB7XG4gICAgZGVidWcoTkFNRSwgJ1tyZXF1ZXN0YW5zd2VyXScpXG4gICAgLy8gaW52b2tlcyAtPiBzZW5kQW5zd2VyXG4gICAgdGhpcy5fcGVlckhlbHBlci5jcmVhdGVBbnN3ZXIoc2RwKVxuICAgICAgICAudGhlbihzZXNzaW9uRGVzY3JpcHRpb24gPT4ge1xuICAgICAgICAgIGRlYnVnKE5BTUUsICdbb25hbnN3ZXJjcmVhdGVkXScpXG4gICAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMuYmFuZHdpZHRoKSB7XG4gICAgICAgICAgICBzZXNzaW9uRGVzY3JpcHRpb24uc2RwID0gd2VicnRjLnVwZGF0ZUJhbmR3aWR0aCh0aGlzLl9vcHRpb25zLmJhbmR3aWR0aCwgc2Vzc2lvbkRlc2NyaXB0aW9uLnNkcClcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVidWcoTkFNRSwgJ1s+IHNlbmRhbnN3ZXJdJylcbiAgICAgICAgICB0aGlzLnNlbmRBbnN3ZXIodGhpcy5fb3B0aW9ucy5zdHJlYW1OYW1lLCB0aGlzLl9vcHRpb25zLnN1YnNjcmlwdGlvbklkLCBzZXNzaW9uRGVzY3JpcHRpb24pXG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaCh0aGlzLm9uU0RQRXJyb3IpXG4gIH1cblxuICBzZW5kQW5zd2VyIChzdHJlYW1OYW1lLCBzdWJzY3JpcHRpb25JZCwgc2RwKSB7XG4gICAgZGVidWcoTkFNRSwgYFtzZW5kYW5zd2VyXTogc3RyZWFtbmFtZSgke3N0cmVhbU5hbWV9KSwgc3Vic2NyaXB0aW9uaWQoJHtzdWJzY3JpcHRpb25JZH0pYClcbiAgICB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChSVENTdWJzY3JpYmVyRXZlbnRUeXBlcy5BTlNXRVJfU1RBUlQsIHRoaXMsIHNkcCkpXG4gICAgLy8gbWVzc2FnZSBvbiBzb2NrZXQgcmVzcG9uc2UgLT4gb25BZGRJY2VDYW5kaWRhdGVcbiAgICAvLyBtZXNzYWdlIG9uIHBlZXIgcmVzcG9uc2UgLT4gb25hZGRzdHJlYW1cbiAgICB0aGlzLl9zb2NrZXRIZWxwZXIucG9zdCh7XG4gICAgICBoYW5kbGVBbnN3ZXI6IHN0cmVhbU5hbWUsXG4gICAgICByZXF1ZXN0SWQ6IHN1YnNjcmlwdGlvbklkLFxuICAgICAgZGF0YToge1xuICAgICAgICBzZHA6IHNkcFxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBzZW5kQ2FuZGlkYXRlIChjYW5kaWRhdGUpIHtcbiAgICBkZWJ1ZyhOQU1FLCAnW3NlbmRjYW5kaWRhdGVdJylcbiAgICB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChSVENTdWJzY3JpYmVyRXZlbnRUeXBlcy5DQU5ESURBVEVfU1RBUlQsIHRoaXMsIGNhbmRpZGF0ZSkpXG4gICAgLy8gbWVzc2FnZSBvbiBwZWVyIHJlc3BvbnNlIC0+IG9uaWNlY2FuZGlkYXRlXG4gICAgdGhpcy5fc29ja2V0SGVscGVyLnBvc3Qoe1xuICAgICAgaGFuZGxlQ2FuZGlkYXRlOiB0aGlzLl9vcHRpb25zLnN0cmVhbU5hbWUsXG4gICAgICByZXF1ZXN0SWQ6IHRoaXMuX29wdGlvbnMuc3Vic2NyaXB0aW9uSWQsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGNhbmRpZGF0ZTogY2FuZGlkYXRlXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHNlbmRTdWJzY3JpYmUgKCkge1xuICAgIGRlYnVnKE5BTUUsICdbc2VuZHN1YnNjcmliZV0nKVxuICAgIHRoaXMuX3NvY2tldEhlbHBlci5wb3N0KHtcbiAgICAgIHN1YnNjcmliZTogdGhpcy5fb3B0aW9ucy5zdHJlYW1OYW1lLFxuICAgICAgcmVxdWVzdElkOiB0aGlzLl9vcHRpb25zLnN1YnNjcmlwdGlvbklkXG4gICAgfSlcbiAgfVxuXG4gIG9uU3RyZWFtQXZhaWxhYmxlIChyZWNlaXB0KSB7XG4gICAgZGVidWcoTkFNRSwgJ1tvbnN0cmVhbWF2YWlsYWJsZV06ICcgKyBKU09OLnN0cmluZ2lmeShyZWNlaXB0LCBudWxsLCAyKSlcbiAgICB0aGlzLl9jb25uZWN0KHRoaXMuX29wdGlvbnMuaWNlU2VydmVycylcbiAgfVxuXG4gIG9uU3RyZWFtVW5hdmFpbGFibGUgKHJlY2VpcHQpIHtcbiAgICBkZWJ1ZyhOQU1FLCBgU3RyZWFtICR7dGhpcy5fb3B0aW9ucy5zdHJlYW1OYW1lfSBkb2VzIG5vdCBleGlzdC5gKVxuICAgIGRlYnVnKE5BTUUsICdbb25zdHJlYW11bmF2YWlsYWJsZV06ICcgKyBKU09OLnN0cmluZ2lmeShyZWNlaXB0LCBudWxsLCAyKSlcbiAgICB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChTdWJzY3JpYmVyRXZlbnRUeXBlcy5TVUJTQ1JJQkVfSU5WQUxJRF9OQU1FLCB0aGlzKSlcbiAgICB0aGlzLl9kaXNjb25uZWN0KClcbiAgfVxuXG4gIG9uU0RQU3VjY2VzcyAocmVjZWlwdCkge1xuICAgIGRlYnVnKE5BTUUsICdbb25zZHBzdWNjZXNzXTogJyArIEpTT04uc3RyaW5naWZ5KHJlY2VpcHQsIG51bGwsIDIpKVxuICB9XG5cbiAgb25TRFBPZmZlciAocmVjZWlwdCkge1xuICAgIGRlYnVnKE5BTUUsICdbb25zZHBvZmZlcl06ICcgKyBKU09OLnN0cmluZ2lmeShyZWNlaXB0LCBudWxsLCAyKSlcbiAgICBjb25zdCBzZHAgPSBuZXcgd2VicnRjLlJUQ1Nlc3Npb25EZXNjcmlwdGlvbihyZWNlaXB0LnNkcClcbiAgICB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChSVENTdWJzY3JpYmVyRXZlbnRUeXBlcy5PRkZFUl9FTkQsIHRoaXMpKVxuICAgIHRoaXMucmVxdWVzdEFuc3dlcihzZHApXG4gIH1cblxuICBvblNEUEVycm9yIChyZWNlaXB0KSB7XG4gICAgZXJyb3IoTkFNRSwgJ1tvbnNkcGVycm9yXTogJyArIEpTT04uc3RyaW5naWZ5KHJlY2VpcHQsIG51bGwsIDIpKVxuICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFN1YnNjcmliZXJFdmVudFR5cGVzLlNVQlNDUklCRV9GQUlMLCB0aGlzLCByZWNlaXB0KSlcbiAgfVxuXG4gIG9uQW5zd2VyTWVkaWFTdHJlYW0gKHN0cmVhbSA9IHVuZGVmaW5lZCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoUlRDU3Vic2NyaWJlckV2ZW50VHlwZXMuQU5TV0VSX0VORCwgdGhpcykpXG4gIH1cblxuICBvbkljZUNhbmRpZGF0ZSAoY2FuZGlkYXRlKSB7XG4gICAgZGVidWcoTkFNRSwgJ1tvbmljZWNhbmRpZGF0ZV0nKVxuICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFJUQ1N1YnNjcmliZXJFdmVudFR5cGVzLkNBTkRJREFURV9FTkQsIHRoaXMpKVxuICAgIHRoaXMuc2VuZENhbmRpZGF0ZShjYW5kaWRhdGUpXG4gIH1cblxuICBvbkljZUNhbmRpZGF0ZVRyaWNrbGVFbmQgKHN0cmVhbSkge1xuICAgIGRlYnVnKE5BTUUsICdbb25pY2V0cmlja2xlZW5kXScpXG4gICAgdGhpcy5fdmlldy5hdHRhY2hTdHJlYW0oc3RyZWFtLCB0aGlzLl9vcHRpb25zLmF1dG9wbGF5IHx8IHRydWUpXG4gICAgdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoU3Vic2NyaWJlckV2ZW50VHlwZXMuU1VCU0NSSUJFX1NUQVJULCB0aGlzKSlcbiAgfVxuXG4gIG9uQWRkSWNlQ2FuZGlkYXRlIChjYW5kaWRhdGUpIHtcbiAgICBkZWJ1ZyhOQU1FLCAnW29uYWRkaWNlY2FuZGlkYXRlXScpXG4gICAgdGhpcy5fcGVlckhlbHBlci5hZGRJY2VDYW5kaWRhdGUoY2FuZGlkYXRlKVxuICB9XG5cbiAgb25Tb2NrZXRJY2VDYW5kaWRhdGVFbmQgKCkge1xuICAgIGRlYnVnKE5BTUUsICdbb25zb2NrZXRpY2VjYW5kaWRhdGVlbmRdJylcbiAgICB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChSVENTdWJzY3JpYmVyRXZlbnRUeXBlcy5JQ0VfVFJJQ0tMRV9DT01QTEVURSwgdGhpcykpXG4gICAgdGhpcy5zZW5kU3Vic2NyaWJlKClcbiAgfVxuXG4gIG9uU29ja2V0TWVzc2FnZUVycm9yIChtZXNzYWdlLCBkZXRhaWwgPSB1bmRlZmluZWQpIHtcbiAgICBlcnJvcihOQU1FLCBgRXJyb3IgaW4gc3RyZWFtIHN1YnNjcmlwdGlvbjogJHttZXNzYWdlfS5cXG5bT3B0aW9uYWwgZGV0YWlsXTogJHtkZXRhaWx9YClcbiAgICB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChTdWJzY3JpYmVyRXZlbnRUeXBlcy5TVUJTQ1JJQkVfRkFJTCwgdGhpcywgbWVzc2FnZSkpXG4gIH1cblxuICBfZGlzY29ubmVjdCAoKSB7XG4gICAgZGVidWcoTkFNRSwgJ1tkaXNjb25uZWN0XScpXG4gICAgaWYgKHRoaXMuX3NvY2tldEhlbHBlcikge1xuICAgICAgdGhpcy5fc29ja2V0SGVscGVyLnRlYXJEb3duKClcbiAgICB9XG4gICAgaWYgKHRoaXMuX3BlZXJIZWxwZXIpIHtcbiAgICAgIHRoaXMuX3BlZXJIZWxwZXIudGVhckRvd24oKVxuICAgIH1cbiAgfVxuXG4gIF9jb25uZWN0IChpY2VTZXJ2ZXJzKSB7XG4gICAgZGVidWcoTkFNRSwgJ1tjb25uZWN0XScpXG4gICAgdGhpcy5fb3B0aW9ucy5pY2VTZXJ2ZXJzID0gaWNlU2VydmVyc1xuICAgIGNvbnN0IHAgPSB0aGlzLl9wZWVySGVscGVyLnNldFVwKHRoaXMuX29wdGlvbnMuaWNlU2VydmVycylcbiAgICBwLnRoZW4oKCkgPT4ge1xuICAgICAgdGhpcy5yZXF1ZXN0T2ZmZXIodGhpcy5fb3B0aW9ucy5zdHJlYW1OYW1lLCB0aGlzLl9vcHRpb25zLnN1YnNjcmlwdGlvbklkKVxuICAgIH0pXG4gICAgLmNhdGNoKCgpID0+IHtcbiAgICAgIHdhcm4oTkFNRSwgJ0NvdWxkIG5vdCBlc3RhYmxpc2ggUlRDUGVlckNvbm5lY3Rpb24uJylcbiAgICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFN1YnNjcmliZXJFdmVudFR5cGVzLkNPTk5FQ1RfRkFJTFVSRSwgdGhpcykpXG4gICAgfSlcbiAgICAvLyAgVE9ETzogTm9ybWFsaXplIHJldHVybnMgdG8gZWl0aGVyIGFsbCBiZSBjaGFpbmFibGUgb3Igbm90IGJlIGNoYWluYWJsZVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBwbGF5IChzdHJlYW1OYW1lID0gbnVsbCwgcHJvbWlzZSA9IG51bGwpIHtcbiAgICBkZWJ1ZyhOQU1FLCAnW3BsYXldJylcbiAgICB0aGlzLl9vcHRpb25zLnN0cmVhbU5hbWUgPSBzdHJlYW1OYW1lIHx8IHRoaXMuX29wdGlvbnMuc3RyZWFtTmFtZVxuICAgIGNvbnN0IHAgPSBwcm9taXNlIHx8IG5ldyBEZWZlcnJlZFByb21pc2UoKVxuICAgIGNvbnN0IHNvY2tldFByb21pc2UgPSBuZXcgRGVmZXJyZWRQcm9taXNlKClcbiAgICBjb25zdCBzb2NrZXR1cmwgPSBlbmRwb2ludEZyb21PcHRpb25zKHRoaXMuX29wdGlvbnMpXG4gICAgdGhpcy5fc29ja2V0SGVscGVyLnNldFVwKHNvY2tldHVybCwgc29ja2V0UHJvbWlzZSlcbiAgICBzb2NrZXRQcm9taXNlLnByb21pc2VcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgcC5yZXNvbHZlKHRoaXMpXG4gICAgICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFN1YnNjcmliZXJFdmVudFR5cGVzLkNPTk5FQ1RfU1VDQ0VTUywgdGhpcykpXG4gICAgICAgIHRoaXMucmVxdWVzdEF2YWlsYWJpbGl0eSh0aGlzLl9vcHRpb25zLnN0cmVhbU5hbWUsIHRoaXMuX29wdGlvbnMuc3RyZWFtVHlwZSB8fCBkZWZhdWx0U3RyZWFtVHlwZSlcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgIHAucmVqZWN0KGVycm9yKVxuICAgICAgICB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChTdWJzY3JpYmVyRXZlbnRUeXBlcy5DT05ORUNUX0ZBSUxVUkUsIHRoaXMsIGVycm9yKSlcbiAgICAgIH0pXG4gICAgcmV0dXJuIHAuaGFzT3duUHJvcGVydHkoJ3Byb21pc2UnKSA/IHAucHJvbWlzZSA6IHBcbiAgfVxuXG4gIHN0b3AgKCkge1xuICAgIGRlYnVnKE5BTUUsICdbc3RvcF0nKVxuICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkUHJvbWlzZSgpXG4gICAgdGhpcy5fZGlzY29ubmVjdCgpXG4gICAgdGhpcy5fdmlldy5zdG9wKClcbiAgICBkZWZlcnJlZC5yZXNvbHZlKHRoaXMpXG4gICAgdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoU3Vic2NyaWJlckV2ZW50VHlwZXMuVU5TVUJTQ1JJQkVfU1VDQ0VTUywgdGhpcykpXG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2VcbiAgfVxuXG4gIGdldFBlZXJDb25uZWN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGVlckhlbHBlciA/IHRoaXMuX3BlZXJIZWxwZXIuY29ubmVjdGlvbiA6IHVuZGVmaW5lZFxuICB9XG5cbiAgZ2V0VHlwZSAoKSB7XG4gICAgcmV0dXJuICdSVEMnXG4gIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBSVENTdWJzY3JpYmVyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9qcy9zdWJzY3JpYmVyL3JlZDVwcm8tcnRjLmpzXG4gKiovIiwiY2xhc3MgRXZlbnQge1xuXG4gIGNvbnN0cnVjdG9yICh0eXBlLCBkYXRhID0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5fdHlwZSA9IHR5cGVcbiAgICB0aGlzLl9kYXRhID0gZGF0YVxuICB9XG5cbiAgZ2V0IHR5cGUgKCkge1xuICAgIHJldHVybiB0aGlzLl90eXBlXG4gIH1cblxuICBnZXQgZGF0YSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFcbiAgfVxuXG59XG5cbmNsYXNzIFB1Ymxpc2hlckV2ZW50IGV4dGVuZHMgRXZlbnQge1xuXG4gIGNvbnN0cnVjdG9yICh0eXBlLCBwdWJsaXNoZXIsIGRhdGEpIHtcbiAgICBzdXBlcih0eXBlLCBkYXRhKVxuICAgIHRoaXMuX3B1Ymxpc2hlciA9IHB1Ymxpc2hlclxuICB9XG5cbiAgZ2V0IHB1Ymxpc2hlciAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3B1Ymxpc2hlclxuICB9XG5cbn1cblxuY2xhc3MgU3Vic2NyaWJlckV2ZW50IGV4dGVuZHMgRXZlbnQge1xuXG4gIGNvbnN0cnVjdG9yICh0eXBlLCBzdWJzY3JpYmVyLCBkYXRhKSB7XG4gICAgc3VwZXIodHlwZSwgZGF0YSlcbiAgICB0aGlzLl9zdWJzY3JpYmVyID0gc3Vic2NyaWJlclxuICB9XG5cbiAgZ2V0IHN1YnNjcmliZXIgKCkge1xuICAgIHJldHVybiB0aGlzLl9zdWJzY3JpYmVyXG4gIH1cblxufVxuXG5leHBvcnQgeyBQdWJsaXNoZXJFdmVudCBhcyBQdWJsaXNoZXJFdmVudCB9XG5leHBvcnQgeyBTdWJzY3JpYmVyRXZlbnQgYXMgU3Vic2NyaWJlckV2ZW50IH1cbmV4cG9ydCB7IGNvbW1vbiBhcyBQdWJsaXNoZXJFdmVudFR5cGVzIH0gZnJvbSAnLi9wdWJsaXNoZXItZXZlbnQnXG5leHBvcnQgeyBydGMgYXMgUlRDUHVibGlzaGVyRXZlbnRUeXBlcyB9IGZyb20gJy4vcHVibGlzaGVyLWV2ZW50J1xuZXhwb3J0IHsgcnRtcCBhcyBSVE1QUHVibGlzaGVyRXZlbnRUeXBlcyB9IGZyb20gJy4vcHVibGlzaGVyLWV2ZW50J1xuZXhwb3J0IHsgZmFpbG92ZXIgYXMgRmFpbG92ZXJQdWJsaXNoZXJFdmVudFR5cGVzIH0gZnJvbSAnLi9wdWJsaXNoZXItZXZlbnQnXG5leHBvcnQgeyBjb21tb24gYXMgU3Vic2NyaWJlckV2ZW50VHlwZXMgfSBmcm9tICcuL3N1YnNjcmliZXItZXZlbnQnXG5leHBvcnQgeyBydGMgYXMgUlRDU3Vic2NyaWJlckV2ZW50VHlwZXMgfSBmcm9tICcuL3N1YnNjcmliZXItZXZlbnQnXG5leHBvcnQgeyBydG1wIGFzIFJUTVBTdWJzY3JpYmVyRXZlbnRUeXBlcyB9IGZyb20gJy4vc3Vic2NyaWJlci1ldmVudCdcbmV4cG9ydCB7IGZhaWxvdmVyIGFzIEZhaWxvdmVyU3Vic2NyaWJlckV2ZW50VHlwZXMgfSBmcm9tICcuL3N1YnNjcmliZXItZXZlbnQnXG5cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL2pzL2V2ZW50L2luZGV4LmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5cbmltcG9ydCBTb2NrZXRIZWxwZXIgZnJvbSAnLi9zb2NrZXQtaGVscGVyJ1xuaW1wb3J0IHsgd2FybiwgZXJyb3IgfSBmcm9tICcuLi9sb2cnXG5cbmNvbnN0IE5BTUUgPSAnUjVQcm9TdWJzY3JpcHRpb25Tb2NrZXQnXG5cbmNsYXNzIFN1YnNjcmlwdGlvblNvY2tldEhlbHBlciBleHRlbmRzIFNvY2tldEhlbHBlciB7XG5cbiAgY29uc3RydWN0b3IgKHJlc3BvbmRlcikge1xuICAgIHN1cGVyKHJlc3BvbmRlciwgTkFNRSlcbiAgfVxuXG4gIHJlc3BvbmQgKG1lc3NhZ2UpIHtcbiAgICAvLyAgICBjb25zb2xlLmxvZyhtZXNzYWdlKVxuICAgIGlmIChtZXNzYWdlLmRhdGEpIHtcbiAgICAgIGxldCBqc29uID0gdGhpcy5nZXRKc29uRnJvbVNvY2tldE1lc3NhZ2UobWVzc2FnZSlcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghc3VwZXIucmVzcG9uZChtZXNzYWdlKSkge1xuICAgICAgICAgIGlmIChqc29uLmRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKGpzb24uZGF0YS5zZHAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBpZiAoanNvbi5kYXRhLnNkcC50eXBlID09PSAnb2ZmZXInKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzcG9uZGVyLm9uU0RQT2ZmZXIoanNvbi5kYXRhKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoanNvbi5kYXRhLmNhbmRpZGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3Jlc3BvbmRlci5vbkFkZEljZUNhbmRpZGF0ZShqc29uLmRhdGEuY2FuZGlkYXRlKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGpzb24uZGF0YS50eXBlID09PSAnc3RhdHVzJykge1xuICAgICAgICAgICAgICBpZiAoanNvbi5kYXRhLmNvZGUgPT09ICdOZXRDb25uZWN0aW9uLklDRS5UcmljbGVDb21wbGV0ZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzcG9uZGVyLm9uU29ja2V0SWNlQ2FuZGlkYXRlRW5kKClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBlcnJvcihOQU1FLCBgW3dzLm9ubWVzc2FnZV0gLSBFcnJvciBpbiBhY2Nlc3NpbmcgbWVzc2FnZSBkYXRhIGFzIEpTT04uICR7ZS5tZXNzYWdlfWApXG4gICAgICAgIHRoaXMuX3Jlc3BvbmRlci5vblNvY2tldE1lc3NhZ2VFcnJvcihgW3dzLm9ubWVzc2FnZV0gLSBFcnJvciBpbiBhY2Nlc3NpbmcgbWVzc2FnZSBkYXRhIGFzIEpTT04uICR7ZS5tZXNzYWdlfWApXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm4oTkFNRSwgJ1t3cy5vbm1lc3NhZ2VdIC0gTm8gTWVzc2FnZSBEYXRhLicpXG4gICAgfVxuICB9XG5cbn1cbmV4cG9ydCBkZWZhdWx0IFN1YnNjcmlwdGlvblNvY2tldEhlbHBlclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvanMvaGVscGVyL3NvY2tldC1oZWxwZXItc3ViLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5pbXBvcnQgKiBhcyB3ZWJzb2NrZXQgZnJvbSAnLi4vYWRhcHRlci93ZWJzb2NrZXQnXG5pbXBvcnQgZW52aXJvbm1lbnQgZnJvbSAnLi4vZW52L2Jyb3dzZXInXG5pbXBvcnQgeyBpbmZvLCBkZWJ1Zywgd2FybiB9IGZyb20gJy4uL2xvZydcblxuY2xhc3MgU29ja2V0SGVscGVyIHtcblxuICBjb25zdHJ1Y3RvciAocmVzcG9uZGVyLCBuYW1lKSB7XG4gICAgdGhpcy5fcmVzcG9uZGVyID0gcmVzcG9uZGVyXG4gICAgdGhpcy5fcGVuZGluZ1Bvc3RSZXF1ZXN0cyA9IFtdXG4gICAgdGhpcy5fd2Vic29ja2V0ID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fbmFtZSA9IG5hbWVcbiAgICB0aGlzLl9vbmNsb3NlID0gdGhpcy50ZWFyRG93bi5iaW5kKHRoaXMpXG4gIH1cblxuICBfcmVtb3ZlU29ja2V0SGFuZGxlcnMgKHdzKSB7XG4gICAgd3Mub25vcGVuID0gdW5kZWZpbmVkXG4gICAgd3Mub25tZXNzYWdlID0gdW5kZWZpbmVkXG4gICAgd3Mub25lcnJvciA9IHVuZGVmaW5lZFxuICB9XG5cbiAgX2FkZFNvY2tldEhhbmRsZXJzICh3cywgcHJvbWlzZSkge1xuICAgIHdzLm9ub3BlbiA9ICgpID0+IHtcbiAgICAgIGluZm8odGhpcy5fbmFtZSwgJ1t3ZWJzb2NrZXRvcGVuXScpXG4gICAgICB3aGlsZSAodGhpcy5fcGVuZGluZ1Bvc3RSZXF1ZXN0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMucG9zdCh0aGlzLl9wZW5kaW5nUG9zdFJlcXVlc3RzLnNoaWZ0KCkpXG4gICAgICB9XG4gICAgICBwcm9taXNlLnJlc29sdmUoKVxuICAgIH1cblxuICAgIHdzLm9uZXJyb3IgPSAoZXJyb3IpID0+IHtcbiAgICAgIHdhcm4odGhpcy5fbmFtZSwgYFt3ZWJzb2NrZXRlcnJvcl06IEVycm9yIGZyb20gV2ViU29ja2V0LiAke2Vycm9yLnR5cGV9YClcbiAgICAgIHByb21pc2UucmVqZWN0KGVycm9yKVxuICAgIH1cblxuICAgIHdzLm9ubWVzc2FnZSA9IChtZXNzYWdlKSA9PiB7XG4gICAgICB0aGlzLnJlc3BvbmQobWVzc2FnZSlcbiAgICB9XG4gIH1cblxuICBzZXRVcCAodXJsLCBzZXR1cFByb21pc2UpIHtcbiAgICB0aGlzLnRlYXJEb3duKClcbiAgICB0aGlzLl93ZWJzb2NrZXQgPSB3ZWJzb2NrZXQuY3JlYXRlKHVybClcbiAgICB0aGlzLl9hZGRTb2NrZXRIYW5kbGVycyh0aGlzLl93ZWJzb2NrZXQsIHNldHVwUHJvbWlzZSlcbiAgICBlbnZpcm9ubWVudC5hZGRDbG9zZUhhbmRsZXIodGhpcy5fb25jbG9zZSlcbiAgfVxuXG4gIHRlYXJEb3duICgpIHtcbiAgICB0aGlzLl9wZW5kaW5nUG9zdFJlcXVlc3RzLmxlbmd0aCA9IDBcbiAgICBpZiAodHlwZW9mIHRoaXMuX3dlYnNvY2tldCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMuX3JlbW92ZVNvY2tldEhhbmRsZXJzKHRoaXMuX3dlYnNvY2tldClcbiAgICAgIHRoaXMuX3dlYnNvY2tldC5jbG9zZSgpXG4gICAgfVxuICAgIHRoaXMuX3dlYnNvY2tldCA9IHVuZGVmaW5lZFxuICAgIGVudmlyb25tZW50LnJlbW92ZUNsb3NlSGFuZGxlcih0aGlzLl9vbmNsb3NlKVxuICB9XG5cbiAgZ2V0SnNvbkZyb21Tb2NrZXRNZXNzYWdlIChtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBtZXNzYWdlLmRhdGEgPT09ICdzdHJpbmcnID8gSlNPTi5wYXJzZShtZXNzYWdlLmRhdGEpIDogbWVzc2FnZS5kYXRhXG4gIH1cblxuICBwb3N0IChzZW5kUmVxdWVzdCkge1xuICAgIGlmICh0aGlzLl93ZWJzb2NrZXQgIT09IHVuZGVmaW5lZCAmJiB0aGlzLl93ZWJzb2NrZXQucmVhZHlTdGF0ZSA9PT0gMSAvKiBXZWJTb2NrZXQuT1BFTiAqLykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZGVidWcodGhpcy5fbmFtZSwgJ1t3ZWJzb2NrZXQtcG9zdF06ICcgKyBKU09OLnN0cmluZ2lmeShzZW5kUmVxdWVzdCwgbnVsbCwgMikpXG4gICAgICAgIHRoaXMuX3dlYnNvY2tldC5zZW5kKEpTT04uc3RyaW5naWZ5KHNlbmRSZXF1ZXN0KSlcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZGVidWcodGhpcy5fbmFtZSwgYENvdWxkIG5vdCBzZW5kIHJlcXVlc3Q6ICR7c2VuZFJlcXVlc3R9LiAke2V9YClcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcGVuZGluZ1Bvc3RSZXF1ZXN0cy5wdXNoKHNlbmRSZXF1ZXN0KVxuICAgIH1cbiAgfVxuXG4gIHJlc3BvbmQgKG1lc3NhZ2UpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIGlmIChtZXNzYWdlLmRhdGEpIHtcbiAgICAgIGxldCBqc29uID0gdGhpcy5nZXRKc29uRnJvbVNvY2tldE1lc3NhZ2UobWVzc2FnZSlcbiAgICAgIGRlYnVnKHRoaXMuX25hbWUsICdbd2Vic29ja2V0LXJlc3BvbnNlXTogJyArIEpTT04uc3RyaW5naWZ5KGpzb24sIG51bGwsIDIpKVxuICAgICAgaWYgKGpzb24uaXNBdmFpbGFibGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodHlwZW9mIGpzb24uaXNBdmFpbGFibGUgPT09ICdib29sZWFuJyAmJiBqc29uLmlzQXZhaWxhYmxlKSB7XG4gICAgICAgICAgdGhpcy5fcmVzcG9uZGVyLm9uU3RyZWFtQXZhaWxhYmxlKGpzb24pXG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9yZXNwb25kZXIub25TdHJlYW1VbmF2YWlsYWJsZShqc29uKVxuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoanNvbi5kYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGpzb24uZGF0YS5tZXNzYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoanNvbi5kYXRhLnR5cGUgPT09ICdlcnJvcicpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc3BvbmRlci5vblNvY2tldE1lc3NhZ2VFcnJvcihqc29uLmRhdGEubWVzc2FnZSwganNvbi5kYXRhLmRldGFpbClcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFNvY2tldEhlbHBlclxuXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9qcy9oZWxwZXIvc29ja2V0LWhlbHBlci5qc1xuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgZW52aXJvbm1lbnQgZnJvbSAnLi4vZW52L2Jyb3dzZXInXG5cbmV4cG9ydCBjb25zdCBpc1N1cHBvcnRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGVudmlyb25tZW50LnN1cHBvcnRzV2ViU29ja2V0KClcbn1cblxuZXhwb3J0IGNvbnN0IGNyZWF0ZSA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgcmV0dXJuIGVudmlyb25tZW50LmNyZWF0ZVdlYlNvY2tldCh1cmwpXG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9qcy9hZGFwdGVyL3dlYnNvY2tldC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgeyBEZWZlcnJlZFByb21pc2UgfSBmcm9tICcuLi91dGlsL3Byb21pc2UnXG5pbXBvcnQgeyBOb0VsZW1lbnRGb3VuZEVycm9yIH0gZnJvbSAnLi4vZXhjZXB0aW9uL2Vycm9ycydcblxubGV0IGNsb3NlSGFuZGxlcnMgPSBuZXcgU2V0KClcbmZ1bmN0aW9uIG9ud2luZG93Y2xvc2UgKCkge1xuICBjbG9zZUhhbmRsZXJzLmZvckVhY2goaCA9PiBoKCkpXG59XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlb2pzL3ZpZGVvLmpzL2Jsb2IvbWFzdGVyL3NyYy9qcy90ZWNoL2ZsYXNoLmpzI0w0NzZcbmNvbnN0IGZsYXNoVmVyc2lvbiA9IGZ1bmN0aW9uICgpIHtcbiAgbGV0IHZlcnNpb24gPSAnMCwwLDAnXG4gIC8vIElFXG4gIHRyeSB7XG4gICAgdmVyc2lvbiA9IG5ldyB3aW5kb3cuQWN0aXZlWE9iamVjdCgnU2hvY2t3YXZlRmxhc2guU2hvY2t3YXZlRmxhc2gnKS5HZXRWYXJpYWJsZSgnJHZlcnNpb24nKS5yZXBsYWNlKC9cXEQrL2csICcsJykubWF0Y2goL14sPyguKyksPyQvKVsxXVxuXG4gIC8vIG90aGVyIGJyb3dzZXJzXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKG5hdmlnYXRvci5taW1lVHlwZXNbJ2FwcGxpY2F0aW9uL3gtc2hvY2t3YXZlLWZsYXNoJ10uZW5hYmxlZFBsdWdpbikge1xuICAgICAgICB2ZXJzaW9uID0gKG5hdmlnYXRvci5wbHVnaW5zWydTaG9ja3dhdmUgRmxhc2ggMi4wJ10gfHwgbmF2aWdhdG9yLnBsdWdpbnNbJ1Nob2Nrd2F2ZSBGbGFzaCddKS5kZXNjcmlwdGlvbi5yZXBsYWNlKC9cXEQrL2csICcsJykubWF0Y2goL14sPyguKyksPyQvKVsxXVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gbmFkYVxuICAgIH1cbiAgfVxuICByZXR1cm4gdmVyc2lvbi5zcGxpdCgnLCcpXG59XG5cbmNvbnN0IGlzTW96ID0gISFuYXZpZ2F0b3IubW96R2V0VXNlck1lZGlhXG5uYXZpZ2F0b3IuZ2V0VXNlck1lZGlhID0gbmF2aWdhdG9yLmdldFVzZXJNZWRpYSB8fCBuYXZpZ2F0b3IubW96R2V0VXNlck1lZGlhIHx8IG5hdmlnYXRvci53ZWJraXRHZXRVc2VyTWVkaWEgfHwgbmF2aWdhdG9yLm1zR2V0VXNlck1lZGlhXG5cbmNvbnN0IGRlZmF1bHRVc2VyTWVkaWFBdWRpbyA9IGlzTW96ID8gdHJ1ZSA6IHtcbiAgbWFuZGl0b3J5OiB7XG4gICAgZ29vZ0F1dG9HYWluQ29udHJvbDogdHJ1ZSxcbiAgICBnb29nSGlnaHBhc3NGaWx0ZXI6IHRydWUsXG4gICAgZ29vZ0VjaG9DYW5jZWxsYXRpb246IHRydWUsXG4gICAgZ29vZ05vaXNlU3VwcHJlc3Npb246IHRydWVcbiAgfSxcbiAgb3B0aW9uYWw6IFtcbiAgICB7XG4gICAgICBiYW5kd2lkdGg6IDUwXG4gICAgfSxcbiAgICB7XG4gICAgICBlY2hvQ2FuY2VsbGF0aW9uOiB0cnVlXG4gICAgfVxuICBdXG59XG5jb25zdCBkZWZhdWx0VXNlck1lZGlhVmlkZW8gPSBpc01veiA/IHRydWUgOiB7XG4gIG1hbmRhdG9yeToge1xuICAgIG1pbldpZHRoOiAzMjAsXG4gICAgbWluSGVpZ2h0OiAyNDAsXG4gICAgbWluRnJhbWVSYXRlOiA0LFxuICAgIG1heFdpZHRoOiA2NDAsXG4gICAgbWF4SGVpZ2h0OiA0ODAsXG4gICAgbWF4RnJhbWVSYXRlOiAyNFxuICB9LFxuICBvcHRpb25hbDogW1xuICAgIHtcbiAgICAgIGJhbmR3aWR0aDogMjU2XG4gICAgfVxuICBdXG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgc3VwcG9ydHNXZWJTb2NrZXQ6ICgpID0+IHtcbiAgICByZXR1cm4gISF3aW5kb3cuV2ViU29ja2V0XG4gIH0sXG5cbiAgc3VwcG9ydHNGbGFzaFZlcnNpb246ICh2ZXJzaW9uLCBkZWxpbWl0ZXIgPSAnLicpID0+IHtcbiAgICByZXR1cm4gZmxhc2hWZXJzaW9uKClbMF0gPj0gdmVyc2lvbi5zcGxpdChkZWxpbWl0ZXIpWzBdXG4gIH0sXG5cbiAgcmVzb2x2ZUVsZW1lbnQ6IChpZCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBlbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKVxuICAgICAgaWYgKCFlbCkge1xuICAgICAgICB0aHJvdyBuZXcgTm9FbGVtZW50Rm91bmRFcnJvcihgRWxlbWVudCB3aXRoIGlkKCR7aWR9KSBjb3VsZCBub3QgYmUgZm91bmQuYClcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbFxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBOb0VsZW1lbnRGb3VuZEVycm9yKGBFcnJvciBpbiBhY2Nlc3NpbmcgZWxlbWVudCB3aXRoIGlkKCR7aWR9KS4gJHtlLm1lc3NhZ2V9YClcbiAgICB9XG4gIH0sXG5cbiAgY3JlYXRlV2ViU29ja2V0OiAodXJsKSA9PiB7XG4gICAgcmV0dXJuIG5ldyB3aW5kb3cuV2ViU29ja2V0KHVybClcbiAgfSxcblxuICBzZXRWaWRlb1NvdXJjZTogKHZpZGVvRWxlbWVudCwgbWVkaWFTdHJlYW0sIGF1dG9wbGF5ID0gZmFsc2UpID0+IHtcbiAgICBpZiAoaXNNb3opIHtcbiAgICAgIHZpZGVvRWxlbWVudFsnbW96U3JjT2JqZWN0J10gPSBtZWRpYVN0cmVhbVxuICAgIH0gZWxzZSB7XG4gICAgICB2aWRlb0VsZW1lbnQuc3JjID0gd2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwobWVkaWFTdHJlYW0pXG4gICAgfVxuICAgIGlmIChhdXRvcGxheSkge1xuICAgICAgdmlkZW9FbGVtZW50LnBsYXkoKVxuICAgIH1cbiAgfSxcblxuICBpbmplY3RTY3JpcHQ6ICh1cmwpID0+IHtcbiAgICBsZXQgZGZkID0gbmV3IERlZmVycmVkUHJvbWlzZSgpXG4gICAgbGV0IHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpXG4gICAgc2NyaXB0LnR5cGUgPSAndGV4dC9qYXZhc2NyaXB0J1xuICAgIHNjcmlwdC5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICBkZmQucmVzb2x2ZSgpXG4gICAgfVxuICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoc2NyaXB0LnJlYWR5U3RhdGUgPT09ICdsb2FkZWQnIHx8IHNjcmlwdC5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnKSB7XG4gICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsXG4gICAgICAgIGRmZC5yZXNvbHZlKClcbiAgICAgIH1cbiAgICB9XG4gICAgc2NyaXB0LnNyYyA9IHVybFxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0uYXBwZW5kQ2hpbGQoc2NyaXB0KVxuICAgIHJldHVybiBkZmQucHJvbWlzZVxuICB9LFxuXG4gIGdldFN3Zk9iamVjdDogKCkgPT4ge1xuICAgIHJldHVybiB3aW5kb3cuc3dmb2JqZWN0XG4gIH0sXG5cbiAgZ2V0RW1iZWRPYmplY3Q6IChpZCkgPT4ge1xuICAgIHJldHVybiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZClcbiAgfSxcblxuICBnZXRWaWRlb0pzOiAoKSA9PiB7XG4gICAgcmV0dXJuIHdpbmRvdy52aWRlb2pzXG4gIH0sXG5cbiAgZ2V0VXNlck1lZGlhOiAoYXVkaW8gPSBudWxsLCB2aWRlbyA9IG51bGwpID0+IHtcbiAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZFByb21pc2UoKVxuICAgIG5hdmlnYXRvci5nZXRVc2VyTWVkaWEoe1xuICAgICAgYXVkaW86IGF1ZGlvIHx8IGRlZmF1bHRVc2VyTWVkaWFBdWRpbyxcbiAgICAgIHZpZGVvOiB2aWRlbyB8fCBkZWZhdWx0VXNlck1lZGlhVmlkZW9cbiAgICB9LCBkZWZlcnJlZC5yZXNvbHZlLCBkZWZlcnJlZC5yZWplY3QpXG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2VcbiAgfSxcblxuICBnZXREZWZhdWx0UHVibGlzaENvbnN0cmFpbnRzOiAoYXVkaW8gPSBmYWxzZSwgdmlkZW8gPSBmYWxzZSkgPT4ge1xuICAgIGlmIChpc01veikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb2ZmZXJUb1JlY2VpdmVWaWRlbzogdmlkZW8sXG4gICAgICAgIG9mZmVyVG9SZWNlaXZlQXVkaW86IGF1ZGlvXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBtYW5kYXRvcnk6IHtcbiAgICAgICAgb2ZmZXJUb1JlY2VpdmVWaWRlbzogdmlkZW8sXG4gICAgICAgIG9mZmVyVG9SZWNlaXZlQXVkaW86IGF1ZGlvXG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGdldElzTW96OiAoKSA9PiB7XG4gICAgcmV0dXJuIGlzTW96XG4gIH0sXG5cbiAgYWRkQ2xvc2VIYW5kbGVyOiAoaGFuZGxlcikgPT4ge1xuICAgIGNsb3NlSGFuZGxlcnMuYWRkKGhhbmRsZXIpXG4gICAgaWYgKHdpbmRvdy5vbmJlZm9yZXVubG9hZCAhPT0gb253aW5kb3djbG9zZSkge1xuICAgICAgd2luZG93Lm9uYmVmb3JldW5sb2FkID0gb253aW5kb3djbG9zZVxuICAgIH1cbiAgfSxcblxuICByZW1vdmVDbG9zZUhhbmRsZXI6IChoYW5kbGVyKSA9PiB7XG4gICAgaWYgKGNsb3NlSGFuZGxlcnMuaGFzKGhhbmRsZXIpKSB7XG4gICAgICBjbG9zZUhhbmRsZXJzLmRlbGV0ZShoYW5kbGVyKVxuICAgIH1cbiAgfVxuXG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9qcy9lbnYvYnJvd3Nlci5qc1xuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG5jbGFzcyBfRGVmZXJyZWRQcm9taXNlIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHRoaXMucmVzb2x2ZSA9IHVuZGVmaW5lZFxuICAgIHRoaXMucmVqZWN0ID0gdW5kZWZpbmVkXG4gICAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5yZXNvbHZlID0gcmVzb2x2ZVxuICAgICAgdGhpcy5yZWplY3QgPSByZWplY3RcbiAgICB9KVxuICB9XG59XG5cbmNvbnN0IF9GdXR1cmUgPSB7XG4gIGNyZWF0ZUlmTm90RXhpc3Q6IChkZWZlcnJlZElmRXhpc3QpID0+IHtcbiAgICBsZXQgZiA9IGRlZmVycmVkSWZFeGlzdFxuICAgIGlmICghZikge1xuICAgICAgZiA9IG5ldyBfRGVmZXJyZWRQcm9taXNlKClcbiAgICB9XG4gICAgcmV0dXJuIGZcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgRGVmZXJyZWRQcm9taXNlID0gX0RlZmVycmVkUHJvbWlzZVxuZXhwb3J0IGNvbnN0IEZ1dHVyZSA9IF9GdXR1cmVcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL2pzL3V0aWwvcHJvbWlzZS5qc1xuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG5leHBvcnQgY2xhc3MgTm9FbGVtZW50Rm91bmRFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlKSB7XG4gICAgdGhpcy5uYW1lID0gJ05vRWxlbWVudEZvdW5kJ1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2VcbiAgfVxufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvanMvZXhjZXB0aW9uL2Vycm9ycy5qc1xuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgKiBhcyB3ZWJydGMgZnJvbSAnLi4vYWRhcHRlci93ZWJydGMnXG5pbXBvcnQgeyBEZWZlcnJlZFByb21pc2UgfSBmcm9tICcuLi91dGlsL3Byb21pc2UnXG5pbXBvcnQgeyBkZWJ1Zywgd2FybiwgZXJyb3IgfSBmcm9tICcuLi9sb2cnXG5cbmNvbnN0IE5BTUUgPSAnUjVQcm9TdWJzY3JpcHRpb25QZWVyJ1xuXG5jbGFzcyBTdWJzY3JpcHRpb25QZWVySGVscGVyIHtcblxuICBjb25zdHJ1Y3RvciAocmVzcG9uZGVyKSB7XG4gICAgdGhpcy5fcmVzcG9uZGVyID0gcmVzcG9uZGVyXG4gICAgdGhpcy5fcGVlckNvbm5lY3Rpb24gPSB1bmRlZmluZWRcbiAgICB0aGlzLl9wZW5kaW5nTWVkaWFTdHJlYW0gPSB1bmRlZmluZWRcbiAgfVxuXG4gIF9yZW1vdmVDb25uZWN0aW9uSGFuZGxlcnMgKGNvbm5lY3Rpb24pIHtcbiAgICBjb25uZWN0aW9uLm9uY29ubmVjdGlvbnN0YXRlY2hhbmdlID0gdW5kZWZpbmVkXG4gICAgY29ubmVjdGlvbi5vbmljZWNhbmRpZGF0ZSA9IHVuZGVmaW5lZFxuICAgIGNvbm5lY3Rpb24ub25hZGRzdHJlYW0gPSB1bmRlZmluZWRcbiAgICBjb25uZWN0aW9uLm9udHJhY2sgPSB1bmRlZmluZWRcbiAgfVxuXG4gIF9hZGRDb25uZWN0aW9uSGFuZGxlcnMgKGNvbm5lY3Rpb24sIHByb21pc2UpIHtcblxuICAgIGNvbm5lY3Rpb24ub25jb25uZWN0aW9uc3RhdGVjaGFuZ2UgPSAoKSA9PiB7XG4gICAgICBpZiAoY29ubmVjdGlvbi5jb25uZWN0aW9uU3RhdGUgPT09ICdjb25uZWN0ZWQnKSB7XG4gICAgICAgIGRlYnVnKE5BTUUsICdbcGVlcmNvbm5lY3Rpb246b3Blbl0nKVxuICAgICAgICBpZiAocHJvbWlzZSkge1xuICAgICAgICAgIHByb21pc2UucmVzb2x2ZSh0aGlzKVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNvbm5lY3Rpb24uY29ubmVjdGlvblN0YXRlID09PSAnZmFpbGVkJyB8fFxuICAgICAgICBjb25uZWN0aW9uLmNvbm5lY3Rpb25TdGF0ZSA9PT0gJ2Rpc2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgd2FybihOQU1FLCAnW3BlZXJjb25uZWN0aW9uOmVycm9yXScpXG4gICAgICAgIGlmIChwcm9taXNlKSB7XG4gICAgICAgICAgcHJvbWlzZS5yZWplY3QoKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29ubmVjdGlvbi5vbmljZWNhbmRpZGF0ZSA9IChldmVudCkgPT4ge1xuICAgICAgZGVidWcoTkFNRSwgYFtwZWVyLm9uaWNlY2FuZGlkYXRlXSAtIFBlZXIgQ2FuZGlkYXRlOiAke2V2ZW50LmNhbmRpZGF0ZX1gKVxuICAgICAgaWYgKGV2ZW50LmNhbmRpZGF0ZSkge1xuICAgICAgICB0aGlzLl9yZXNwb25kZXIub25JY2VDYW5kaWRhdGUoZXZlbnQuY2FuZGlkYXRlKVxuICAgICAgfSBlbHNlIGlmIChldmVudC5jYW5kaWRhdGUgPT09IG51bGwpIHtcbiAgICAgICAgLy8gbnVsbCBtZWFucyB0aGV5IGhhdmUgZmluaXNoZWQgc2VuZGluZyBjYW5kaWRhdGVzIGJhY2sgYW5kIGZvcnRoP1xuICAgICAgICB0aGlzLl9yZXNwb25kZXIub25JY2VDYW5kaWRhdGVUcmlja2xlRW5kKHRoaXMuX3BlbmRpbmdNZWRpYVN0cmVhbSlcbiAgICAgICAgdGhpcy5fcGVuZGluZ01lZGlhU3RyZWFtID0gdW5kZWZpbmVkXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29ubmVjdGlvbi5vbmFkZHN0cmVhbSA9IChldmVudCkgPT4ge1xuICAgICAgZGVidWcoTkFNRSwgYFBlZXIgQWRkIFN0cmVhbTogJHtldmVudC5zdHJlYW19YClcbiAgICAgIGlmIChldmVudC5zdHJlYW0pIHtcbiAgICAgICAgdGhpcy5fcGVuZGluZ01lZGlhU3RyZWFtID0gZXZlbnQuc3RyZWFtXG4gICAgICAgIHRoaXMuX3Jlc3BvbmRlci5vbkFuc3dlck1lZGlhU3RyZWFtKGV2ZW50LnN0cmVhbSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25uZWN0aW9uLm9udHJhY2sgPSAoZXZlbnQpID0+IHtcbiAgICAgIGRlYnVnKE5BTUUsIGBQZWVyIEFkZCBTdHJlYW06ICR7ZXZlbnQuc3RyZWFtc31gKVxuICAgICAgaWYgKGV2ZW50LnN0cmVhbXMgJiYgZXZlbnQuc3RyZWFtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuX3BlbmRpbmdNZWRpYVN0cmVhbSA9IGV2ZW50LnN0cmVhbXNbMF1cbiAgICAgIH1cblxuICAgIH1cbiAgfVxuXG4gIHNldFVwIChpY2VTZXJ2ZXJzLCBzZXRVcFByb21pc2UpIHtcbiAgICB0aGlzLnRlYXJEb3duKClcbiAgICBkZWJ1ZyhOQU1FLCAnW3NldHVwXScpXG4gICAgY29uc3QgcCA9IHNldFVwUHJvbWlzZSB8fCBuZXcgRGVmZXJyZWRQcm9taXNlKClcbiAgICB0cnkge1xuICAgICAgbGV0IHBlZXIgPSBuZXcgd2VicnRjLlJUQ1BlZXJDb25uZWN0aW9uKHtcbiAgICAgICAgaWNlU2VydmVyczogaWNlU2VydmVyc1xuICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG9wdGlvbmFsOiBbXG4gICAgICAgICAgICB7RHRsc1NydHBLZXlBZ3JlZW1lbnQ6IHRydWV9LFxuICAgICAgICAgICAge1J0cERhdGFDaGFubmVsczogZmFsc2V9LFxuICAgICAgICAgICAge2dvb2dDcHVPdmVydXNlRGV0ZWN0aW9uOiB0cnVlfVxuICAgICAgICAgIF1cbiAgICAgICAgfSlcbiAgICAgIHRoaXMuX3BlZXJDb25uZWN0aW9uID0gcGVlclxuICAgICAgdGhpcy5fYWRkQ29ubmVjdGlvbkhhbmRsZXJzKHBlZXIpXG4gICAgICBwLnJlc29sdmUoKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHdhcm4oTkFNRSwgYENvdWxkIG5vdCBjcmVhdGUgYSBSVENQZWVyQ29ubmVjdGlvbi4gRXJyb3I6ICR7ZS5tZXNzYWdlfWApXG4gICAgICBwLnJlamVjdChlLm1lc3NhZ2UpXG4gICAgfVxuICAgIHJldHVybiBwLmhhc093blByb3BlcnR5KCdwcm9taXNlJykgPyBwLnByb21pc2UgOiBwXG4gIH1cblxuICB0ZWFyRG93biAoKSB7XG4gICAgZGVidWcoTkFNRSwgJ1t0ZWFyZG93bl0nKVxuICAgIGlmICh0aGlzLl9wZWVyQ29ubmVjdGlvbikge1xuICAgICAgdGhpcy5fcmVtb3ZlQ29ubmVjdGlvbkhhbmRsZXJzKHRoaXMuX3BlZXJDb25uZWN0aW9uKVxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5fcGVlckNvbm5lY3Rpb24uY2xvc2UoKVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB3YXJuKE5BTUUsIGBbcGVlcmNvbm5lY3Rpb24uY2xvc2VdIGVycm9yOiAke2UubWVzc2FnZX1gKVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9wZW5kaW5nTWVkaWFTdHJlYW0gPSB1bmRlZmluZWRcbiAgICB0aGlzLl9wZWVyQ29ubmVjdGlvbiA9IHVuZGVmaW5lZFxuICB9XG5cbiAgY3JlYXRlQW5zd2VyIChzZHApIHtcbiAgICBkZWJ1ZyhOQU1FLCAnW2NyZWF0ZWFuc3dlcl0nKVxuICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkUHJvbWlzZSgpXG5cbiAgICB0aGlzLl9wZWVyQ29ubmVjdGlvbi5zZXRSZW1vdGVEZXNjcmlwdGlvbihzZHApXG4gICAgICAudGhlbih0aGlzLl9yZXNwb25kZXIub25TRFBTdWNjZXNzKVxuICAgICAgLmNhdGNoKHRoaXMuX3Jlc3BvbmRlci5vblNEUEVycm9yKVxuXG4gICAgdGhpcy5fcGVlckNvbm5lY3Rpb24uY3JlYXRlQW5zd2VyKClcbiAgICAgIC50aGVuKHNlc3Npb25EZXNjcmlwdGlvbiA9PiB7XG4gICAgICAgIHRoaXMuX3BlZXJDb25uZWN0aW9uLnNldExvY2FsRGVzY3JpcHRpb24oc2Vzc2lvbkRlc2NyaXB0aW9uKVxuICAgICAgICAgIC50aGVuKHRoaXMuX3Jlc3BvbmRlci5vblNEUFN1Y2Nlc3MpXG4gICAgICAgICAgLmNhdGNoKHRoaXMuX3Jlc3BvbmRlci5vblNEUEVycm9yKVxuICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHNlc3Npb25EZXNjcmlwdGlvbilcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goZGVmZXJyZWQucmVqZWN0KVxuXG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2VcbiAgfVxuXG4gIGFkZEljZUNhbmRpZGF0ZSAoY2FuZGlkYXRlKSB7XG4gICAgZGVidWcoTkFNRSwgJ1thZGRpY2VjYW5kaWRhdGVdJylcbiAgICBsZXQgaWNlQ2FuZGlkYXRlID0gbmV3IHdlYnJ0Yy5SVENJY2VDYW5kaWRhdGUoe1xuICAgICAgc2RwTUxpbmVJbmRleDogY2FuZGlkYXRlLnNkcE1MaW5lSW5kZXgsXG4gICAgICBjYW5kaWRhdGU6IGNhbmRpZGF0ZS5jYW5kaWRhdGVcbiAgICB9KVxuICAgIHRoaXMuX3BlZXJDb25uZWN0aW9uLmFkZEljZUNhbmRpZGF0ZShpY2VDYW5kaWRhdGUpXG4gICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgIC8vIG5hZGFcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgZXJyb3IoTkFNRSwgYEVycm9yIGluIGFkZCBvZiBJQ0UgQ2FuZGlkaWF0ZSArICR7ZXJyfWApXG4gICAgICB9KVxuICB9XG5cbiAgZ2V0IGNvbm5lY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9wZWVyQ29ubmVjdGlvblxuICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgU3Vic2NyaXB0aW9uUGVlckhlbHBlclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvanMvaGVscGVyL3dlYnJ0Yy1oZWxwZXItc3ViLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5cbmltcG9ydCBlbnZpcm9ubWVudCBmcm9tICcuLi9lbnYvYnJvd3NlcidcblxuLyoqIC0tIGhhbmRsZWQgYnkgYWRhcHRlci5qcyAtLSAqL1xuY29uc3QgX1JUQ1BlZXJDb25uZWN0aW9uID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uIHx8ICh3aW5kb3cubW96UlRDUGVlckNvbm5lY3Rpb24gfHwgd2luZG93LndlYmtpdFJUQ1BlZXJDb25uZWN0aW9uKVxuY29uc3QgX1JUQ0ljZUNhbmRpZGF0ZSA9IHdpbmRvdy5SVENJY2VDYW5kaWRhdGUgfHwgKHdpbmRvdy5tb3pSVENJY2VDYW5kaWRhdGUgfHwgd2luZG93LndlYmtpdFJUQ0ljZUNhbmRpZGF0ZSlcbmNvbnN0IF9SVENTZXNzaW9uRGVzY3JpcHRpb24gPSB3aW5kb3cuUlRDU2Vzc2lvbkRlc2NyaXB0aW9uIHx8ICh3aW5kb3cubW96UlRDU2Vzc2lvbkRlc2NyaXB0aW9uIHx8IHdpbmRvdy53ZWJraXRSVENTZXNzaW9uRGVzY3JpcHRpb24pXG5cbmV4cG9ydCBjb25zdCBpc1N1cHBvcnRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIF9SVENQZWVyQ29ubmVjdGlvbiAmJiBfUlRDSWNlQ2FuZGlkYXRlICYmIF9SVENTZXNzaW9uRGVzY3JpcHRpb25cbn1cblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL211YXota2hhbi9XZWJSVEMtRXhwZXJpbWVudC9ibG9iL21hc3Rlci9SVENQZWVyQ29ubmVjdGlvbi9SVENQZWVyQ29ubmVjdGlvbi12MS42LmpzI0wxNThcbi8vIE11YXogS2hhbiAgICAgLSBnaXRodWIuY29tL211YXota2hhblxuLy8gTUlUIExpY2Vuc2UgICAtIHd3dy5XZWJSVEMtRXhwZXJpbWVudC5jb20vbGljZW5jZVxuLy8gRG9jdW1lbnRhdGlvbiAtIGdpdGh1Yi5jb20vbXVhei1raGFuL1dlYlJUQy1FeHBlcmltZW50L3RyZWUvbWFzdGVyL1JUQ1BlZXJDb25uZWN0aW9uXG5leHBvcnQgY29uc3QgdXBkYXRlQmFuZHdpZHRoID0gZnVuY3Rpb24gKG9wdGlvbnMsIHNkcCkge1xuICBpZiAoZW52aXJvbm1lbnQuZ2V0SXNNb3ooKSkge1xuICAgIHJldHVybiBzZHBcbiAgfVxuICBzZHAgPSBzZHAucmVwbGFjZSgvYj1BUyhbXlxcclxcbl0rXFxyXFxuKS9nLCAnJylcbiAgaWYgKG9wdGlvbnMuYXVkaW8pIHtcbiAgICBzZHAgPSBzZHAucmVwbGFjZSgvYT1taWQ6YXVkaW9cXHJcXG4vZywgJ2E9bWlkOmF1ZGlvXFxyXFxuYj1BUzonICsgb3B0aW9ucy5hdWRpbyArICdcXHJcXG4nKVxuICB9XG4gIGlmIChvcHRpb25zLnZpZGVvKSB7XG4gICAgc2RwID0gc2RwLnJlcGxhY2UoL2E9bWlkOnZpZGVvXFxyXFxuL2csICdhPW1pZDp2aWRlb1xcclxcbmI9QVM6JyArIG9wdGlvbnMudmlkZW8gKyAnXFxyXFxuJylcbiAgfVxuICByZXR1cm4gc2RwXG59XG5cbmV4cG9ydCBjb25zdCBSVENQZWVyQ29ubmVjdGlvbiA9IF9SVENQZWVyQ29ubmVjdGlvblxuZXhwb3J0IGNvbnN0IFJUQ0ljZUNhbmRpZGF0ZSA9IF9SVENJY2VDYW5kaWRhdGVcbmV4cG9ydCBjb25zdCBSVENTZXNzaW9uRGVzY3JpcHRpb24gPSBfUlRDU2Vzc2lvbkRlc2NyaXB0aW9uXG5cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL2pzL2FkYXB0ZXIvd2VicnRjLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5cbmltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnLi4vY29yZS9ldmVudC1lbWl0dGVyJ1xuaW1wb3J0IHsgU3Vic2NyaWJlckV2ZW50IH0gZnJvbSAnLi4vZXZlbnQnXG5pbXBvcnQgeyBTdWJzY3JpYmVyRXZlbnRUeXBlcyB9IGZyb20gJy4uL2V2ZW50J1xuaW1wb3J0IGVudmlyb25tZW50IGZyb20gJy4uL2Vudi9icm93c2VyJ1xuaW1wb3J0IFZpZGVvSlNIYW5kbGVyIGZyb20gJy4vdmlkZW9qcy1zb3VyY2UtaGFuZGxlcidcbmltcG9ydCB7IERlZmVycmVkUHJvbWlzZSB9IGZyb20gJy4uL3V0aWwvcHJvbWlzZSdcbmltcG9ydCB7IGRlYnVnIH0gZnJvbSAnLi4vbG9nJ1xuXG5jb25zdCBOQU1FID0gJ1I1UHJvSExTU3Vic2NyaWJlcidcbmNvbnN0IHZpZGVvanMgPSBlbnZpcm9ubWVudC5nZXRWaWRlb0pzKClcbmNvbnN0IGRlZmF1bHRNaW1lVHlwZSA9ICdhcHBsaWNhdGlvbi94LW1wZWdVUkwnXG5jb25zdCBkZWZhdWx0U1dGID0gJ2xpYi9yZWQ1cHJvL3JlZDVwcm8tdmlkZW8tanMuc3dmJ1xuY29uc3Qgb3B0aW9uc1RvSGxzVVJMID0gKG9wdGlvbnMpID0+IHtcbiAgY29uc3QgcHJvdG9jb2wgPSBvcHRpb25zLmhsc3Byb3RvY29sID8gb3B0aW9ucy5obHNwcm90b2NvbCA6IG9wdGlvbnMucHJvdG9jb2xcbiAgY29uc3QgcG9ydCA9IG9wdGlvbnMuaGxzcG9ydCA/IG9wdGlvbnMuaGxzcG9ydCA6IG9wdGlvbnMucG9ydFxuICBjb25zdCBhcHBFbmRwb2ludCA9IG9wdGlvbnMuY29udGV4dCA/IFtvcHRpb25zLmFwcCwgb3B0aW9ucy5jb250ZXh0XS5qb2luKCcvJykgOiBvcHRpb25zLmFwcFxuICByZXR1cm4gYCR7cHJvdG9jb2x9Oi8vJHtvcHRpb25zLmhvc3R9OiR7cG9ydH0vJHthcHBFbmRwb2ludH0vJHtvcHRpb25zLnN0cmVhbU5hbWV9Lm0zdThgXG59XG5cbmNsYXNzIEhMU1N1YnNjcmliZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuXG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5fb3B0aW9ucyA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX3ZpZXcgPSB1bmRlZmluZWRcbiAgICB0aGlzLl92aWRlb2pzSGFuZGxlciA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX2JvdW5kQnViYmxlU3Vic2NyaWJlckV2ZW50cyA9IHRoaXMuYnViYmxlU3Vic2NyaWJlckV2ZW50cy5iaW5kKHRoaXMpXG4gIH1cblxuICBidWJibGVTdWJzY3JpYmVyRXZlbnRzIChldmVudCkge1xuICAgIHRoaXMudHJpZ2dlci5jYWxsKHRoaXMsIGV2ZW50KVxuICB9XG5cblxuICBpbml0IChvcHRpb25zKSB7XG4gICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWRQcm9taXNlKClcbiAgICBpZiAoIWVudmlyb25tZW50LmdldFZpZGVvSnMoKSkge1xuICAgICAgZGVmZXJyZWQucmVqZWN0KCdDb3VsZCBub3QgcmVzb2x2ZSBITFNTdWJzY3JpYmVyLiBSZXF1aXJlcyB2aWRlb2pzIGxpYnJhcnkuJylcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnNcbiAgICAgIGRlZmVycmVkLnJlc29sdmUodGhpcylcbiAgICB9XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2VcbiAgfVxuXG4gIHNldFZpZXcgKHZpZXcpIHtcbiAgICB0aGlzLl92aWV3ID0gdmlld1xuICAgIGlmICh0aGlzLl92aWRlb2pzSGFuZGxlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl92aWRlb2pzSGFuZGxlci5vZmYoJyonLCB0aGlzLl9ib3VuZEJ1YmJsZVN1YnNjcmliZXJFdmVudHMpXG4gICAgICB0aGlzLl92aWRlb2pzSGFuZGxlci5kaXNjb25uZWN0KClcbiAgICAgIHRoaXMuX3ZpZGVvanNIYW5kbGVyID0gdW5kZWZpbmVkXG4gICAgfVxuICAgIHRoaXMuX3ZpZGVvanNIYW5kbGVyID0gbmV3IFZpZGVvSlNIYW5kbGVyKHRoaXMuX3ZpZXcudmlldywgdGhpcy5nZXRUeXBlKCkpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHBsYXkgKHN0cmVhbU5hbWUgPSBudWxsLCBwcm9taXNlID0gbnVsbCkge1xuICAgIGNvbnN0IHAgPSBwcm9taXNlIHx8IG5ldyBEZWZlcnJlZFByb21pc2UoKVxuICAgIHRoaXMuX29wdGlvbnMuc3RyZWFtTmFtZSA9IHN0cmVhbU5hbWUgfHwgdGhpcy5fb3B0aW9ucy5zdHJlYW1OYW1lXG4gICAgbGV0IHVybCA9IG9wdGlvbnNUb0hsc1VSTCh0aGlzLl9vcHRpb25zKVxuICAgIGxldCB0eXBlID0gZGVmYXVsdE1pbWVUeXBlXG4gICAgbGV0IHN3ZlVSTCA9IGRlZmF1bHRTV0ZcbiAgICBpZiAodHlwZW9mIHRoaXMuX29wdGlvbnMgPT09ICdvYmplY3QnKSB7XG4gICAgICB0eXBlID0gdGhpcy5fb3B0aW9ucy5ydG1wTWltZVR5cGUgfHwgdGhpcy5fb3B0aW9ucy5taW1lVHlwZSB8fCB0eXBlXG4gICAgICBzd2ZVUkwgPSB0aGlzLl9vcHRpb25zLnN3ZiB8fCBzd2ZVUkxcbiAgICB9XG4gICAgZGVidWcoTkFNRSwgYFtwbGF5XTogVVJMKCR7dXJsfSkuYClcbiAgICB0aGlzLl92aWRlb2pzSGFuZGxlci5vbignKicsIHRoaXMuX2JvdW5kQnViYmxlU3Vic2NyaWJlckV2ZW50cylcbiAgICB0aGlzLl92aWRlb2pzSGFuZGxlci5hZGRTb3VyY2UodXJsLCB0eXBlLCB2aWRlb2pzLCBzd2ZVUkwpXG4gICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgIHAucmVzb2x2ZSh0aGlzKVxuICAgICAgICB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChTdWJzY3JpYmVyRXZlbnRUeXBlcy5DT05ORUNUX1NVQ0NFU1MpKVxuICAgICAgfSlcbiAgICAgIC5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgIHAucmVqZWN0KGVycm9yKVxuICAgICAgICB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChTdWJzY3JpYmVyRXZlbnRUeXBlcy5DT05ORUNUX0ZBSUxVUkUpKVxuICAgICAgfSlcbiAgICByZXR1cm4gcC5oYXNPd25Qcm9wZXJ0eSgncHJvbWlzZScpID8gcC5wcm9taXNlIDogcFxuICB9XG5cbiAgc3RvcCAoKSB7XG4gICAgZGVidWcoTkFNRSwgJ1tzdG9wXScpXG4gICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWRQcm9taXNlKClcbiAgICB0cnkge1xuICAgICAgdGhpcy5fdmlkZW9qc0hhbmRsZXIub2ZmKCcqJywgdGhpcy5fYm91bmRCdWJibGVTdWJzY3JpYmVyRXZlbnRzKVxuICAgICAgdGhpcy5fdmlkZW9qc0hhbmRsZXIuZGlzY29ubmVjdCgpXG4gICAgICBkZWZlcnJlZC5yZXNvbHZlKClcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBkZWZlcnJlZC5yZWplY3QoZS5tZXNzYWdlKVxuICAgIH1cbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZVxuICB9XG5cbiAgZ2V0VHlwZSAoKSB7XG4gICAgcmV0dXJuICdITFMnXG4gIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBITFNTdWJzY3JpYmVyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9qcy9zdWJzY3JpYmVyL3JlZDVwcm8taGxzLmpzXG4gKiovIiwiLyoqXG4gKiBCYXNlIGhhbmRsZXIgZm9yIHV0aWxpemluZyB0aGUgdmlkZW9qc1xuICogbGlicmFyeSB0byBpbnRlcmdhdGUgcGxheWJhY2sgb2YgbGl2ZSB2aWRlby5cbiAqXG4gKiBAc2VlIHJlZDVwcm8taGxzXG4gKiBAc2VlIHJlZDVwcm8tcnRtcFxuICovXG4ndXNlIHN0cmljdCdcblxuaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICcuLi9jb3JlL2V2ZW50LWVtaXR0ZXInXG5pbXBvcnQgeyBTdWJzY3JpYmVyRXZlbnQgfSBmcm9tICcuLi9ldmVudCdcbmltcG9ydCB7IFN1YnNjcmliZXJFdmVudFR5cGVzIH0gZnJvbSAnLi4vZXZlbnQnXG5pbXBvcnQgYnJvd3NlciBmcm9tICcuLi9lbnYvYnJvd3NlcidcbmltcG9ydCB7IGRlZXBEZWZpbmUgfSBmcm9tICcuLi91dGlsL29iamVjdCdcbmltcG9ydCB7IGRlYnVnLCBlcnJvciB9IGZyb20gJy4uL2xvZydcblxuY29uc3QgTkFNRSA9ICdSNVByb0Jhc2VWaWRlb0pTSGFuZGxlcidcblxuY29uc3QgdmlkZW9qcyA9IGJyb3dzZXIuZ2V0VmlkZW9KcygpXG5jb25zdCBtaW1lVHlwZSA9ICd2aWRlby93ZWJtJ1xuY29uc3Qgb3B0aW9uc1RvVVJMID0gKG9wdGlvbnMpID0+IHtcbiAgdmFyIGFwcEVuZHBvaW50ID0gb3B0aW9ucy5jb250ZXh0ID8gW29wdGlvbnMuYXBwLCBvcHRpb25zLmNvbnRleHRdLmpvaW4oJy8nKSA6IG9wdGlvbnMuYXBwXG4gIHJldHVybiBgJHtvcHRpb25zLnByb3RvY29sfTovLyR7b3B0aW9ucy5ob3N0fToke29wdGlvbnMucG9ydH0vJHthcHBFbmRwb2ludH0vJHtvcHRpb25zLnN0cmVhbU5hbWV9YFxufVxuXG5jbGFzcyBCYXNlSGFuZGxlciBleHRlbmRzIEV2ZW50RW1pdHRlcntcblxuICBjb25zdHJ1Y3RvciAodmlkZW8sIHBsYXllclR5cGUgPSBudWxsKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMudmlkZW8gPSB2aWRlb1xuICAgIHRoaXMuY2xvbmUgPSB0aGlzLnZpZGVvLmNsb25lTm9kZSh0cnVlKVxuICAgIHRoaXMuaG9sZGVyID0gdGhpcy52aWRlby5wYXJlbnROb2RlXG4gICAgdGhpcy52aWRlb2pzID0gbnVsbFxuICAgIHRoaXMuc291cmNlID0gbnVsbFxuICAgIHRoaXMucGxheWVyVHlwZSA9IHBsYXllclR5cGVcbiAgICB0aGlzLmhhc0Fzc2lnbmVkRXZlbnRMaXN0ZW5lcnMgPSBmYWxzZVxuXG4gICAgLy8gIFRPRE86IFRlbXBvcmFyeSBhZGp1c3RtZW50LiBCZXR0ZXIgdG8gcGFzcyB2aWRlb2pzIHVwIHRoZSBjaGFpbiBzbyBlbmQgdXNlcnMgY2FuIHNldCB0aGVpciBvd24gaGFuZGxlcnMuXG4gICAgdGhpcy5vblZpZGVvSlNFcnJvciA9IHRoaXMub25WaWRlb0pTRXJyb3IuYmluZCh0aGlzKVxuICAgIHRoaXMub25WaWRlb0pTTG9hZGVkRGF0YSA9IHRoaXMub25WaWRlb0pTTG9hZGVkRGF0YS5iaW5kKHRoaXMpXG4gICAgdGhpcy5vblZpZGVvSlNMb2FkZWRNZXRhZGF0YSA9IHRoaXMub25WaWRlb0pTTG9hZGVkTWV0YWRhdGEuYmluZCh0aGlzKVxuICAgIHRoaXMub25WaWRlb0pTVGltZVVwZGF0ZSA9IHRoaXMub25WaWRlb0pTVGltZVVwZGF0ZS5iaW5kKHRoaXMpXG4gICAgdGhpcy5vblZpZGVvSlNVc2VyQWN0aXZlID0gdGhpcy5vblZpZGVvSlNVc2VyQWN0aXZlLmJpbmQodGhpcylcbiAgICB0aGlzLm9uVmlkZW9KU1VzZXJJbmFjdGl2ZSA9IHRoaXMub25WaWRlb0pTVXNlckluYWN0aXZlLmJpbmQodGhpcylcbiAgICB0aGlzLm9uVmlkZW9KU1ZvbHVtZUNoYW5nZSA9IHRoaXMub25WaWRlb0pTVm9sdW1lQ2hhbmdlLmJpbmQodGhpcylcbiAgICB0aGlzLm9uVmlkZW9KU0VuZGVkID0gdGhpcy5vblZpZGVvSlNFbmRlZC5iaW5kKHRoaXMpXG4gIH1cblxuICAvLyAgQXNzaWduIGFsbCB2aWRlby5qcyBsaXN0ZW5lcnMgKHRob3NlIHdoaWNoIGFyZSBsaXN0ZWQgb24gaHR0cDovL2RvY3MudmlkZW9qcy5jb20vZG9jcy9hcGkvcGxheWVyLmh0bWwjZXZlbnRzKVxuICBhZGRWaWRlb0pTRXZlbnRMaXN0ZW5lcnMgKCkge1xuICAgIGlmICh0aGlzLmhhc0Fzc2lnbmVkRXZlbnRMaXN0ZW5lcnMpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB0aGlzLnZpZGVvanMub24oJ2Vycm9yJywgdGhpcy5vblZpZGVvSlNFcnJvcilcbiAgICB0aGlzLnZpZGVvanMub24oJ2xvYWRlZGRhdGEnLCB0aGlzLm9uVmlkZW9KU0xvYWRlZERhdGEpXG4gICAgdGhpcy52aWRlb2pzLm9uKCdsb2FkZWRtZXRhZGF0YScsIHRoaXMub25WaWRlb0pTTG9hZGVkTWV0YWRhdGEpXG4gICAgdGhpcy52aWRlb2pzLm9uKCd0aW1ldXBkYXRlJywgdGhpcy5vblZpZGVvSlNUaW1lVXBkYXRlKVxuICAgIHRoaXMudmlkZW9qcy5vbigndXNlcmFjdGl2ZScsIHRoaXMub25WaWRlb0pTVXNlckFjdGl2ZSlcbiAgICB0aGlzLnZpZGVvanMub24oJ3VzZXJpbmFjdGl2ZScsIHRoaXMub25WaWRlb0pTVXNlckluYWN0aXZlKVxuICAgIHRoaXMudmlkZW9qcy5vbigndm9sdW1lY2hhbmdlJywgdGhpcy5vblZpZGVvSlNWb2x1bWVDaGFuZ2UpXG4gICAgdGhpcy52aWRlb2pzLm9uKCdlbmRlZCcsIHRoaXMub25WaWRlb0pTRW5kZWQpXG4gICAgdGhpcy5oYXNBc3NpZ25lZEV2ZW50TGlzdGVuZXJzID0gdHJ1ZVxuICB9XG5cbiAgLy8gIFJlbW92ZSBhbGwgdmlkZW8uanMgbGlzdGVuZXJzICh0aG9zZSB3aGljaCBhcmUgbGlzdGVkIG9uIGh0dHA6Ly9kb2NzLnZpZGVvanMuY29tL2RvY3MvYXBpL3BsYXllci5odG1sI2V2ZW50cylcbiAgcmVtb3ZlVmlkZW9KU0V2ZW50TGlzdGVuZXJzICgpIHtcbiAgICBpZiAoIXRoaXMuaGFzQXNzaWduZWRFdmVudExpc3RlbmVycykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHRoaXMudmlkZW9qcy5vZmYoJ2Vycm9yJywgdGhpcy5vblZpZGVvSlNFcnJvcilcbiAgICB0aGlzLnZpZGVvanMub2ZmKCdsb2FkZWRkYXRhJywgdGhpcy5vblZpZGVvSlNMb2FkZWREYXRhKVxuICAgIHRoaXMudmlkZW9qcy5vZmYoJ2xvYWRlZG1ldGFkYXRhJywgdGhpcy5vblZpZGVvSlNMb2FkZWRNZXRhZGF0YSlcbiAgICB0aGlzLnZpZGVvanMub2ZmKCd0aW1ldXBkYXRlJywgdGhpcy5vblZpZGVvSlNUaW1lVXBkYXRlKVxuICAgIHRoaXMudmlkZW9qcy5vZmYoJ3VzZXJhY3RpdmUnLCB0aGlzLm9uVmlkZW9KU1VzZXJBY3RpdmUpXG4gICAgdGhpcy52aWRlb2pzLm9mZigndXNlcmluYWN0aXZlJywgdGhpcy5vblZpZGVvSlNVc2VySW5hY3RpdmUpXG4gICAgdGhpcy52aWRlb2pzLm9mZigndm9sdW1lY2hhbmdlJywgdGhpcy5vblZpZGVvSlNWb2x1bWVDaGFuZ2UpXG4gICAgdGhpcy52aWRlb2pzLm9mZignZW5kZWQnLCB0aGlzLm9uVmlkZW9KU0VuZGVkKVxuICAgIHRoaXMuaGFzQXNzaWduZWRFdmVudExpc3RlbmVycyA9IGZhbHNlXG4gIH1cblxuICAvLyAgQ2xlYW51cCBvdXIgPHNvdXJjZT4gaWYgaXQgZXhpc3RzXG4gIGNsZWFudXAgKCkge1xuICAgIGlmICh0aGlzLnNvdXJjZSkge1xuICAgICAgdGhpcy5zb3VyY2UucmVtb3ZlKClcbiAgICB9XG4gICAgdGhpcy5zb3VyY2UgPSBudWxsXG4gIH1cblxuICAvLyAgQ2xlYW51cCBvdXIgdmlkZW8uanMgaW1wbGVtZW50YXRpb25cbiAgY2xlYW51cFZpZGVvSlMgKCkge1xuICAgIGlmICh0aGlzLnZpZGVvanMpIHtcbiAgICAgIHRoaXMudmlkZW8ucmVtb3ZlKClcbiAgICAgIHRoaXMucmVtb3ZlVmlkZW9KU0V2ZW50TGlzdGVuZXJzKClcbiAgICAgIHRoaXMudmlkZW9qcy5kaXNwb3NlKClcbiAgICAgIC8vICBUaGlzIHJlY3JlYXRlcyBvdXIgb3JpZ2luYWwgPHZpZGVvPiBlbGVtZW50IGFuZCBhcHBlbmRzIGl0IHRvIHRoZSBvcmlnaW5hbCBjb250YWluaW5nIGVsZW1lbnRcbiAgICAgIHRoaXMudmlkZW8gPSB0aGlzLmNsb25lLmNsb25lTm9kZSh0cnVlKVxuICAgICAgdGhpcy5ob2xkZXIuYXBwZW5kQ2hpbGQodGhpcy52aWRlbylcbiAgICB9XG4gICAgdGhpcy52aWRlb2pzID0gbnVsbFxuICB9XG5cbiAgLy8gIEFkZCBhIG5ldyA8c291cmNlPiBmb3Igb3VyIDx2aWRlbz4gYW5kIHN0YXJ0dXAgdmlkZW8uanNcbiAgYWRkU291cmNlIChzcmMsIHR5cGUgPSBtaW1lVHlwZSwgdmlkZW9JbXBsID0gdmlkZW9qcywgc3dmVVJMID0gbnVsbCkge1xuICAgIGxldCBzZWxmID0gdGhpc1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlU291cmNlIChfc3JjLCBfdHlwZSkge1xuICAgICAgbGV0IHNvdXJjZUVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc291cmNlJylcbiAgICAgIHNvdXJjZUVsLnNyYyA9IF9zcmNcbiAgICAgIHNvdXJjZUVsLnR5cGUgPSBfdHlwZVxuICAgICAgcmV0dXJuIHNvdXJjZUVsXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zZXJ0U291cmNlSW50byAoX3NyYywgX3R5cGUsIF9wYXJlbnQpIHtcbiAgICAgIGxldCBzb3VyY2VFbCA9IGNyZWF0ZVNvdXJjZShfc3JjLCBfdHlwZSlcbiAgICAgIGlmIChfcGFyZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgX3BhcmVudC5pbnNlcnRCZWZvcmUoc291cmNlRWwsIF9wYXJlbnQuZmlyc3RDaGlsZClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9wYXJlbnQuYXBwZW5kQ2hpbGQoc291cmNlRWwpXG4gICAgICB9XG4gICAgICByZXR1cm4gc291cmNlRWxcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gIElmIHdlIGhhdmUgYSBjdXJyZW50IDxzb3VyY2U+IGVsZW1lbnQsIHJlbW92ZSBpdFxuICAgICAgICBzZWxmLmNsZWFudXAoKVxuICAgICAgICAvLyAgSWYgdmlkZW8uanMgaGFzIGFscmVhZHkgYmVlbiBpbnN0YW50aWF0ZWQsIGRpc3Bvc2Ugb2YgaXRcbiAgICAgICAgc2VsZi5jbGVhbnVwVmlkZW9KUygpXG5cbiAgICAgICAgLy8gIENyZWF0ZSB0aGUgbmV3IDxzb3VyY2U+IGVsZW1lbnRcbiAgICAgICAgY29uc3Qgc3JjVVJMID0gdHlwZW9mIHNyYyA9PT0gJ3N0cmluZycgPyBzcmMgOiBvcHRpb25zVG9VUkwoc3JjKVxuICAgICAgICBjb25zdCBtaW1lVHlwZSA9IHR5cGVvZiBzcmMgPT09ICdzdHJpbmcnID8gdHlwZSA6ICgoc3JjLm1pbWVUeXBlKSA/IHNyYy5taW1lVHlwZSA6IHR5cGUpXG4gICAgICAgIGRlYnVnKE5BTUUsIGBcIiR7c2VsZi5wbGF5ZXJUeXBlfVwiIGxvYWRpbmcgJHtzcmNVUkx9YClcbiAgICAgICAgc2VsZi5zb3VyY2UgPSBpbnNlcnRTb3VyY2VJbnRvKHNyY1VSTCwgbWltZVR5cGUsIHNlbGYudmlkZW8pXG5cbiAgICAgICAgLy8gIEluc3RhbnRpYXRlIHZpZGVvLmpzXG4gICAgICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICAgICAgdGVjaE9yZGVyOiBbJ2h0bWw1JywgJ2ZsYXNoJ11cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3dmVVJMKSB7XG4gICAgICAgICAgZGVlcERlZmluZSh2aWRlb0ltcGwsIFsnb3B0aW9ucycsICdmbGFzaCcsICdzd2YnXSwgc3dmVVJMKVxuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi52aWRlb2pzID0gdmlkZW9JbXBsKHNlbGYudmlkZW8sIG9wdHMsICgpID0+IHtcbiAgICAgICAgICBkZWJ1ZyhOQU1FLCAndmlkZW9KUyBlbWJlZCBjb21wbGV0ZS4nKVxuICAgICAgICAgIHJlc29sdmUoc2VsZilcbiAgICAgICAgfSlcbiAgICAgICAgc2VsZi5hZGRWaWRlb0pTRXZlbnRMaXN0ZW5lcnMoKVxuICAgICAgfVxuICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgZXJyb3IoTkFNRSwgYENvdWxkIG5vdCBpbnN0YW50aWF0ZSBuZXcgVmlkZW9KUy1iYXNlZCBcIiR7c2VsZi5wbGF5ZXJUeXBlfVwiIFBsYXllci5cXG5SZWFzb246ICR7ZS5tZXNzYWdlfWApXG4gICAgICAgIHJlamVjdChgQ291bGQgbm90IGluc3RhbnRpYXRlIG5ldyBWaWRlb0pTLWJhc2VkIFwiJHtzZWxmLnBsYXllclR5cGV9XCIgUGxheWVyLlxcblJlYXNvbjogJHtlLm1lc3NhZ2V9YClcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgb25WaWRlb0pTRXJyb3IgKGUpIHtcbiAgICBlcnJvcihOQU1FLCAnb25WaWRlb0pTRXJyb3I6ICcgKyBKU09OLnN0cmluZ2lmeShlLCBudWxsLCAyKSlcbiAgICB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChTdWJzY3JpYmVyRXZlbnRUeXBlcy5TVUJTQ1JJQkVfRkFJTCwgZSkpXG4gIH1cblxuICBvblZpZGVvSlNMb2FkZWREYXRhICgpIHtcbiAgICB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChTdWJzY3JpYmVyRXZlbnRUeXBlcy5TVUJTQ1JJQkVfU1RBUlQpKVxuICB9XG5cbiAgb25WaWRlb0pTRW5kZWQgKCkge1xuICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFN1YnNjcmliZXJFdmVudFR5cGVzLlNVQlNDUklCRV9TVE9QKSlcbiAgfVxuXG4gIG9uVmlkZW9KU0xvYWRlZE1ldGFkYXRhICgpIHt9XG5cbiAgb25WaWRlb0pTVGltZVVwZGF0ZSAoKSB7fVxuXG4gIG9uVmlkZW9KU1VzZXJBY3RpdmUgKCkge31cblxuICBvblZpZGVvSlNVc2VySW5hY3RpdmUgKCkge31cblxuICBvblZpZGVvSlNWb2x1bWVDaGFuZ2UgKCkge31cblxuICBnZXRUeXBlICgpIHtcbiAgICByZXR1cm4gdGhpcy5wbGF5ZXJUeXBlXG4gIH1cblxuICBkaXNjb25uZWN0ICgpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy52aWRlby5wYXVzZSgpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gbmFkYS5cbiAgICB9XG4gICAgdGhpcy5jbGVhbnVwKClcbiAgICB0aGlzLmNsZWFudXBWaWRlb0pTKClcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBCYXNlSGFuZGxlclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvanMvc3Vic2NyaWJlci92aWRlb2pzLXNvdXJjZS1oYW5kbGVyLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogTW9kaWZpZXMgdGFyZ2V0IGBvYmplY3RgIGluIHBsYWNlIHdpdGggYSBuYW1lc3BhY2VkIHZhbHVlLlxuICovXG5leHBvcnQgY29uc3QgZGVlcERlZmluZSA9IChvYmplY3QsIHBhdGhzLCB2YWx1ZSkgPT4ge1xuICBsZXQgaSA9IDBcbiAgbGV0IHRhaWwgPSBvYmplY3RcbiAgY29uc3QgcHJvcCA9IHBhdGhzLnBvcCgpXG4gIGNvbnN0IGxlbmd0aCA9IHBhdGhzLmxlbmd0aFxuICBmb3IgKGk7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGxldCBwYXRoID0gcGF0aHNbaV1cbiAgICB0YWlsW3BhdGhdID0gdGFpbFtwYXRoXSB8fCB7fVxuICAgIHRhaWwgPSB0YWlsW3BhdGhdXG4gIH1cbiAgdGFpbFtwcm9wXSA9IHZhbHVlXG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9qcy91dGlsL29iamVjdC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJy4uL2NvcmUvZXZlbnQtZW1pdHRlcidcbmltcG9ydCBWaWRlb0pTU3Vic2NyaWJlciBmcm9tICcuL3JlZDVwcm8tcnRtcC12aWRlb2pzJ1xuaW1wb3J0IFI1TGl2ZVN1YnNjcmliZXIgZnJvbSAnLi9yZWQ1cHJvLXJ0bXAtbGl2ZSdcbmltcG9ydCB7IGRlYnVnIH0gZnJvbSAnLi4vbG9nJ1xuXG5jb25zdCBOQU1FID0gJ1I1UHJvUlRNUFN1YnNjcmliZXJQcm94eSdcblxuY2xhc3MgUlRNUFN1YnNjcmliZXJQcm94eSBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG5cbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLl92aWV3ID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fYm91bmRCdWJibGVTdWJJbXBsRXZlbnQgPSB0aGlzLmJ1YmJsZVN1YnNjcmliZXJFdmVudC5iaW5kKHRoaXMpXG4gIH1cblxuICBpbml0IChvcHRpb25zKSB7XG4gICAgbGV0IGltcGxcbiAgICBkZWJ1ZyhOQU1FLCBgT3B0aW9ucyBwcm9wZXJ0eSBmb3IgdXNlVmlkZW9KUzogJHtvcHRpb25zLnVzZVZpZGVvSlN9LmApXG4gICAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ3VzZVZpZGVvSlMnKSAmJiB0eXBlb2Ygb3B0aW9ucy51c2VWaWRlb0pTID09PSAnYm9vbGVhbicgJiYgIW9wdGlvbnMudXNlVmlkZW9KUykge1xuICAgICAgZGVidWcoTkFNRSwgJ0RlZmF1bHRpbmcgdG8gUlRNUFN1YnNjcmliZXIgdXNpbmcgY3VzdG9tIGxpdmUgU1dGLicpXG4gICAgICBpbXBsID0gbmV3IFI1TGl2ZVN1YnNjcmliZXIoKVxuICAgICAgaW1wbC5vbignKicsIHRoaXMuX2JvdW5kQnViYmxlU3ViSW1wbEV2ZW50KVxuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1ZyhOQU1FLCAnRGVmYXVsdCB0byBSVE1QU3Vic2NyaWJlciB1c2luZyB2aWRlb2pzIHN1cHBvcnQuJylcbiAgICAgIGltcGwgPSBuZXcgVmlkZW9KU1N1YnNjcmliZXIoKVxuICAgICAgaW1wbC5vbignKicsIHRoaXMuX2JvdW5kQnViYmxlU3ViSW1wbEV2ZW50KVxuICAgIH1cbiAgICBpZiAodGhpcy5fdmlldykge1xuICAgICAgaW1wbC5zZXRWaWV3KHRoaXMuX3ZpZXcpXG4gICAgICB0aGlzLl92aWV3ID0gdW5kZWZpbmVkXG4gICAgfVxuICAgIHJldHVybiBpbXBsLmluaXQob3B0aW9ucylcbiAgfVxuXG4gIHNldFZpZXcgKHZpZXcpIHtcbiAgICB0aGlzLl92aWV3ID0gdmlld1xuICB9XG5cbiAgYnViYmxlU3Vic2NyaWJlckV2ZW50IChzdWJzY3JpYmVyRXZlbnQpIHtcbiAgICB0aGlzLnRyaWdnZXIuY2FsbCh0aGlzLCBzdWJzY3JpYmVyRXZlbnQpXG4gIH1cblxuICBnZXRUeXBlICgpIHtcbiAgICByZXR1cm4gJ1JUTVBTdWJzY3JpYmVyUHJveHknXG4gIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBSVE1QU3Vic2NyaWJlclByb3h5XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9qcy9zdWJzY3JpYmVyL3JlZDVwcm8tcnRtcC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgZW52aXJvbm1lbnQgZnJvbSAnLi4vZW52L2Jyb3dzZXInXG5pbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJy4uL2NvcmUvZXZlbnQtZW1pdHRlcidcbmltcG9ydCBWaWRlb0pTSGFuZGxlciBmcm9tICcuL3ZpZGVvanMtc291cmNlLWhhbmRsZXInXG5pbXBvcnQgeyBEZWZlcnJlZFByb21pc2UgfSBmcm9tICcuLi91dGlsL3Byb21pc2UnXG5pbXBvcnQgeyBkZWJ1ZyB9IGZyb20gJy4uL2xvZydcblxuY29uc3QgTkFNRSA9ICdSNVByb1JUTVBTdWJzY3JpYmVyJ1xuY29uc3QgdmlkZW9qcyA9IGVudmlyb25tZW50LmdldFZpZGVvSnMoKVxuY29uc3QgZGVmYXVsdE1pbWVUeXBlID0gJ3J0bXAvZmx2J1xuY29uc3QgZGVmYXVsdEZsYXNoVmVyc2lvbiA9ICcxMC4wLjAnXG5jb25zdCBkZWZhdWx0U1dGID0gJ2xpYi9yZWQ1cHJvL3JlZDVwcm8tdmlkZW8tanMuc3dmJ1xuY29uc3Qgb3B0aW9uc1RvUnRtcFVSTCA9IChvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHByb3RvY29sID0gb3B0aW9ucy5ydG1wcHJvdG9jb2wgPyBvcHRpb25zLnJ0bXBwcm90b2NvbCA6IG9wdGlvbnMucHJvdG9jb2xcbiAgY29uc3QgcG9ydCA9IG9wdGlvbnMucnRtcHBvcnQgPyBvcHRpb25zLnJ0bXBwb3J0IDogb3B0aW9ucy5wb3J0XG4gIGNvbnN0IGFwcEVuZHBvaW50ID0gb3B0aW9ucy5jb250ZXh0ID8gW29wdGlvbnMuYXBwLCBvcHRpb25zLmNvbnRleHRdLmpvaW4oJy8nKSA6IG9wdGlvbnMuYXBwXG4gIHJldHVybiBgJHtwcm90b2NvbH06Ly8ke29wdGlvbnMuaG9zdH06JHtwb3J0fS8ke2FwcEVuZHBvaW50fS8ke29wdGlvbnMuc3RyZWFtTmFtZX1gXG59XG5cbmNsYXNzIFZpZGVvSlNTdWJzY3JpYmVyIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcblxuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuX29wdGlvbnMgPSB1bmRlZmluZWRcbiAgICB0aGlzLl92aWV3ID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fdmlkZW9qc0hhbmRsZXIgPSB1bmRlZmluZWRcbiAgICB0aGlzLl9ib3VuZEJ1YmJsZVN1YnNjcmliZXJFdmVudHMgPSB0aGlzLmJ1YmJsZVN1YnNjcmliZXJFdmVudHMuYmluZCh0aGlzKVxuICB9XG5cbiAgYnViYmxlU3Vic2NyaWJlckV2ZW50cyAoZXZlbnQpIHtcbiAgICB0aGlzLnRyaWdnZXIuY2FsbCh0aGlzLCBldmVudClcbiAgfVxuXG4gIGluaXQgKG9wdGlvbnMpIHtcbiAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZFByb21pc2UoKVxuICAgIGlmICghZW52aXJvbm1lbnQuc3VwcG9ydHNGbGFzaFZlcnNpb24oZGVmYXVsdEZsYXNoVmVyc2lvbikpIHtcbiAgICAgIGRlZmVycmVkLnJlamVjdChgQ291bGQgbm90IHJlc29sdmUgUlRNUFN1YnNjcmliZXIgaW5zdGFuY2UuIFJlcXVpcmVzIG1pbmltdW0gRmxhc2ggUGxheWVyIGluc3RhbGwgb2YgJHtkZWZhdWx0Rmxhc2hWZXJzaW9ufS5gKVxuICAgIH0gZWxzZSBpZiAoIWVudmlyb25tZW50LmdldFZpZGVvSnMoKSkge1xuICAgICAgZGVmZXJyZWQucmVqZWN0KCdDb3VsZCBub3QgcmVzb2x2ZSBSVE1QU3Vic2NyaWJlciBpbnN0YW5jZS4gUmVxdWlyZXMgdmlkZW9qcyBsaWJyYXJ5LicpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zXG4gICAgICBkZWZlcnJlZC5yZXNvbHZlKHRoaXMpXG4gICAgfVxuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlXG4gIH1cblxuICBzZXRWaWV3ICh2aWV3KSB7XG4gICAgdGhpcy5fdmlldyA9IHZpZXdcbiAgICBpZiAodGhpcy5fdmlkZW9qc0hhbmRsZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fdmlkZW9qc0hhbmRsZXIub2ZmKCcqJywgdGhpcy5fYm91bmRCdWJibGVTdWJzY3JpYmVyRXZlbnRzKVxuICAgICAgdGhpcy5fdmlkZW9qc0hhbmRsZXIuZGlzY29ubmVjdCgpXG4gICAgICB0aGlzLl92aWRlb2pzSGFuZGxlciA9IHVuZGVmaW5lZFxuICAgIH1cbiAgICBpZiAodmlldykge1xuICAgICAgdGhpcy5fdmlkZW9qc0hhbmRsZXIgPSBuZXcgVmlkZW9KU0hhbmRsZXIodGhpcy5fdmlldy52aWV3LCB0aGlzLmdldFR5cGUoKSlcbiAgICB9XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHBsYXkgKHN0cmVhbU5hbWUgPSBudWxsLCBwcm9taXNlID0gbnVsbCkge1xuICAgIGNvbnN0IHAgPSBwcm9taXNlIHx8IG5ldyBEZWZlcnJlZFByb21pc2UoKVxuICAgIHRoaXMuX29wdGlvbnMuc3RyZWFtTmFtZSA9IHN0cmVhbU5hbWUgfHwgdGhpcy5fb3B0aW9ucy5zdHJlYW1OYW1lXG4gICAgbGV0IHVybCA9IG9wdGlvbnNUb1J0bXBVUkwodGhpcy5fb3B0aW9ucylcbiAgICBsZXQgdHlwZSA9IGRlZmF1bHRNaW1lVHlwZVxuICAgIGxldCBzd2ZVUkwgPSBkZWZhdWx0U1dGXG4gICAgaWYgKHR5cGVvZiB0aGlzLl9vcHRpb25zID09PSAnb2JqZWN0Jykge1xuICAgICAgdHlwZSA9IHRoaXMuX29wdGlvbnMucnRtcE1pbWVUeXBlIHx8IHRoaXMuX29wdGlvbnMubWltZVR5cGUgfHwgdHlwZVxuICAgICAgc3dmVVJMID0gdGhpcy5fb3B0aW9ucy5zd2YgfHwgc3dmVVJMXG4gICAgfVxuICAgIGRlYnVnKE5BTUUsIGBbcGxheV06IFVSTCgke3VybH0pLmApXG4gICAgdGhpcy5fdmlkZW9qc0hhbmRsZXIub24oJyonLCB0aGlzLl9ib3VuZEJ1YmJsZVN1YnNjcmliZXJFdmVudHMpXG4gICAgdGhpcy5fdmlkZW9qc0hhbmRsZXIuYWRkU291cmNlKHVybCwgdHlwZSwgdmlkZW9qcywgc3dmVVJMKVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICBwLnJlc29sdmUodGhpcylcbiAgICAgIH0pXG4gICAgICAuY2F0Y2gocC5yZWplY3QpXG4gICAgcmV0dXJuIHAuaGFzT3duUHJvcGVydHkoJ3Byb21pc2UnKSA/IHAucHJvbWlzZSA6IHBcbiAgfVxuXG4gIHN0b3AgKCkge1xuICAgIGRlYnVnKE5BTUUsICdbc3RvcF0nKVxuICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkUHJvbWlzZSgpXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuX3ZpZGVvanNIYW5kbGVyLm9mZignKicsIHRoaXMuX2JvdW5kQnViYmxlU3Vic2NyaWJlckV2ZW50cylcbiAgICAgIHRoaXMuX3ZpZGVvanNIYW5kbGVyLmRpc2Nvbm5lY3QoKVxuICAgICAgZGVmZXJyZWQucmVzb2x2ZSgpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZGVmZXJyZWQucmVqZWN0KGUubWVzc2FnZSlcbiAgICB9XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2VcbiAgfVxuXG4gIGdldFR5cGUgKCkge1xuICAgIHJldHVybiAnUlRNUCdcbiAgfVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFZpZGVvSlNTdWJzY3JpYmVyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9qcy9zdWJzY3JpYmVyL3JlZDVwcm8tcnRtcC12aWRlb2pzLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5cbmltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnLi4vY29yZS9ldmVudC1lbWl0dGVyJ1xuaW1wb3J0IHsgU3Vic2NyaWJlckV2ZW50IH0gZnJvbSAnLi4vZXZlbnQnXG5pbXBvcnQgZW52aXJvbm1lbnQgZnJvbSAnLi4vZW52L2Jyb3dzZXInXG5pbXBvcnQgeyBEZWZlcnJlZFByb21pc2UgfSBmcm9tICcuLi91dGlsL3Byb21pc2UnXG5pbXBvcnQgTGl2ZVNvdXJjZUhhbmRsZXIgZnJvbSAnLi9saXZlLXNvdXJjZS1oYW5kbGVyJ1xuaW1wb3J0IHsgU3Vic2NyaWJlckV2ZW50VHlwZXMsIFJUTVBTdWJzY3JpYmVyRXZlbnRUeXBlcyB9IGZyb20gJy4uL2V2ZW50J1xuaW1wb3J0IHsgZGVidWcsIGVycm9yIH0gZnJvbSAnLi4vbG9nJ1xuXG5jb25zdCBOQU1FID0gJ1I1UHJvTGl2ZVJUTVBTdWJjcmliZXInXG5jb25zdCBzd2ZJZCA9ICdSVE1QU3Vic2NyaWJlcidcbmNvbnN0IGRlZmF1bHRGbGFzaFZlcnNpb24gPSAnMTAuMC4wJ1xuY29uc3QgZGVmYXVsdFNXRiA9ICdsaWIvcmVkNXByby9yZWQ1cHJvLXN1YnNjcmliZXIuc3dmJ1xuY29uc3Qgc3dmb2JqZWN0VVJMID0gJ2xpYi9zd2ZvYmplY3Qvc3dmb2JqZWN0LmpzJ1xuY29uc3QgcHJvZHVjdEluc3RhbGxVUkwgPSAnbGliL3N3Zm9iamVjdC9wbGF5ZXJQcm9kdWN0SW5zdGFsbC5zd2YnXG5cbmNsYXNzIFI1TGl2ZVN1YnNjcmliZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXJ7XG5cbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLl9vcHRpb25zID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fdmlldyA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX3NvdXJjZUhhbmRsZXIgPSB1bmRlZmluZWRcbiAgfVxuXG4gIGluaXQgKG9wdGlvbnMpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpc1xuICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkUHJvbWlzZSgpXG4gICAgY29uc3QgdmVyc2lvbiA9IG9wdGlvbnMubWluRmxhc2hWZXJzaW9uIHx8IGRlZmF1bHRGbGFzaFZlcnNpb25cbiAgICBpZiAoIWVudmlyb25tZW50LnN1cHBvcnRzRmxhc2hWZXJzaW9uKHZlcnNpb24pKSB7XG4gICAgICBkZWZlcnJlZC5yZWplY3QoYENvdWxkIG5vdCByZXNvbHZlIExpdmVSVE1QU3Vic2NyaWJlciBpbnN0YW5jZS4gUmVxdWlyZXMgbWluaW11bSBGbGFzaCBQbGF5ZXIgaW5zdGFsbCBvZiAke3ZlcnNpb259LmApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zXG4gICAgICB0aGlzLl9vcHRpb25zLnN3ZiA9IHRoaXMuX29wdGlvbnMuc3dmIHx8IGRlZmF1bHRTV0ZcbiAgICAgIHRoaXMuX29wdGlvbnMubWluRmxhc2hWZXJzaW9uID0gdmVyc2lvblxuICAgICAgdGhpcy5fb3B0aW9ucy5zd2ZvYmplY3RVUkwgPSB0aGlzLl9vcHRpb25zLnN3Zm9iamVjdFVSTCB8fCBzd2ZvYmplY3RVUkxcbiAgICAgIHRoaXMuX29wdGlvbnMucHJvZHVjdEluc3RhbGxVUkwgPSB0aGlzLl9vcHRpb25zLnByb2R1Y3RJbnN0YWxsVVJMIHx8IHByb2R1Y3RJbnN0YWxsVVJMXG4gICAgICB0cnkge1xuICAgICAgICBlbnZpcm9ubWVudC5pbmplY3RTY3JpcHQodGhpcy5fb3B0aW9ucy5zd2ZvYmplY3RVUkwpXG4gICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgZGVidWcoTkFNRSwgJ1NXRk9iamVjdCBlbWJlZGRlZC4nKVxuICAgICAgICAgICAgaWYgKHNlbGYuX3NvdXJjZUhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX3NvdXJjZUhhbmRsZXIuYWRkU291cmNlKHN3ZklkLCBzZWxmLl9vcHRpb25zKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICB9KVxuICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoc2VsZilcbiAgICAgICAgICAgIHNlbGYudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFJUTVBTdWJzY3JpYmVyRXZlbnRUeXBlcy5FTUJFRF9TVUNDRVNTLCBzZWxmKSlcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgZXJyb3IoTkFNRSwgYENvdWxkIG5vdCBlbWJlZCBGbGFzaC1iYXNlZCBSVE1QIFBsYXllci4gUmVhc29uOiAke2Vycn1gKVxuICAgICAgICAgICAgaWYgKHNlbGYuX3NvdXJjZUhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgc2VsZi5fc291cmNlSGFuZGxlci5kaXNjb25uZWN0KClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KGVycilcbiAgICAgICAgICAgIHNlbGYudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFJUTVBTdWJzY3JpYmVyRXZlbnRUeXBlcy5FTUJFRF9GQUlMVVJFLCBzZWxmKSlcbiAgICAgICAgICB9KVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBkZWZlcnJlZC5yZWplY3QoYENvdWxkIG5vdCBpbmplY3QgRmxhc2gtYmFzZWQgUGxheWVyIGludG8gdGhlIHBhZ2UuIFJlYXNvbjogJHtlLm1lc3NhZ2V9YClcbiAgICAgICAgc2VsZi50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoUlRNUFN1YnNjcmliZXJFdmVudFR5cGVzLkVNQkVEX0ZBSUxVUkUsIHNlbGYpKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZVxuICB9XG5cbiAgc2V0VmlldyAodmlldykge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzXG4gICAgdGhpcy5fdmlldyA9IHZpZXdcbiAgICBpZiAodGhpcy5fc291cmNlSGFuZGxlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl9zb3VyY2VIYW5kbGVyLmRpc2Nvbm5lY3QoKVxuICAgICAgdGhpcy5fc291cmNlSGFuZGxlciA9IHVuZGVmaW5lZFxuICAgIH1cblxuICAgIGlmICh2aWV3KSB7XG4gICAgICB0aGlzLl9zb3VyY2VIYW5kbGVyID0gbmV3IExpdmVTb3VyY2VIYW5kbGVyKHRoaXMuX3ZpZXcudmlldywgdGhpcy5nZXRUeXBlKCkpXG4gICAgICBpZiAodGhpcy5fb3B0aW9ucykge1xuICAgICAgICB0aGlzLl9zb3VyY2VIYW5kbGVyLmFkZFNvdXJjZShzd2ZJZCwgdGhpcy5fb3B0aW9ucylcbiAgICAgICAgICAuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgICAgc2VsZi50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoUlRNUFN1YnNjcmliZXJFdmVudFR5cGVzLkVNQkVEX0ZBSUxVUkUsIHNlbGYpKVxuXG4gICAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIF9lc3RhYmxpc2hFeHRJbnRIYW5kbGVycyAoKSB7XG4gICAgY29uc3QgaWQgPSB0aGlzLl9vcHRpb25zLnN0cmVhbU5hbWVcbiAgICBjb25zdCBpbnZva2VGbiA9IChsYWJlbCkgPT4ge1xuICAgICAgcmV0dXJuIFsnc3Vic2NyaWJlcicsIGxhYmVsLCBpZF0uam9pbignXycpXG4gICAgfVxuICAgIHdpbmRvd1tpbnZva2VGbigncjVwcm9Db25uZWN0U3VjY2VzcycpXSA9ICgpID0+IHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFN1YnNjcmliZXJFdmVudFR5cGVzLkNPTk5FQ1RfU1VDQ0VTUykpXG4gICAgd2luZG93W2ludm9rZUZuKCdyNXByb0Nvbm5lY3RGYWlsdXJlJyldID0gKCkgPT4gdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoU3Vic2NyaWJlckV2ZW50VHlwZXMuQ09OTkVDVF9GQUlMVVJFKSlcbiAgICB3aW5kb3dbaW52b2tlRm4oJ3I1cHJvU3Vic2NyaWJlU3RhcnQnKV0gPSAoKSA9PiB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChTdWJzY3JpYmVyRXZlbnRUeXBlcy5TVUJTQ1JJQkVfU1RBUlQpKVxuICAgIHdpbmRvd1tpbnZva2VGbigncjVwcm9TdWJzY3JpYmVTdG9wJyldID0gKCkgPT4gdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoU3Vic2NyaWJlckV2ZW50VHlwZXMuU1VCU0NSSUJFX1NUT1ApKVxuICAgIHdpbmRvd1tpbnZva2VGbigncjVwcm9TdWJzY3JpYmVGYWlsJyldID0gKCkgPT4gdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoU3Vic2NyaWJlckV2ZW50VHlwZXMuU1VCU0NSSUJFX0ZBSUwpKVxuICAgIHdpbmRvd1tpbnZva2VGbigncjVwcm9TdWJzY3JpYmVJbnZhbGlkTmFtZScpXSA9KCkgPT4gdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoU3Vic2NyaWJlckV2ZW50VHlwZXMuU1VCU0NSSUJFX0lOVkFMSURfTkFNRSkpXG4gIH1cblxuICBwbGF5IChzdHJlYW1OYW1lID0gbnVsbCwgcHJvbWlzZSA9IG51bGwpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIHRoaXMuX2VzdGFibGlzaEV4dEludEhhbmRsZXJzKClcbiAgICB0aGlzLl9zb3VyY2VIYW5kbGVyLmNvbm5lY3QoKVxuICAgIGNvbnN0IGNiID0gKHJlc29sdmUpID0+IHtcbiAgICAgIHJlc29sdmUodGhpcylcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGNiKVxuICB9XG5cbiAgc3RvcCAoKSB7XG4gICAgLy8gTGl2ZSBzdWJzY2liZXIuc3dmIHByZXZpb3VzbHkgY3JlYXRlZCBmb3IgUmVkNSBQcm8gZXhhbXBsZXMgY291bGQgdXNlIHNvbWUgbG92ZSB3aXRoIGFuIGludm9jYXRpb24gQVBJLlxuICAgIGNvbnN0IGNiID0gKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5fc291cmNlSGFuZGxlci5kaXNjb25uZWN0KClcbiAgICAgICAgcmVzb2x2ZSgpXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlLm1lc3NhZ2UpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZShjYilcbiAgfVxuXG4gIGdldFR5cGUgKCkge1xuICAgIHJldHVybiAnTGl2ZVJUTVAnXG4gIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBSNUxpdmVTdWJzY3JpYmVyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9qcy9zdWJzY3JpYmVyL3JlZDVwcm8tcnRtcC1saXZlLmpzXG4gKiovIiwiJ3VzZSBzY3JpcHQnXG5cbmltcG9ydCAqIGFzIGVtYmVkIGZyb20gJy4uL2Vudi9lbWJlZCdcbmltcG9ydCBlbnZpcm9ubWVudCBmcm9tICcuLi9lbnYvYnJvd3NlcidcbmltcG9ydCB7IERlZmVycmVkUHJvbWlzZSB9IGZyb20gJy4uL3V0aWwvcHJvbWlzZSdcbmltcG9ydCB7IGRlYnVnIH0gZnJvbSAnLi4vbG9nJ1xuXG5jb25zdCBOQU1FID0gJ1JUTVBMaXZlU291cmNlSGFuZGxlcidcblxuY2xhc3MgTGl2ZVNvdXJjZUhhbmRsZXIge1xuXG4gIGNvbnN0cnVjdG9yICh2aWRlbywgdHlwZSkge1xuICAgIHRoaXMudmlkZW8gPSB2aWRlb1xuICAgIHRoaXMuY2xvbmUgPSB0aGlzLnZpZGVvLmNsb25lTm9kZSh0cnVlKVxuICAgIHRoaXMuaG9sZGVyID0gdGhpcy52aWRlby5wYXJlbnROb2RlXG4gICAgdGhpcy5wbGF5ZXJUeXBlID0gdHlwZVxuICB9XG5cbiAgY2xlYW5VcCAoKSB7XG4gICAgLy8gUmV0dXJuIHRvIHByaW9yIERPTSBtYW5pcHVsYXRpb24uXG4gICAgdGhpcy52aWRlby5yZW1vdmUoKVxuICAgIHRoaXMudmlkZW8gPSB0aGlzLmNsb25lLmNsb25lTm9kZSh0cnVlKVxuICAgIHRoaXMuaG9sZGVyLmFwcGVuZENoaWxkKHRoaXMudmlkZW8pXG4gIH1cblxuICBfc2V0VXBJbml0Q2FsbGJhY2sgKHByb21pc2UpIHtcbiAgICB3aW5kb3cuc2V0U3Vic2NyaWJlcklkID0gKHN1Y2Nlc3NJZCkgPT4ge1xuICAgICAgLy8gc3VjY2Vzc0lkID09PSBfb3B0aW9ucy5zdHJlYW1OYW1lXG4gICAgICBkZWJ1ZyhOQU1FLCBgRW1iZWQgYW5kIGluaXQoKSBjb21wbGV0ZSBmb3Igc3Vic2NyaWJlciBzd2YuIHN1Y2Nlc3NJZCgke3N1Y2Nlc3NJZH0pLmApXG4gICAgICBwcm9taXNlLnJlc29sdmUoc3VjY2Vzc0lkKVxuICAgICAgdGhpcy5fdGVhckRvd25Jbml0Q2FsbGJhY2soKVxuICAgIH1cbiAgICAvLyBUT0RPOiBTZXR1cCB0aW1lb3V0IHRvIHJlamVjdD9cbiAgfVxuXG4gIF90ZWFyRG93bkluaXRDYWxsYmFjayAoKSB7XG4gICAgd2luZG93LnNldEFjdGl2ZUlkID0gdW5kZWZpbmVkXG4gIH1cblxuICBhZGRTb3VyY2UgKHN3ZklkLCBvcHRpb25zLCBzd2ZVcmwgPSBudWxsLCBtaW5GbGFzaFZlcnNpb24gPSBudWxsKSB7XG4gICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWRQcm9taXNlKClcbiAgICBvcHRpb25zLnN3ZiA9IHN3ZlVybCB8fCBvcHRpb25zLnN3ZlxuICAgIG9wdGlvbnMubWluRmxhc2hWZXJzaW9uID0gbWluRmxhc2hWZXJzaW9uIHx8IG9wdGlvbnMubWluRmxhc2hWZXJzaW9uXG4gICAgdGhpcy5fc2V0VXBJbml0Q2FsbGJhY2soZGVmZXJyZWQpXG4gICAgZW1iZWQuZGVmaW5lRW1iZWRFbGVtZW50KHRoaXMudmlkZW8sIHRoaXMuaG9sZGVyKVxuICAgICAgLnRoZW4oZWxlbWVudElkID0+IHtcbiAgICAgICAgbGV0IGZsYXNodmFycyA9IHtcbiAgICAgICAgICBzdHJlYW06IG9wdGlvbnMuc3RyZWFtTmFtZSxcbiAgICAgICAgICBhcHA6IG9wdGlvbnMuY29udGV4dCA/IGAke29wdGlvbnMuYXBwfS8ke29wdGlvbnMuY29udGV4dH1gIDogb3B0aW9ucy5hcHAsXG4gICAgICAgICAgaG9zdDogb3B0aW9ucy5ob3N0XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuYnVmZmVyICYmICFpc05hTihOdW1iZXIob3B0aW9ucy5idWZmZXIpKSkge1xuICAgICAgICAgIGZsYXNodmFycy5idWZmZXIgPSBvcHRpb25zLmJ1ZmZlclxuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLndpZHRoICYmICFpc05hTihOdW1iZXIob3B0aW9ucy53aWR0aCkpKSB7XG4gICAgICAgICAgZmxhc2h2YXJzLndpZHRoID0gb3B0aW9ucy53aWR0aFxuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmhlaWdodCAmJiAhaXNOYU4oTnVtYmVyKG9wdGlvbnMuaGVpZ2h0KSkpIHtcbiAgICAgICAgICBmbGFzaHZhcnMuaGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHRcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW1iZWQuZW1iZWRTd2ZPYmplY3Qoc3dmSWQsIG9wdGlvbnMsIGZsYXNodmFycywgZW52aXJvbm1lbnQuZ2V0U3dmT2JqZWN0KCksIGVsZW1lbnRJZClcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goZSA9PiBkZWZlcnJlZC5yZWplY3QoZSkpXG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2VcbiAgfVxuXG4gIGNvbm5lY3QgKCkge1xuICAgIHRyeSB7XG4gICAgICBlbnZpcm9ubWVudC5nZXRFbWJlZE9iamVjdCgpLmNvbm5lY3QoKVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgLy8gbmFkYS5cbiAgICB9XG4gIH1cblxuICBkaXNjb25uZWN0ICgpIHtcbiAgICB0cnkge1xuICAgICAgLy8gTm8gaW52b2NhYmxlIEFQSSBmb3IgY3VzdG9tIGxpdmUgZmxhc2ggc3Vic2NyaWJlciBmcm9tIFJlZDUgUHJvIGF0IHRoZSB0aW1lLlxuICAgICAgZW52aXJvbm1lbnQuZ2V0RW1iZWRPYmplY3QoKS5kaXNjb25uZWN0KClcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBuYWRhLlxuICAgIH1cbiAgICB0aGlzLmNsZWFuVXAoKVxuICB9XG5cbiAgZ2V0VHlwZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMucGxheWVyVHlwZVxuICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgTGl2ZVNvdXJjZUhhbmRsZXJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL2pzL3N1YnNjcmliZXIvbGl2ZS1zb3VyY2UtaGFuZGxlci5qc1xuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgeyBEZWZlcnJlZFByb21pc2UgfSBmcm9tICcuLi91dGlsL3Byb21pc2UnXG5cbmV4cG9ydCBjb25zdCBkZWZpbmVFbWJlZEVsZW1lbnQgPSAodGFyZ2V0RWxlbWVudCwgdGFyZ2V0UGFyZW50KSA9PiB7XG4gIGxldCBkZmQgPSBuZXcgRGVmZXJyZWRQcm9taXNlKClcbiAgY29uc3QgZWxlbWVudElkID0gdGFyZ2V0RWxlbWVudC5pZFxuICBpZiAodGFyZ2V0RWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAndmlkZW8nKSB7XG4gICAgbGV0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgZGl2LmlkID0gZWxlbWVudElkICsgJ19ydG1wJ1xuICAgIHRhcmdldFBhcmVudC5hcHBlbmRDaGlsZChkaXYpXG4gICAgdGFyZ2V0RWxlbWVudC5yZW1vdmUoKVxuICAgIGRmZC5yZXNvbHZlKGRpdi5pZClcbiAgfSBlbHNlIHtcbiAgICBkZmQucmVzb2x2ZShlbGVtZW50SWQpXG4gIH1cbiAgcmV0dXJuIGRmZC5wcm9taXNlXG59XG5cbmV4cG9ydCBjb25zdCBlbWJlZFN3Zk9iamVjdCA9IChpZE5hbWUsIG9wdGlvbnMsIGZsYXNodmFycywgc3dmb2JqZWN0LCBlbGVtZW50SWQpID0+IHtcbiAgbGV0IGRmZCA9IG5ldyBEZWZlcnJlZFByb21pc2UoKVxuICBsZXQgcGFyYW1zID0ge1xuICAgIHF1YWxpdHk6ICdoaWdoJyxcbiAgICBiZ2NvbG9yOiAnIzAwMCcsXG4gICAgYWxsb3dzY3JpcHRhY2Nlc3M6ICdhbHdheXMnLFxuICAgIGFsbG93ZnVsbHNjcmVlbjogJ3RydWUnXG4gIH1cbiAgbGV0IGF0dHJpYnV0ZXMgPSB7XG4gICAgaWQ6IGlkTmFtZSxcbiAgICBuYW1lOiBpZE5hbWUsXG4gICAgYWxpZ246ICdtaWRkbGUnXG4gIH1cbiAgaWYgKHN3Zm9iamVjdC5oYXNGbGFzaFBsYXllclZlcnNpb24ob3B0aW9ucy5taW5GbGFzaFZlcnNpb24pKSB7XG4gICAgc3dmb2JqZWN0LmVtYmVkU1dGKFxuICAgICAgb3B0aW9ucy5zd2YsXG4gICAgICBlbGVtZW50SWQsXG4gICAgICBvcHRpb25zLndpZHRoIHx8ICczMjAnLFxuICAgICAgb3B0aW9ucy5oZWlnaHQgfHwgJzI0MCcsXG4gICAgICBvcHRpb25zLm1pbkZsYXNoVmVyc2lvbixcbiAgICAgIG9wdGlvbnMucHJvZHVjdEluc3RhbGxVUkwsXG4gICAgICBmbGFzaHZhcnMsXG4gICAgICBwYXJhbXMsXG4gICAgICBhdHRyaWJ1dGVzLFxuICAgICAgZGZkLnJlc29sdmUpXG4gIH0gZWxzZSB7XG4gICAgZGZkLnJlamVjdCgnRmxhc2ggUGxheWVyIFZlcnNpb24gaXMgbm90IHN1cHBvcnRlZC4nKVxuICB9XG4gIHJldHVybiBkZmQucHJvbWlzZVxufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvanMvZW52L2VtYmVkLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5cbmltcG9ydCB7IERlZmVycmVkUHJvbWlzZSB9IGZyb20gJy4vcHJvbWlzZSdcblxuY29uc3QgbWFwID0gbmV3IFdlYWtNYXAoKVxuXG5jb25zdCBwdnQgPSAoY3R4KSA9PiB7XG4gIGlmICghbWFwLmhhcyhjdHgpKSB7XG4gICAgbWFwLnNldChjdHgsIHt9KVxuICB9XG5cbiAgcmV0dXJuIG1hcC5nZXQoY3R4KVxufVxuXG5leHBvcnQgY2xhc3MgSW1wbEZhY3RvcnlPcmRlciB7XG5cbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHRoaXMubGlzdG9yZGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAqIGxpc3RvcmRlciAobGlzdCkge1xuICAgICAgICB3aGlsZSAobGlzdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgeWllbGQgbGlzdC5zaGlmdCgpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KCkpXG5cbiAgICBwdnQodGhpcykuZmluZCA9IChpdGVyYXRvciwgbWFwLCBvcHRpb25zLCBwcm9taXNlLCBpbml0Rm4gPSBudWxsKSA9PiB7XG4gICAgICBjb25zdCBbdHlwZSwgSW1wbF0gPSBwdnQodGhpcykubmV4dChpdGVyYXRvciwgbWFwKVxuICAgICAgaWYgKCFJbXBsKSB7XG4gICAgICAgIHByb21pc2UucmVqZWN0KClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBwXG4gICAgICAgIGxldCBzcmMgPSBvcHRpb25zW3R5cGVdXG4gICAgICAgIHNyYyA9IHNyYyB8fCBvcHRpb25zXG4gICAgICAgIGlmIChpbml0Rm4pIHtcbiAgICAgICAgICBwID0gbmV3IEltcGwoKVtpbml0Rm5dKHNyYylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwID0gbmV3IEltcGwoc3JjKVxuICAgICAgICB9XG4gICAgICAgIHAudGhlbigoY29uY3JldGUpID0+IHtcbiAgICAgICAgICBwcm9taXNlLnJlc29sdmUoY29uY3JldGUpXG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaCgoKSA9PiB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgICAgICBwdnQodGhpcykuZmluZChpdGVyYXRvciwgbWFwLCBvcHRpb25zLCBwcm9taXNlLCBpbml0Rm4pXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuXG4gICAgcHZ0KHRoaXMpLm5leHQgPSAob3JkZXIsIG1hcCkgPT4ge1xuICAgICAgbGV0IEltcGxcbiAgICAgIGxldCBrZXlcbiAgICAgIGNvbnN0IG5leHQgPSBvcmRlci5uZXh0KClcbiAgICAgIGlmICghbmV4dC5kb25lKSB7XG4gICAgICAgIGtleSA9IG5leHQudmFsdWVcbiAgICAgICAgSW1wbCA9IG1hcC5nZXQoa2V5KVxuICAgICAgfVxuICAgICAgcmV0dXJuIFtrZXksIEltcGxdXG4gICAgfVxuICB9XG5cbiAgY3JlYXRlIChvcmRlciwgbWFwLCBvcHRpb25zLCBpbml0Rm4gPSBudWxsKSB7XG4gICAgY29uc3QgcHJvbWlzZSA9IG5ldyBEZWZlcnJlZFByb21pc2UoKVxuICAgIHB2dCh0aGlzKS5maW5kKHRoaXMubGlzdG9yZGVyKG9yZGVyLnNsaWNlKCkpLCBtYXAsIG9wdGlvbnMsIHByb21pc2UsIGluaXRGbilcbiAgICByZXR1cm4gcHJvbWlzZS5wcm9taXNlXG4gIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBJbXBsRmFjdG9yeU9yZGVyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9qcy91dGlsL2ltcGwtZmFjdG9yeS1vcmRlci5qc1xuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG5leHBvcnQgY29uc3QgUGxheWJhY2tUeXBlcyA9IE9iamVjdC5mcmVlemUoe1xuICBSVE1QOiAncnRtcCcsXG4gIFJUQzogJ3J0YycsXG4gIEhMUzogJ2hscydcbn0pXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9qcy9lbnVtL3BsYXliYWNrLmpzXG4gKiovIiwiLyoqXG4gKiBNYWluIGVudHJ5IGZvciBmYWlsb3ZlciBzdXBwb3J0IG9mIGFsbCBwdWJsaXNoZXIgaW1wbGVtZW50YXRpb25zLlxuICovXG4ndXNlIHN0cmljdCdcblxuaW1wb3J0IEltcGxGYWN0b3J5T3JkZXIgZnJvbSAnLi4vdXRpbC9pbXBsLWZhY3Rvcnktb3JkZXInXG5pbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJy4uL2NvcmUvZXZlbnQtZW1pdHRlcidcbmltcG9ydCBSVE1QUHVibGlzaGVyIGZyb20gJy4vcmVkNXByby1ydG1wJ1xuaW1wb3J0IFJUQ1B1Ymxpc2hlciBmcm9tICcuL3JlZDVwcm8tcnRjJ1xuaW1wb3J0IHsgRGVmZXJyZWRQcm9taXNlIH0gZnJvbSAnLi4vdXRpbC9wcm9taXNlJ1xuaW1wb3J0IHsgUHVibGlzaFR5cGVzIH0gZnJvbSAnLi4vZW51bS9wdWJsaXNoJ1xuaW1wb3J0IHsgZGVidWcsIHdhcm4gfSBmcm9tICcuLi9sb2cnXG5cbmNvbnN0IE5BTUUgPSAnUjVQcm9QdWJsaXNoZXInXG5jb25zdCBwdWJsaXNoRmFjdG9yeSA9IG5ldyBJbXBsRmFjdG9yeU9yZGVyKClcbmNvbnN0IHB1Ymxpc2hlckltcGwgPSAoZnVuY3Rpb24gKCkge1xuICBsZXQgbWFwID0gbmV3IE1hcCgpXG4gIG1hcC5zZXQoUHVibGlzaFR5cGVzLlJUTVAsIFJUTVBQdWJsaXNoZXIpXG4gIG1hcC5zZXQoUHVibGlzaFR5cGVzLlJUQywgUlRDUHVibGlzaGVyKVxuICByZXR1cm4gbWFwXG59KCkpXG5cbmNsYXNzIFJlZDVQcm9QdWJsaXNoZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuXG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5fb3B0aW9ucyA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX3ZpZXcgPSB1bmRlZmluZWRcbiAgICB0aGlzLl9jdXJyZW50UHVibGlzaGVyID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fYm91bmRCdWJibGVQdWJsaXNoZXJFdmVudCA9IHRoaXMuYnViYmxlUHVibGlzaGVyRXZlbnQuYmluZCh0aGlzKVxuICAgIHRoaXMuX29yZGVyID0gW1xuICAgICAgUHVibGlzaFR5cGVzLlJUTVAsXG4gICAgICBQdWJsaXNoVHlwZXMuUlRDXG4gICAgXVxuICB9XG5cbiAgZ2V0UHVibGlzaE9yZGVyICgpIHtcbiAgICByZXR1cm4gdGhpcy5fb3JkZXJcbiAgfVxuXG4gIHNldFB1Ymxpc2hPcmRlciAob3JkZXIpIHtcbiAgICAvLyBBbGxvdyBmb3Igc3RyaW5nIHZhbHVlIHRvIGRlZmluZSBzaW5nbGUgaXRlbSBpbiBvcmRlci5cbiAgICBvcmRlciA9IHR5cGVvZiBvcmRlciA9PT0gJ3N0cmluZycgPyBbb3JkZXJdIDogb3JkZXJcblxuICAgIC8vIEZpbHRlciBvdXQgdmFsdWVzIG5vdCBhdmFpbGFibGUgaW4gZW51bWVyYXRpb24gb2YgcGxheWJhY2sgdHlwZXMuXG4gICAgY29uc3QgdCA9IG9yZGVyLmZpbHRlcihlbnRyeSA9PiB7XG4gICAgICBsZXQga2V5XG4gICAgICBmb3IgKGtleSBpbiBQdWJsaXNoVHlwZXMpIHtcbiAgICAgICAgaWYgKFB1Ymxpc2hUeXBlc1trZXldLnRvTG93ZXJDYXNlKCkgPT09IGVudHJ5LnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9KS5tYXAoZW50cnkgPT4gZW50cnkudG9Mb3dlckNhc2UoKSlcblxuICAgIC8vIERlZmluZSBuZXcgb3JkZXIuXG4gICAgdGhpcy5fb3JkZXIgPSBbLi4ubmV3IFNldCh0KV1cbiAgICBkZWJ1ZyhOQU1FLCBgW29yZGVydXBkYXRlXTogJHt0aGlzLl9vcmRlcn1gKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzZXRWaWV3IChwdWJsaXNoVmlldykge1xuICAgIHRoaXMuX3ZpZXcgPSBwdWJsaXNoVmlld1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBnZXRQdWJsaXNoZXJGcm9tT3JkZXIgKG9yZGVyLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHB1Ymxpc2hGYWN0b3J5LmNyZWF0ZShvcmRlciwgcHVibGlzaGVySW1wbCwgb3B0aW9ucywgJ2luaXQnKVxuICB9XG5cbiAgaW5pdCAob3B0aW9ucykge1xuICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkUHJvbWlzZSgpXG4gICAgZGVidWcoTkFNRSwgJ1twdWJsaXNoXScpXG4gICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnNcbiAgICB0aGlzLmdldFB1Ymxpc2hlckZyb21PcmRlcih0aGlzLl9vcmRlciwgdGhpcy5fb3B0aW9ucylcbiAgICAgIC50aGVuKHB1Ymxpc2hlciA9PiB7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRQdWJsaXNoZXIgPSBwdWJsaXNoZXJcbiAgICAgICAgdGhpcy5fY3VycmVudFB1Ymxpc2hlci5zZXRWaWV3KHRoaXMuX3ZpZXcpXG4gICAgICAgIHRoaXMuX2N1cnJlbnRQdWJsaXNoZXIub24oJyonLCB0aGlzLl9ib3VuZEJ1YmJsZVB1Ymxpc2hlckV2ZW50KVxuICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHRoaXMuX2N1cnJlbnRQdWJsaXNoZXIpXG4gICAgICB9KVxuICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgIHdhcm4oTkFNRSwgYFtwdWJsaXNoZXJyb3JdOiBDb3VsZCBub3QgaW1wbGVtZW50IGEgcHVibGlzaGVyOiAke2Vycn1gKVxuICAgICAgICBkZWZlcnJlZC5yZWplY3QoZXJyKVxuICAgICAgfSlcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZVxuICB9XG5cbiAgc3RvcCAoKSB7XG4gICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWRQcm9taXNlKClcbiAgICBpZiAoIXRoaXMuX2N1cnJlbnRQdWJsaXNoZXIpIHtcbiAgICAgIHdhcm4oTkFNRSwgJ1tzdG9wXTogQ291bGQgbm90IGludm9rZSBzdG9wKCkgb24gdW5kZWZpbmVkIHB1Ymxpc2hlci4nKVxuICAgICAgZGVmZXJyZWQucmVqZWN0KCdBIGN1cnJlbnQgcHVibGlzaGVyIGlzIG5vdCBhdmFpbGFibGUgdG8gaXNzdWUgYSA6c3RvcCgpIGNvbW1hbmQgdG8uJylcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWcoTkFNRSwgJ1tzdG9wXTogSW52b2tpbmcgc3RvcCBvbiBoZWxkIHB1Ymxpc2hlcicpXG4gICAgICB0aGlzLl9jdXJyZW50UHVibGlzaGVyLnVucHVibGlzaCgpXG4gICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICBkZWJ1ZyhOQU1FLCAnW3N0b3BzdWNjZXNzXScpXG4gICAgICAgICAgdGhpcy5fY3VycmVudFB1Ymxpc2hlci5vZmYoJyonLCB0aGlzLl9ib3VuZEJ1YmJsZVB1Ymxpc2hlckV2ZW50KVxuICAgICAgICAgIHRoaXMuX2N1cnJlbnRQdWJsaXNoZXIgPSB1bmRlZmluZWRcbiAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKClcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgZGVidWcoTkFNRSwgYFtzdG9wZXJyb3JdOiAke2Vycn1gKVxuICAgICAgICAgIGlmICh0aGlzLl9jdXJyZW50UHVibGlzaGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50UHVibGlzaGVyLm9mZignKicsIHRoaXMuX2JvdW5kQnViYmxlUHVibGlzaGVyRXZlbnQpXG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX2N1cnJlbnRQdWJsaXNoZXIgPSB1bmRlZmluZWRcbiAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoZXJyKVxuICAgICAgICB9KVxuICAgIH1cbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZVxuICB9XG5cbiAgYnViYmxlUHVibGlzaGVyRXZlbnQgKHB1Ymxpc2hlckV2ZW50KSB7XG4gICAgdGhpcy50cmlnZ2VyLmNhbGwodGhpcywgcHVibGlzaGVyRXZlbnQpXG4gIH1cblxuICBnZXQgcHVibGlzaFR5cGVzICgpIHtcbiAgICByZXR1cm4gUHVibGlzaFR5cGVzXG4gIH1cblxuICBnZXQgY3VycmVudFB1Ymxpc2hlciAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRQdWJsaXNoZXJcbiAgfVxuXG59XG5cbmV4cG9ydCB7IFJlZDVQcm9QdWJsaXNoZXIsIFJUTVBQdWJsaXNoZXIsIFJUQ1B1Ymxpc2hlciB9XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9qcy9wdWJsaXNoZXIvaW5kZXguanNcbiAqKi8iLCIndXNlIHN0cmljdCdcblxuaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICcuLi9jb3JlL2V2ZW50LWVtaXR0ZXInXG5pbXBvcnQgeyBQdWJsaXNoZXJFdmVudCB9IGZyb20gJy4uL2V2ZW50J1xuaW1wb3J0IGVudmlyb25tZW50IGZyb20gJy4uL2Vudi9icm93c2VyJ1xuaW1wb3J0IHsgRGVmZXJyZWRQcm9taXNlIH0gZnJvbSAnLi4vdXRpbC9wcm9taXNlJ1xuaW1wb3J0IHsgUHVibGlzaFR5cGVzIH0gZnJvbSAnLi4vZW51bS9wdWJsaXNoJ1xuaW1wb3J0IFB1Ymxpc2hlclNvdXJjZUhhbmRsZXIgZnJvbSAnLi9wdWItc291cmNlLWhhbmRsZXInXG5pbXBvcnQgeyBQdWJsaXNoZXJFdmVudFR5cGVzLCBSVE1QUHVibGlzaGVyRXZlbnRUeXBlcyB9IGZyb20gJy4uL2V2ZW50J1xuaW1wb3J0IHsgZGVidWcsIGVycm9yIH0gZnJvbSAnLi4vbG9nJ1xuXG5jb25zdCBOQU1FID0gJ1I1UHJvUlRNUFB1Ymxpc2hlcidcbmNvbnN0IHN3ZklkID0gJ1JUTVBQdWJsaXNoZXInXG5jb25zdCBkZWZhdWx0TW9kZSA9ICdsaXZlJ1xuY29uc3QgZGVmYXVsdEZsYXNoVmVyc2lvbiA9ICcxMC4wLjAnXG5jb25zdCBkZWZhdWx0U1dGID0gJ2xpYi9yZWQ1cHJvL3JlZDVwcm8tcHVibGlzaGVyLnN3ZidcbmNvbnN0IHN3Zm9iamVjdFVSTCA9ICdsaWIvc3dmb2JqZWN0L3N3Zm9iamVjdC5qcydcbmNvbnN0IHByb2R1Y3RJbnN0YWxsVVJMID0gJ2xpYi9zd2ZvYmplY3QvcGxheWVyUHJvZHVjdEluc3RhbGwuc3dmJ1xuXG5jbGFzcyBSVE1QUHVibGlzaGVyIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcblxuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuX29wdGlvbnMgPSB1bmRlZmluZWRcbiAgICB0aGlzLl92aWV3ID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fc291cmNlSGFuZGxlciA9IHVuZGVmaW5lZFxuICB9XG5cbiAgaW5pdCAob3B0aW9ucykge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzXG4gICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWRQcm9taXNlKClcbiAgICBjb25zdCB2ZXJzaW9uID0gb3B0aW9ucy5taW5GbGFzaFZlcnNpb24gfHwgZGVmYXVsdEZsYXNoVmVyc2lvblxuICAgIGlmICghZW52aXJvbm1lbnQuc3VwcG9ydHNGbGFzaFZlcnNpb24odmVyc2lvbikpIHtcbiAgICAgIGRlZmVycmVkLnJlamVjdChgQ291bGQgbm90IHJlc29sdmUgUlRNUFB1Ymxpc2hlciBpbnN0YW5jZS4gUmVxdWlyZXMgbWluaW11bSBGbGFzaCBQbGF5ZXIgaW5zdGFsbCBvZiAke3ZlcnNpb259YClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnNcbiAgICAgIHRoaXMuX29wdGlvbnMuc3dmID0gdGhpcy5fb3B0aW9ucy5zd2YgfHwgZGVmYXVsdFNXRlxuICAgICAgdGhpcy5fb3B0aW9ucy5taW5GbGFzaFZlcnNpb24gPSB2ZXJzaW9uXG4gICAgICB0aGlzLl9vcHRpb25zLnN0cmVhbU1vZGUgPSB0aGlzLl9vcHRpb25zLnN0cmVhbU1vZGUgfHwgZGVmYXVsdE1vZGVcbiAgICAgIHRoaXMuX29wdGlvbnMuc3dmb2JqZWN0VVJMID0gdGhpcy5fb3B0aW9ucy5zd2ZvYmplY3RVUkwgfHwgc3dmb2JqZWN0VVJMXG4gICAgICB0aGlzLl9vcHRpb25zLnByb2R1Y3RJbnN0YWxsVVJMID0gdGhpcy5fb3B0aW9ucy5wcm9kdWN0SW5zdGFsbFVSTCB8fCBwcm9kdWN0SW5zdGFsbFVSTFxuICAgICAgdHJ5IHtcbiAgICAgICAgZW52aXJvbm1lbnQuaW5qZWN0U2NyaXB0KHRoaXMuX29wdGlvbnMuc3dmb2JqZWN0VVJMKVxuICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGRlYnVnKE5BTUUsICdTV0ZPYmplY3QgZW1iZWRkZWQuJylcbiAgICAgICAgICAgIGlmIChzZWxmLl9zb3VyY2VIYW5kbGVyKSB7XG4gICAgICAgICAgICAgIGRlYnVnKE5BTUUsICdQdWJsaXNoIGhhbmRsZXIgZXN0YWJsaXNoZWQuJylcbiAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX3NvdXJjZUhhbmRsZXIuYWRkU291cmNlKHN3ZklkLCBzZWxmLl9vcHRpb25zKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZGVidWcoTkFNRSwgJ1B1Ymxpc2ggaGFuZGxlciBub3QgZXN0YWJsaXNoZWQuJylcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICAgIC50aGVuKCgpID0+IGRlZmVycmVkLnJlc29sdmUoc2VsZikpXG4gICAgICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgICBlcnJvcihOQU1FLCBgQ291bGQgbm90IGVtYmVkIEZsYXNoLWJhc2VkIFJUTVAgUHVibGlzaGVyLiBSZWFzb246ICR7ZXJyfWApXG4gICAgICAgICAgICBpZiAoc2VsZi5fc291cmNlSGFuZGxlcikge1xuICAgICAgICAgICAgICBzZWxmLl9zb3VyY2VIYW5kbGVyLmRpc2Nvbm5lY3QoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KGVycilcbiAgICAgICAgICAgIHNlbGYudHJpZ2dlcihuZXcgUHVibGlzaGVyRXZlbnQoUlRNUFB1Ymxpc2hlckV2ZW50VHlwZXMuRU1CRURfRkFJTFVSRSwgc2VsZikpXG4gICAgICAgICAgfSlcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZGVmZXJyZWQucmVqZWN0KGBDb3VsZCBub3QgaW5qZWN0IEZsYXNoLWJhc2VkIFB1Ymxpc2hlciBpbnRvIHRoZSBwYWdlLiBSZWFzb246ICR7ZS5tZXNzYWdlfWApXG4gICAgICAgIHNlbGYudHJpZ2dlcihuZXcgUHVibGlzaGVyRXZlbnQoUlRNUFB1Ymxpc2hlckV2ZW50VHlwZXMuRU1CRURfRkFJTFVSRSwgc2VsZikpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlXG4gIH1cblxuICBfc2V0VXBDb25uZWN0Q2FsbGJhY2sgKHByb21pc2UpIHtcbiAgICB3aW5kb3cuc2V0QWN0aXZlSWQgPSAoc3VjY2Vzc0lkKSA9PiB7XG4gICAgICAvLyBzdWNjZXNzSWQgPT09IF9vcHRpb25zLnN0cmVhbU5hbWVcbiAgICAgIGRlYnVnKE5BTUUsIGBFbWJlZCBhbmQgY29ubmVjdCgpIGNvbXBsZXRlIGZvciBwdWJsaXNoZXIgc3dmLiBzdWNjZXNzSWQoJHtzdWNjZXNzSWR9KS5gKVxuICAgICAgcHJvbWlzZS5yZXNvbHZlKHN1Y2Nlc3NJZClcbiAgICAgIHRoaXMudHJpZ2dlcihuZXcgUHVibGlzaGVyRXZlbnQoUlRNUFB1Ymxpc2hlckV2ZW50VHlwZXMuRU1CRURfU1VDQ0VTUywgdGhpcykpXG4gICAgICB0aGlzLl90ZWFyRG93bkNvbm5lY3RDYWxsYmFjaygpXG4gICAgfVxuICAgIC8vIFRPRE86IFNldHVwIHRpbWVvdXQgdG8gcmVqZWN0P1xuICB9XG5cbiAgX3RlYXJEb3duQ29ubmVjdENhbGxiYWNrICgpIHtcbiAgICB3aW5kb3cuc2V0QWN0aXZlSWQgPSB1bmRlZmluZWRcbiAgfVxuXG4gIF9lc3RhYmxpc2hFeHRJbnRIYW5kbGVycyAoKSB7XG4gICAgY29uc3QgaWQgPSB0aGlzLl9vcHRpb25zLnN0cmVhbU5hbWVcbiAgICBjb25zdCBpbnZva2VGbiA9IChsYWJlbCkgPT4ge1xuICAgICAgcmV0dXJuIFsncHVibGlzaGVyJywgbGFiZWwsIGlkXS5qb2luKCdfJylcbiAgICB9XG4gICAgd2luZG93W2ludm9rZUZuKCdyNXByb0Nvbm5lY3RTdWNjZXNzJyldID0gKCkgPT4gdGhpcy50cmlnZ2VyKG5ldyBQdWJsaXNoZXJFdmVudChQdWJsaXNoZXJFdmVudFR5cGVzLkNPTk5FQ1RfU1VDQ0VTUykpXG4gICAgd2luZG93W2ludm9rZUZuKCdyNXByb0Nvbm5lY3RGYWlsdXJlJyldID0gKCkgPT4gdGhpcy50cmlnZ2VyKG5ldyBQdWJsaXNoZXJFdmVudChQdWJsaXNoZXJFdmVudFR5cGVzLkNPTk5FQ1RfRkFJTFVSRSkpXG4gICAgd2luZG93W2ludm9rZUZuKCdyNXByb1B1Ymxpc2hTdGFydCcpXSA9ICgpID0+IHRoaXMudHJpZ2dlcihuZXcgUHVibGlzaGVyRXZlbnQoUHVibGlzaGVyRXZlbnRUeXBlcy5QVUJMSVNIX1NUQVJUKSlcbiAgICB3aW5kb3dbaW52b2tlRm4oJ3I1cHJvUHVibGlzaEZhaWwnKV0gPSAoKSA9PiB0aGlzLnRyaWdnZXIobmV3IFB1Ymxpc2hlckV2ZW50KFB1Ymxpc2hlckV2ZW50VHlwZXMuUFVCTElTSF9GQUlMKSlcbiAgICB3aW5kb3dbaW52b2tlRm4oJ3I1cHJvUHVibGlzaEludmFsaWROYW1lJyldID0oKSA9PiB0aGlzLnRyaWdnZXIobmV3IFB1Ymxpc2hlckV2ZW50KFB1Ymxpc2hlckV2ZW50VHlwZXMuUFVCTElTSF9JTlZBTElEX05BTUUpKVxuICAgIHdpbmRvd1tpbnZva2VGbigncjVwcm9VbnB1Ymxpc2hTdWNjZXNzJyldID0gKCkgPT4gdGhpcy50cmlnZ2VyKG5ldyBQdWJsaXNoZXJFdmVudChQdWJsaXNoZXJFdmVudFR5cGVzLlVOUFVCTElTSF9TVUNDRVNTKSlcbiAgfVxuXG4gIHB1Ymxpc2ggKHN0cmVhbU5hbWUgPSB1bmRlZmluZWQpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIGNvbnN0IGRmZCA9IG5ldyBEZWZlcnJlZFByb21pc2UoKVxuICAgIHRoaXMuX3NldFVwQ29ubmVjdENhbGxiYWNrKGRmZClcbiAgICB0cnkge1xuICAgICAgdGhpcy5fc291cmNlSGFuZGxlci5nZXRFbWJlZE9wZXJhdGlvbigpXG4gICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICBkZWJ1ZyhOQU1FLCAnW2hhbmRsZXI6ZW1iZWQ6Y29tcGxldGVdJylcbiAgICAgICAgICBjb25zdCBlbCA9IGVudmlyb25tZW50LmdldEVtYmVkT2JqZWN0KHN3ZklkKVxuICAgICAgICAgIGlmIChlbCkge1xuICAgICAgICAgICAgdGhpcy5fZXN0YWJsaXNoRXh0SW50SGFuZGxlcnMoKVxuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgY291bnQgPSAwXG4gICAgICAgICAgY29uc3QgbGltaXQgPSAxMDAwXG4gICAgICAgICAgbGV0IHRyeUNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBsZXQgdGltZW91dFxuICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KVxuICAgICAgICAgICAgICAgIGVsLmNvbm5lY3QoKVxuICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50KysgPiBsaW1pdCkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgZVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB0cnlDb25uZWN0KClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIDMwMClcbiAgICAgICAgICB9XG4gICAgICAgICAgdHJ5Q29ubmVjdCgpXG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgIGRmZC5yZWplY3QoZXJyKVxuICAgICAgICAgIHRoaXMudHJpZ2dlcihuZXcgUHVibGlzaGVyRXZlbnQoUHVibGlzaGVyRXZlbnRUeXBlcy5DT05ORUNUX0ZBSUxVUkUsIHRoaXMpKVxuICAgICAgICB9KVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGVycm9yKE5BTUUsICdbaGFuZGxlcjplbWJlZDplcnJvcl0nKVxuICAgICAgZGZkLnJlamVjdChgQ291bGQgbm90IGluaXRpYXRlIGNvbm5lY3Rpb24gc2VxdWVuY2UuIFJlYXNvbjogJHtlLm1lc3NhZ2V9YClcbiAgICAgIHRoaXMudHJpZ2dlcihuZXcgUHVibGlzaGVyRXZlbnQoUHVibGlzaGVyRXZlbnRUeXBlcy5DT05ORUNUX0ZBSUxVUkUsIHRoaXMpKVxuICAgICAgdGhpcy5fdGVhckRvd25Db25uZWN0Q2FsbGJhY2soKVxuICAgIH1cbiAgICByZXR1cm4gZGZkLnByb21pc2VcbiAgfVxuXG4gIHVucHVibGlzaCAoKSB7XG4gICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWRQcm9taXNlKClcbiAgICB0cnkge1xuICAgICAgZW52aXJvbm1lbnQuZ2V0RW1iZWRPYmplY3Qoc3dmSWQpLmRpc2Nvbm5lY3QoKVxuICAgICAgZGVmZXJyZWQucmVzb2x2ZSgpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXJyb3IoTkFNRSwgYENvdWxkIG5vdCBpbml0aWF0ZSBkaXNjb25uZWN0aW9uIHNlcXVlbmNlLiBSZWFzb246ICR7ZS5tZXNzYWdlfWApXG4gICAgICBkZWZlcnJlZC5yZWplY3QoZS5tZXNzYWdlKVxuICAgIH1cbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZVxuICB9XG5cbiAgc2V0VmlldyAodmlldykge1xuICAgIHRoaXMuX3ZpZXcgPSB2aWV3XG4gICAgaWYgKHRoaXMuX3NvdXJjZUhhbmRsZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fc291cmNlSGFuZGxlci5kaXNjb25uZWN0KClcbiAgICAgIHRoaXMuX3NvdXJjZUhhbmRsZXIgPSB1bmRlZmluZWRcbiAgICB9XG4gICAgaWYgKHRoaXMuX3ZpZXcpIHtcbiAgICAgIHRoaXMuX3NvdXJjZUhhbmRsZXIgPSBuZXcgUHVibGlzaGVyU291cmNlSGFuZGxlcih0aGlzLl92aWV3LnZpZXcsIHRoaXMuZ2V0VHlwZSgpKVxuICAgIH1cbiAgICBpZiAodGhpcy5fb3B0aW9ucyAmJiB0aGlzLl9zb3VyY2VIYW5kbGVyKSB7XG4gICAgICB0aGlzLl9zb3VyY2VIYW5kbGVyLmFkZFNvdXJjZShzd2ZJZCwgdGhpcy5fb3B0aW9ucylcbiAgICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgZXJyb3IoTkFNRSwgYENvdWxkIG5vdCBlc3RhYmxpc2ggcHJvcGVyIFJUTVAgcHVibGlzaGVyOiAke2Vycn1gKVxuICAgICAgICAgIHRoaXMudHJpZ2dlcihuZXcgUHVibGlzaGVyRXZlbnQoUlRNUFB1Ymxpc2hlckV2ZW50VHlwZXMuRU1CRURfRkFJTFVSRSwgdGhpcykpXG4gICAgICAgIH0pXG4gICAgfVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBnZXRUeXBlICgpIHtcbiAgICByZXR1cm4gUHVibGlzaFR5cGVzLlJUTVAudG9VcHBlckNhc2UoKVxuICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgUlRNUFB1Ymxpc2hlclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvanMvcHVibGlzaGVyL3JlZDVwcm8tcnRtcC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG5leHBvcnQgY29uc3QgUHVibGlzaFR5cGVzID0gT2JqZWN0LmZyZWV6ZSh7XG4gIFJUTVA6ICdydG1wJyxcbiAgUlRDOiAncnRjJ1xufSlcblxuZXhwb3J0IGNvbnN0IFB1Ymxpc2hNb2RlVHlwZXMgPSBPYmplY3QuZnJlZXplKHtcbiAgTElWRTogJ2xpdmUnLFxuICBSRUNPUkQ6ICdyZWNvcmQnLFxuICBBUFBFTkQ6ICdhcHBlbmQnXG59KVxuXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9qcy9lbnVtL3B1Ymxpc2guanNcbiAqKi8iLCIndXNlIHN0cmljdCdcblxuaW1wb3J0ICogYXMgZW1iZWQgZnJvbSAnLi4vZW52L2VtYmVkJ1xuaW1wb3J0IGVudmlyb25tZW50IGZyb20gJy4uL2Vudi9icm93c2VyJ1xuaW1wb3J0IHsgRnV0dXJlIH0gZnJvbSAnLi4vdXRpbC9wcm9taXNlJ1xuaW1wb3J0IHsgZGVidWcgfSBmcm9tICcuLi9sb2cnXG5cbmNvbnN0IE5BTUUgPSAnUjVQcm9QdWJsaXNoZXJTb3VyY2VIYW5kbGVyJ1xuXG5jbGFzcyBQdWJsaXNoZXJTb3VyY2VIYW5kbGVyIHtcblxuICBjb25zdHJ1Y3RvciAodmlkZW8sIHR5cGUpIHtcbiAgICB0aGlzLnZpZGVvID0gdmlkZW9cbiAgICB0aGlzLmNsb25lID0gdGhpcy52aWRlby5jbG9uZU5vZGUodHJ1ZSlcbiAgICB0aGlzLmhvbGRlciA9IHRoaXMudmlkZW8ucGFyZW50Tm9kZVxuICAgIHRoaXMucHVibGlzaGVyVHlwZSA9IHR5cGVcbiAgICB0aGlzLl9lbWJlZEZ1dHVyZSA9IHVuZGVmaW5lZFxuICB9XG5cbiAgZ2V0RW1iZWRPcGVyYXRpb24gKCkge1xuICAgIHRoaXMuX2VtYmVkRnV0dXJlID0gRnV0dXJlLmNyZWF0ZUlmTm90RXhpc3QodGhpcy5fZW1iZWRGdXR1cmUpXG4gICAgcmV0dXJuIHRoaXMuX2VtYmVkRnV0dXJlLnByb21pc2VcbiAgfVxuXG4gIGNsZWFuVXAgKCkge1xuICAgIC8vIFJldHVybiB0byBwcmlvciBET00gbWFuaXB1bGF0aW9uLlxuICAgIHRoaXMudmlkZW8ucmVtb3ZlKClcbiAgICB0aGlzLnZpZGVvID0gdGhpcy5jbG9uZS5jbG9uZU5vZGUodHJ1ZSlcbiAgICB0aGlzLmhvbGRlci5hcHBlbmRDaGlsZCh0aGlzLnZpZGVvKVxuICAgIHRoaXMuX2VtYmVkRnV0dXJlID0gdW5kZWZpbmVkXG4gIH1cblxuICBhZGRTb3VyY2UgKHN3ZklkLCBvcHRpb25zLCBzd2ZVcmwgPSBudWxsLCBtaW5GbGFzaFZlcnNpb24gPSBudWxsKSB7XG4gICAgZGVidWcoTkFNRSwgJ1thZGRzb3VyY2VdJylcbiAgICBjb25zdCBzZWxmID0gdGhpc1xuICAgIHRoaXMuX2VtYmVkRnV0dXJlID0gRnV0dXJlLmNyZWF0ZUlmTm90RXhpc3QodGhpcy5fZW1iZWRGdXR1cmUpXG4gICAgY29uc3QgZGVmZXJyZWQgPSB0aGlzLl9lbWJlZEZ1dHVyZVxuICAgIG9wdGlvbnMuc3dmID0gc3dmVXJsIHx8IG9wdGlvbnMuc3dmXG4gICAgb3B0aW9ucy5taW5GbGFzaFZlcnNpb24gPSBtaW5GbGFzaFZlcnNpb24gfHwgb3B0aW9ucy5taW5GbGFzaFZlcnNpb25cbiAgICBlbWJlZC5kZWZpbmVFbWJlZEVsZW1lbnQodGhpcy52aWRlbywgdGhpcy5ob2xkZXIpXG4gICAgICAudGhlbihlbGVtZW50SWQgPT4ge1xuICAgICAgICBkZWJ1ZyhOQU1FLCAnW2VsZW1lbnQ6Y29tcGxldGVdJylcbiAgICAgICAgbGV0IGZsYXNodmFycyA9IHtcbiAgICAgICAgICBidWZmZXI6IG9wdGlvbnMuYnVmZmVyICE9IG51bGwgPyBvcHRpb25zLmJ1ZmZlciA6IDIsXG4gICAgICAgICAgc3RyZWFtTW9kZTogb3B0aW9ucy5zdHJlYW1Nb2RlLFxuICAgICAgICAgIHN0cmVhbU5hbWU6IG9wdGlvbnMuc3RyZWFtTmFtZSxcbiAgICAgICAgICBhcHBOYW1lOiBvcHRpb25zLmFwcCxcbiAgICAgICAgICBob3N0OiBvcHRpb25zLmhvc3RcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5jb250ZXh0KSB7XG4gICAgICAgICAgZmxhc2h2YXJzLnJvb21OYW1lID0gb3B0aW9ucy5jb250ZXh0XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMud2lkdGggJiYgIWlzTmFOKE51bWJlcihvcHRpb25zLndpZHRoKSkpIHtcbiAgICAgICAgICBmbGFzaHZhcnMud2lkdGggPSBvcHRpb25zLndpZHRoXG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuaGVpZ2h0ICYmICFpc05hTihOdW1iZXIob3B0aW9ucy5oZWlnaHQpKSkge1xuICAgICAgICAgIGZsYXNodmFycy5oZWlnaHQgPSBvcHRpb25zLmhlaWdodFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbWJlZC5lbWJlZFN3Zk9iamVjdChzd2ZJZCwgb3B0aW9ucywgZmxhc2h2YXJzLCBlbnZpcm9ubWVudC5nZXRTd2ZPYmplY3QoKSwgZWxlbWVudElkKVxuICAgICAgfSlcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgZGVidWcoTkFNRSwgJ1tlbWJlZDpjb21wbGV0ZV0nKVxuICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHNlbGYpXG4gICAgICB9KVxuICAgICAgLmNhdGNoKGVyciA9PiBkZWZlcnJlZC5yZWplY3QoZXJyKSlcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZVxuICB9XG5cbiAgZGlzY29ubmVjdCAoKSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIE5vIGludm9jYWJsZSBBUEkgZm9yIGN1c3RvbSBsaXZlIGZsYXNoIHB1Ymxpc2hlciBmcm9tIFJlZDUgUHJvIGF0IHRoZSB0aW1lLlxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIG5hZGEuXG4gICAgfVxuICAgIHRoaXMuY2xlYW5VcCgpXG4gIH1cblxuICBnZXRUeXBlICgpIHtcbiAgICByZXR1cm4gdGhpcy5wdWJsaXNoZXJUeXBlXG4gIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBQdWJsaXNoZXJTb3VyY2VIYW5kbGVyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9qcy9wdWJsaXNoZXIvcHViLXNvdXJjZS1oYW5kbGVyLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5cbmltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnLi4vY29yZS9ldmVudC1lbWl0dGVyJ1xuaW1wb3J0IHsgUHVibGlzaGVyRXZlbnQgfSBmcm9tICcuLi9ldmVudCdcbmltcG9ydCBQdWJsaXNoZXJTb2NrZXRIZWxwZXIgZnJvbSAnLi4vaGVscGVyL3NvY2tldC1oZWxwZXItcHViJ1xuaW1wb3J0IFB1Ymxpc2hlclBlZXJIZWxwZXIgZnJvbSAnLi4vaGVscGVyL3dlYnJ0Yy1oZWxwZXItcHViJ1xuaW1wb3J0IHsgUHVibGlzaE1vZGVUeXBlcyB9IGZyb20gJy4uL2VudW0vcHVibGlzaCdcbmltcG9ydCB7IERlZmVycmVkUHJvbWlzZSwgRnV0dXJlIH0gZnJvbSAnLi4vdXRpbC9wcm9taXNlJ1xuaW1wb3J0IGVudmlyb25tZW50IGZyb20gJy4uL2Vudi9icm93c2VyJ1xuaW1wb3J0ICogYXMgd2VicnRjIGZyb20gJy4uL2FkYXB0ZXIvd2VicnRjJ1xuaW1wb3J0ICogYXMgd2Vic29ja2V0IGZyb20gJy4uL2FkYXB0ZXIvd2Vic29ja2V0J1xuaW1wb3J0IHsgUHVibGlzaFR5cGVzIH0gZnJvbSAnLi4vZW51bS9wdWJsaXNoJ1xuaW1wb3J0IHsgUHVibGlzaGVyRXZlbnRUeXBlcywgUlRDUHVibGlzaGVyRXZlbnRUeXBlcyB9IGZyb20gJy4uL2V2ZW50J1xuXG5pbXBvcnQgeyBkZWJ1ZyBhcyBkZWJ1Z0xvZyB9IGZyb20gJy4uL2xvZydcbmltcG9ydCB7IGVycm9yIGFzIGVycm9yTG9nIH0gZnJvbSAnLi4vbG9nJ1xuaW1wb3J0IHsgd2FybiBhcyB3YXJuTG9nIH0gZnJvbSAnLi4vbG9nJ1xuXG5jb25zdCBkZWZhdWx0U3RyZWFtVHlwZSA9ICd3ZWJydGMnXG5jb25zdCBlbmRwb2ludEZyb21PcHRpb25zID0gKG9wdGlvbnMpID0+IHtcbiAgY29uc3QgcHJvdG9jb2wgPSBvcHRpb25zLndzcHJvdG9jb2wgfHwgb3B0aW9ucy5wcm90b2NvbFxuICBjb25zdCBwb3J0ID0gb3B0aW9ucy53c3BvcnQgfHwgb3B0aW9ucy5wb3J0XG4gIGNvbnN0IGFwcEVuZHBvaW50ID0gb3B0aW9ucy5jb250ZXh0ID8gW29wdGlvbnMuYXBwLCBvcHRpb25zLmNvbnRleHRdLmpvaW4oJy8nKSA6IG9wdGlvbnMuYXBwXG4gIHJldHVybiBgJHtwcm90b2NvbH06Ly8ke29wdGlvbnMuaG9zdH06JHtwb3J0fS8ke2FwcEVuZHBvaW50fT9pZD0ke29wdGlvbnMuc3RyZWFtTmFtZX1gXG59XG5cbmNvbnN0IHB1YlN0YXJ0UmVnZXggPSAvKC4qKSBzdGFydGluZy9naVxuY29uc3QgcHViU3RvcFJlZ2V4ID0gLyguKikgc3RvcHBpbmcvZ2lcbmNvbnN0IE5BTUUgPSAnUlRDUHVibGlzaGVyJ1xuY29uc3QgZGVidWcgPSAobWVzc2FnZSkgPT4ge1xuICBkZWJ1Z0xvZyhOQU1FLCBtZXNzYWdlKVxufVxuY29uc3Qgd2FybiA9IChtZXNzYWdlKSA9PiB7XG4gIHdhcm5Mb2coTkFNRSwgbWVzc2FnZSlcbn1cbmNvbnN0IGVycm9yID0gKG1lc3NhZ2UpID0+IHtcbiAgZXJyb3JMb2coTkFNRSwgbWVzc2FnZSlcbn1cblxuY2xhc3MgUlRDUHVibGlzaGVyIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcblxuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuX29wdGlvbnMgPSB1bmRlZmluZWRcbiAgICB0aGlzLl92aWV3ID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fcGVlckhlbHBlciA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX3NvY2tldEhlbHBlciA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX21lZGlhU3RyZWFtID0gdW5kZWZpbmVkXG5cbiAgICB0aGlzLl9zdHJlYW1GdXR1cmUgPSB1bmRlZmluZWRcbiAgICB0aGlzLl9hdmFpbGFibGVGdXR1cmUgPSB1bmRlZmluZWRcbiAgICB0aGlzLl9wZWVyRnV0dXJlID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fb2ZmZXJGdXR1cmUgPSB1bmRlZmluZWRcbiAgICB0aGlzLl9zZW5kT2ZmZXJGdXR1cmUgPSB1bmRlZmluZWRcbiAgICB0aGlzLl90cmlja2xlRW5kRnV0dXJlID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fcHVibGlzaEZ1dHVyZSA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX3VucHVibGlzaEZ1dHVyZSA9IHVuZGVmaW5lZFxuICB9XG5cbiAgX2dldE1lZGlhU3RyZWFtICgpIHtcbiAgICB0aGlzLl9zdHJlYW1GdXR1cmUgPSBGdXR1cmUuY3JlYXRlSWZOb3RFeGlzdCh0aGlzLl9zdHJlYW1GdXR1cmUpXG4gICAgcmV0dXJuIHRoaXMuX3N0cmVhbUZ1dHVyZS5wcm9taXNlXG4gIH1cblxuICBfZ2V0VHJpY2tsZUVuZCAoKSB7XG4gICAgcmV0dXJuIEZ1dHVyZS5jcmVhdGVJZk5vdEV4aXN0KHRoaXMuX3RyaWNrbGVFbmRGdXR1cmUpXG4gIH1cblxuICBpbml0IChvcHRpb25zKSB7XG4gICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWRQcm9taXNlKClcbiAgICBpZiAoIXdlYnJ0Yy5pc1N1cHBvcnRlZCgpIHx8ICF3ZWJzb2NrZXQuaXNTdXBwb3J0ZWQoKSkge1xuICAgICAgZGVmZXJyZWQucmVqZWN0KCdDYW5ub3QgY3JlYXRlIFdlYlJUQyBwbGF5YmFjayBpbnN0YW5jZS4gWW91ciBlbnZpcm9ubWVudCBkb2VzIG5vdCBzdXBwb3J0IFdlYlJUQyBhbmQvb3IgV2ViU29ja2V0cy4nKVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zXG4gICAgICB0aGlzLl9wZWVySGVscGVyID0gbmV3IFB1Ymxpc2hlclBlZXJIZWxwZXIodGhpcylcbiAgICAgIHRoaXMuX3NvY2tldEhlbHBlciA9IG5ldyBQdWJsaXNoZXJTb2NrZXRIZWxwZXIodGhpcylcbiAgICAgIGRlZmVycmVkLnJlc29sdmUodGhpcylcbiAgICB9XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2VcbiAgfVxuXG4gIHNldFZpZXcgKHZpZXcpIHtcbiAgICB0aGlzLl92aWV3ID0gdmlld1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBhdHRhY2hTdHJlYW0gKG1lZGlhKSB7XG4gICAgdGhpcy5fc3RyZWFtRnV0dXJlID0gRnV0dXJlLmNyZWF0ZUlmTm90RXhpc3QodGhpcy5fc3RyZWFtRnV0dXJlKVxuICAgIHRoaXMuX3N0cmVhbUZ1dHVyZS5yZXNvbHZlKG1lZGlhKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBkZXRhY2hTdHJlYW0gKCkge1xuICAgIGlmICh0aGlzLl9tZWRpYVN0cmVhbSAmJiB0aGlzLl9tZWRpYVN0cmVhbS5zdG9wKSB7XG4gICAgICB0aGlzLl9tZWRpYVN0cmVhbS5zdG9wKClcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5fbWVkaWFTdHJlYW0gJiYgdGhpcy5fbWVkaWFTdHJlYW0uZ2V0VHJhY2tzKSB7XG4gICAgICBjb25zdCB0cmFja3MgPSB0aGlzLl9tZWRpYVN0cmVhbS5nZXRUcmFja3MoKVxuICAgICAgbGV0IHRyYWNrTGVuZ3RoID0gdHJhY2tzLmxlbmd0aDtcbiAgICAgIHdoaWxlICgtLXRyYWNrTGVuZ3RoID4gLTEpIHtcbiAgICAgICAgaWYgKHRyYWNrc1t0cmFja0xlbmd0aF0uc3RvcCkge1xuICAgICAgICAgIHRyYWNrc1t0cmFja0xlbmd0aF0uc3RvcCgpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fc3RyZWFtRnV0dXJlID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fbWVkaWFTdHJlYW0gPSB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgcmVxdWVzdEF2YWlsYWJpbGl0eSAoc3RyZWFtTmFtZSwgdHlwZSkge1xuICAgIGRlYnVnKCdbcmVxdWVzdGF2YWlsYWJpbGl0eV0nKVxuICAgIHRoaXMuX2F2YWlsYWJsZUZ1dHVyZSA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX2F2YWlsYWJsZUZ1dHVyZSA9IEZ1dHVyZS5jcmVhdGVJZk5vdEV4aXN0KHRoaXMuX2F2YWlsYWJsZUZ1dHVyZSlcbiAgICAvLyBtZXNzYWdlIG9uIHNvY2tldCByZXR1cm5zIC0+IG9uU3RyZWFtKFVuKUF2YWlsYWJsZVxuICAgIHRoaXMuX3NvY2tldEhlbHBlci5wb3N0KHtcbiAgICAgIGlzQXZhaWxhYmxlOiBzdHJlYW1OYW1lLFxuICAgICAgdHlwZTogdHlwZSxcbiAgICAgIGJ1bmRsZTogZmFsc2VcbiAgICB9KVxuICAgIHJldHVybiB0aGlzLl9hdmFpbGFibGVGdXR1cmUucHJvbWlzZVxuICB9XG5cbiAgY3JlYXRlUGVlckNvbm5lY3Rpb24gKGljZVNlcnZlcnMpIHtcbiAgICBkZWJ1ZygnW2NyZWF0ZXBlZWVyXScpXG4gICAgdGhpcy5fcGVlckZ1dHVyZSA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX3BlZXJGdXR1cmUgPSBGdXR1cmUuY3JlYXRlSWZOb3RFeGlzdCh0aGlzLl9wZWVyRnV0dXJlKVxuICAgIHRoaXMuX3BlZXJIZWxwZXIuc2V0VXAoaWNlU2VydmVycywgdGhpcy5fcGVlckZ1dHVyZSlcbiAgICByZXR1cm4gdGhpcy5fcGVlckZ1dHVyZS5wcm9taXNlXG4gIH1cblxuICBjcmVhdGVPZmZlciAoY29uc3RyYWludHMsIGJhbmR3aWR0aCA9IG51bGwpIHtcbiAgICBkZWJ1ZygnW2NyZWF0ZW9mZmVyXScpXG4gICAgdGhpcy5fb2ZmZXJGdXR1cmUgPSB1bmRlZmluZWRcbiAgICB0aGlzLl9vZmZlckZ1dHVyZSA9IEZ1dHVyZS5jcmVhdGVJZk5vdEV4aXN0KHRoaXMuX29mZmVyRnV0dXJlKVxuICAgIHRoaXMuX3BlZXJIZWxwZXIuY3JlYXRlT2ZmZXIoYmFuZHdpZHRoLCB0aGlzLl9vZmZlckZ1dHVyZSlcbiAgICByZXR1cm4gdGhpcy5fb2ZmZXJGdXR1cmUucHJvbWlzZVxuICB9XG5cbiAgc2V0UmVtb3RlRGVzY3JpcHRpb24gKHNkcCkge1xuICAgIGRlYnVnKCdbc2V0cmVtb3RlZGVzY3JpcHRpb25dJylcbiAgICByZXR1cm4gdGhpcy5fcGVlckhlbHBlci5zZXRSZW1vdGVEZXNjcmlwdGlvbihzZHApXG4gIH1cblxuICBzZW5kT2ZmZXIgKHNkcCwgc3RyZWFtTmFtZSkge1xuICAgIGRlYnVnKCdbc2VuZG9mZmVyXScpXG4gICAgdGhpcy5fc2VuZE9mZmVyRnV0dXJlID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fc2VuZE9mZmVyRnV0dXJlID0gRnV0dXJlLmNyZWF0ZUlmTm90RXhpc3QodGhpcy5fc2VuZE9mZkZ1dHVyZSlcbiAgICB0aGlzLl9zb2NrZXRIZWxwZXIucG9zdCh7XG4gICAgICBoYW5kbGVPZmZlcjogc3RyZWFtTmFtZSxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgc2RwOiBzZHBcbiAgICAgIH1cbiAgICB9KVxuICAgIHJldHVybiB0aGlzLl9zZW5kT2ZmZXJGdXR1cmUucHJvbWlzZVxuICB9XG5cbiAgc2VuZENhbmRpZGF0ZSAoY2FuZGlkYXRlLCBzdHJlYW1OYW1lKSB7XG4gICAgZGVidWcoJ1tzZW5kY2FuZGlkYXRlXScpXG4gICAgdGhpcy5fc29ja2V0SGVscGVyLnBvc3Qoe1xuICAgICAgaGFuZGxlQ2FuZGlkYXRlOiBzdHJlYW1OYW1lLFxuICAgICAgZGF0YToge1xuICAgICAgICBjYW5kaWRhdGU6IGNhbmRpZGF0ZVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICByZXF1ZXN0UHVibGlzaCAoc3RyZWFtTmFtZSwgc3RyZWFtTW9kZSkge1xuICAgIGRlYnVnKCdbcmVxdWVzdHB1Ymxpc2hdJylcbiAgICB0aGlzLl9wdWJsaXNoRnV0dXJlID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fcHVibGlzaEZ1dHVyZSA9IEZ1dHVyZS5jcmVhdGVJZk5vdEV4aXN0KHRoaXMuX3B1Ymxpc2hGdXR1cmUpXG4gICAgdGhpcy5fc29ja2V0SGVscGVyLnBvc3Qoe1xuICAgICAgcHVibGlzaDogc3RyZWFtTmFtZSxcbiAgICAgIG1vZGU6IHN0cmVhbU1vZGVcbiAgICB9KVxuICAgIHJldHVybiB0aGlzLl9wdWJsaXNoRnV0dXJlLnByb21pc2VcbiAgfVxuXG4gIHJlcXVlc3RVbnB1Ymxpc2ggKHN0cmVhbU5hbWUpIHtcbiAgICB0aGlzLl91bnB1Ymxpc2hGdXR1cmUgPSB1bmRlZmluZWRcbiAgICB0aGlzLl91bnB1Ymxpc2hGdXR1cmUgPSBGdXR1cmUuY3JlYXRlSWZOb3RFeGlzdCh0aGlzLl91bnB1Ymxpc2hGdXR1cmUpXG4gICAgdGhpcy5fc29ja2V0SGVscGVyLnBvc3Qoe1xuICAgICAgdW5wdWJsaXNoOiBzdHJlYW1OYW1lXG4gICAgfSlcbiAgICByZXR1cm4gdGhpcy5fdW5wdWJsaXNoRnV0dXJlLnByb21pc2VcbiAgfVxuXG4gIHB1Ymxpc2ggKHN0cmVhbU5hbWUgPSBudWxsLCBwcm9taXNlID0gbnVsbCkge1xuICAgIGRlYnVnKCdbcHVibGlzaF0nKVxuICAgIHRoaXMuX29wdGlvbnMuc3RyZWFtTmFtZSA9IHN0cmVhbU5hbWUgfHwgdGhpcy5fb3B0aW9ucy5zdHJlYW1OYW1lXG4gICAgdGhpcy5fb3B0aW9ucy5zdHJlYW1Nb2RlID0gdGhpcy5fb3B0aW9ucy5zdHJlYW1Nb2RlIHx8IFB1Ymxpc2hNb2RlVHlwZXMuTElWRVxuICAgIGNvbnN0IHAgPSBwcm9taXNlIHx8IG5ldyBEZWZlcnJlZFByb21pc2UoKVxuICAgIGNvbnN0IHNvY2tldFByb21pc2UgPSBuZXcgRGVmZXJyZWRQcm9taXNlKClcbiAgICBjb25zdCBzb2NrZXR1cmwgPSBlbmRwb2ludEZyb21PcHRpb25zKHRoaXMuX29wdGlvbnMpXG4gICAgdGhpcy5fdHJpY2tsZUVuZEZ1dHVyZSA9IHRoaXMuX2dldFRyaWNrbGVFbmQoKVxuICAgIHRoaXMuX3NvY2tldEhlbHBlci5zZXRVcChzb2NrZXR1cmwsIHNvY2tldFByb21pc2UpXG4vLyAwLiBFc3RhYmxpc2ggc29ja2V0IGNvbm5lY3Rpb24uXG4gICAgc29ja2V0UHJvbWlzZS5wcm9taXNlXG4vLyAxLiBXYWl0IGZvciBzdHJlYW0gYXR0YWNoXG4gICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICB0aGlzLnRyaWdnZXIobmV3IFB1Ymxpc2hlckV2ZW50KFB1Ymxpc2hlckV2ZW50VHlwZXMuQ09OTkVDVF9TVUNDRVNTLCB0aGlzKSlcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldE1lZGlhU3RyZWFtKClcbiAgICAgIH0pXG4vLyAyLiBSZXF1ZXN0IGF2YWlsYWJsZSBzdHJlYW0gdG8gcHVibGlzaCBvblxuICAgICAgLnRoZW4obWVkaWFTdHJlYW0gPT4ge1xuICAgICAgICB0aGlzLl9tZWRpYVN0cmVhbSA9IG1lZGlhU3RyZWFtXG4gICAgICAgIHRoaXMudHJpZ2dlcihuZXcgUHVibGlzaGVyRXZlbnQoUlRDUHVibGlzaGVyRXZlbnRUeXBlcy5NRURJQV9TVFJFQU1fQVZBSUxBQkxFLCB0aGlzLCBtZWRpYVN0cmVhbSkpXG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RBdmFpbGFiaWxpdHkodGhpcy5fb3B0aW9ucy5zdHJlYW1OYW1lLCB0aGlzLl9vcHRpb25zLnN0cmVhbVR5cGUgfHwgZGVmYXVsdFN0cmVhbVR5cGUpXG4gICAgICB9KVxuLy8gMy4gQ3JlYXRlIFBlZXIgQ29ubmVjdGlvblxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVQZWVyQ29ubmVjdGlvbih0aGlzLl9vcHRpb25zLmljZVNlcnZlcnMpXG4gICAgICB9KVxuLy8gNC4gTWFrZSBPZmZlciBvbiBQZWVyIENvbm5lY3Rpb25cbiAgICAgIC50aGVuKGNvbm5lY3Rpb24gPT4ge1xuICAgICAgICBjb25uZWN0aW9uLmFkZFN0cmVhbSh0aGlzLl9tZWRpYVN0cmVhbSlcbiAgICAgICAgdGhpcy50cmlnZ2VyKG5ldyBQdWJsaXNoZXJFdmVudChSVENQdWJsaXNoZXJFdmVudFR5cGVzLlBFRVJfQ09OTkVDVElPTl9BVkFJTEFCTEUsIHRoaXMsIGNvbm5lY3Rpb24pKVxuICAgICAgICB0aGlzLl9vcHRpb25zLnB1Ymxpc2hDb25zdHJhaW50cyA9IHRoaXMuX29wdGlvbnMucHVibGlzaENvbnN0cmFpbnQgfHwgZW52aXJvbm1lbnQuZ2V0RGVmYXVsdFB1Ymxpc2hDb25zdHJhaW50cygpXG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZU9mZmVyKHRoaXMuX29wdGlvbnMucHVibGlzaENvbnN0cmFpbnRzLCB0aGlzLl9vcHRpb25zLmJhbmR3aWR0aClcbiAgICAgIH0pXG4vLyA1LiBTZW5kIE9mZmVyXG4gICAgICAudGhlbihzZXNzaW9uRGVzY3JpcHRpb24gPT4ge1xuICAgICAgICB0aGlzLnRyaWdnZXIobmV3IFB1Ymxpc2hlckV2ZW50KFJUQ1B1Ymxpc2hlckV2ZW50VHlwZXMuT0ZGRVJfU1RBUlQsIHRoaXMsIHNlc3Npb25EZXNjcmlwdGlvbikpXG4gICAgICAgIHJldHVybiB0aGlzLnNlbmRPZmZlcihzZXNzaW9uRGVzY3JpcHRpb24sIHRoaXMuX29wdGlvbnMuc3RyZWFtTmFtZSlcbiAgICAgIH0pXG4vLyA2LiBTZXQgdGhlIHNlc3Npb24gZGVzY3JpcHRpb24gcmVtb3RlbHlcbiAgICAgIC50aGVuKHNkcCA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldFJlbW90ZURlc2NyaXB0aW9uKHNkcC5zZHApXG4gICAgICB9KVxuLy8gNy4gV2FpdCB1bnRpbCBpY2UgdHJpY2tsZSBlbmRcbiAgICAgIC50aGVuKHNkcCA9PiB7XG4gICAgICAgIHRoaXMudHJpZ2dlcihuZXcgUHVibGlzaGVyRXZlbnQoUlRDUHVibGlzaGVyRXZlbnRUeXBlcy5PRkZFUl9FTkQsIHRoaXMsIHNkcCkpXG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRUcmlja2xlRW5kKCkucHJvbWlzZVxuICAgICAgfSlcbi8vIDguIFJlcXVlc3QgdG8gcHVibGlzaCBzdHJlYW1cbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgdGhpcy50cmlnZ2VyKG5ldyBQdWJsaXNoZXJFdmVudChSVENQdWJsaXNoZXJFdmVudFR5cGVzLklDRV9UUklDS0xFX0NPTVBMRVRFLCB0aGlzKSlcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdFB1Ymxpc2godGhpcy5fb3B0aW9ucy5zdHJlYW1OYW1lLCB0aGlzLl9vcHRpb25zLnN0cmVhbU1vZGUpXG4gICAgICB9KVxuLy8gOS4gUmVzdWx0cyBpbiBzb2NrZXQgbWVzc2FnZSBvZiBwdWJsaXNoIChzZWUgOm9uUHVibGlzaFN0YXR1cylcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgcC5yZXNvbHZlKHRoaXMpXG4gICAgICAgIHRoaXMudHJpZ2dlcihuZXcgUHVibGlzaGVyRXZlbnQoUHVibGlzaGVyRXZlbnRUeXBlcy5QVUJMSVNIX1NUQVJULCB0aGlzKSlcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgIHAucmVqZWN0KGVycm9yKVxuICAgICAgICB0aGlzLnRyaWdnZXIobmV3IFB1Ymxpc2hlckV2ZW50KFB1Ymxpc2hlckV2ZW50VHlwZXMuQ09OTkVDVF9GQUlMVVJFLCB0aGlzLCBlcnJvcikpXG4gICAgICB9KVxuICAgIHJldHVybiBwLmhhc093blByb3BlcnR5KCdwcm9taXNlJykgPyBwLnByb21pc2UgOiBwXG4gIH1cblxuICB1bnB1Ymxpc2ggKCkge1xuICAgIGRlYnVnKCdbdW5wdWJsaXNoXScpXG4gICAgaWYgKHRoaXMuX3NvY2tldEhlbHBlcikge1xuICAgICAgdGhpcy5fc29ja2V0SGVscGVyLnRlYXJEb3duKClcbiAgICB9XG4gICAgaWYgKHRoaXMuX3BlZXJIZWxwZXIpIHtcbiAgICAgIHRoaXMuX3BlZXJIZWxwZXIudGVhckRvd24oKVxuICAgIH1cbiAgICB0aGlzLmRldGFjaFN0cmVhbSgpXG4gICAgdGhpcy5fYXZhaWxhYmxlRnV0dXJlID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fcGVlckZ1dHVyZSA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX29mZmVyRnV0dXJlID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fc2VuZE9mZmVyRnV0dXJlID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fdHJpY2tsZUVuZEZ1dHVyZSA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX3B1Ymxpc2hGdXR1cmUgPSB1bmRlZmluZWRcbiAgICBjb25zdCBmID0gdGhpcy5yZXF1ZXN0VW5wdWJsaXNoKHRoaXMuX29wdGlvbnMuc3RyZWFtTmFtZSlcbiAgICBmLnRoZW4oKCkgPT4ge1xuICAgICAgdGhpcy5fdW5wdWJsaXNoRnV0dXJlID0gdW5kZWZpbmVkXG4gICAgICB0aGlzLnRyaWdnZXIobmV3IFB1Ymxpc2hlckV2ZW50KFB1Ymxpc2hlckV2ZW50VHlwZXMuVU5QVUJMSVNIX1NVQ0NFU1MsIHRoaXMpKVxuICAgIH0pXG4gICAgcmV0dXJuIGZcbiAgfVxuXG4gIG9uU3RyZWFtQXZhaWxhYmxlIChyZWNlaXB0KSB7XG4gICAgZGVidWcoJ1tvbnN0cmVhbWF2YWlsYWJsZV06ICcgKyBKU09OLnN0cmluZ2lmeShyZWNlaXB0LCBudWxsLCAyKSlcbiAgICB0aGlzLl9hdmFpbGFibGVGdXR1cmUgPSBGdXR1cmUuY3JlYXRlSWZOb3RFeGlzdCh0aGlzLl9hdmFpbGFibGVGdXR1cmUpXG4gICAgdGhpcy5fYXZhaWxhYmxlRnV0dXJlLnJlamVjdChgU3RyZWFtIHdpdGggbmFtZSAke3RoaXMuX29wdGlvbnMuc3RyZWFtTmFtZX0gYWxyZWFkeSBoYXMgYSBicm9hZGNhc3Qgc2Vzc2lvbi5gKVxuICAgIHRoaXMudHJpZ2dlcihuZXcgUHVibGlzaGVyRXZlbnQoUHVibGlzaGVyRXZlbnRUeXBlcy5QVUJMSVNIX0lOVkFMSURfTkFNRSwgdGhpcykpXG4gIH1cblxuICBvblN0cmVhbVVuYXZhaWxhYmxlIChyZWNlaXB0KSB7XG4gICAgLy8gQmVpbmcgdW5hdmFpbGFibGUsIGlzIGEgZ29vZCB0aGluZyBmb3IgYWxsb3dpbmcgdG8gcHVibGlzaCB1c2luZyBgb3B0aW9ucy5zdHJlYW1OYW1lYFxuICAgIGRlYnVnKGBTdHJlYW0gJHt0aGlzLl9vcHRpb25zLnN0cmVhbU5hbWV9IGRvZXMgbm90IGV4aXN0LmApXG4gICAgZGVidWcoJ1tvbnN0cmVhbXVuYXZhaWxhYmxlXTogJyArIEpTT04uc3RyaW5naWZ5KHJlY2VpcHQsIG51bGwsIDIpKVxuICAgIHRoaXMuX2F2YWlsYWJsZUZ1dHVyZSA9IEZ1dHVyZS5jcmVhdGVJZk5vdEV4aXN0KHRoaXMuX2F2YWlsYWJsZUZ1dHVyZSlcbiAgICB0aGlzLl9hdmFpbGFibGVGdXR1cmUucmVzb2x2ZSh0cnVlKVxuICB9XG5cbiAgb25Tb2NrZXRNZXNzYWdlRXJyb3IgKG1lc3NhZ2UsIGRldGFpbCA9IG51bGwpIHtcbiAgICBlcnJvcihgRXJyb3IgaW4gc3RyZWFtIHBsYXliYWNrOiAke21lc3NhZ2V9LlxcbltPcHRpb25hbCBkZXRhaWxdOiAke2RldGFpbH1gKVxuICAgIGlmICh0aGlzLl9wdWJsaXNoRnV0dXJlKSB7XG4gICAgICB0aGlzLnRyaWdnZXIobmV3IFB1Ymxpc2hlckV2ZW50KFB1Ymxpc2hlckV2ZW50VHlwZXMuUFVCTElTSF9GQUlMLCB0aGlzKSlcbiAgICAgIHRoaXMuX3B1Ymxpc2hGdXR1cmUucmVqZWN0KG1lc3NhZ2UpXG4gICAgfVxuICB9XG5cbiAgb25TRFBTdWNjZXNzIChyZWNlaXB0KSB7XG4gICAgbGV0IGluZm8gPSByZWNlaXB0ID8gJzogJyArIEpTT04uc3RyaW5naWZ5KHJlY2VpcHQsIG51bGwsIDIpIDogJydcbiAgICBkZWJ1ZyhgW29uc2Rwc3VjY2Vzc10ke2luZm99YClcbiAgfVxuXG4gIG9uU0RQRXJyb3IgKHJlY2VpcHQpIHtcbiAgICBsZXQgZXJyb3IgPSByZWNlaXB0ID8gJzogJyArIEpTT04uc3RyaW5naWZ5KHJlY2VpcHQsIG51bGwsIDIpIDogJydcbiAgICBlcnJvcihgW29uc2RwZXJyb3JdJHtlcnJvcn1gKVxuICB9XG5cbiAgb25TRFBBbnN3ZXIgKHNkcCkge1xuICAgIGRlYnVnKCdbc2RwYW5zd2VyXScpXG4gICAgdGhpcy5fc2VuZE9mZmVyRnV0dXJlID0gRnV0dXJlLmNyZWF0ZUlmTm90RXhpc3QodGhpcy5fc2VuZE9mZmVyRnV0dXJlKVxuICAgIHRoaXMuX3NlbmRPZmZlckZ1dHVyZS5yZXNvbHZlKHNkcClcbiAgfVxuXG4gIG9uQWRkSWNlQ2FuZGlkYXRlIChjYW5kaWRhdGUpIHtcbiAgICBkZWJ1ZygnW2FkZGljZWNhbmRpZGF0ZV0nKVxuICAgIHRoaXMuX3BlZXJIZWxwZXIuYWRkSWNlQ2FuZGlkYXRlKGNhbmRpZGF0ZSlcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgZGVidWcoJ1thZGRpY2VjYW5kaWRhdGU6c3VjY2Vzc10nKVxuICAgICAgfSlcbiAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICB3YXJuKGBbYWRkaWNlY2FuZGlkYXRlOmVycm9yXSAtICR7ZXJyfWApXG4gICAgICB9KVxuICB9XG5cbiAgb25JY2VDYW5kaWRhdGUgKGNhbmRpZGF0ZSkge1xuICAgIGRlYnVnKCdbaWNlY2FuZGlkYXRldHJpY2tsZV0nKVxuICAgIHRoaXMuc2VuZENhbmRpZGF0ZShjYW5kaWRhdGUsIHRoaXMuX29wdGlvbnMuc3RyZWFtTmFtZSlcbiAgfVxuXG4gIG9uSWNlQ2FuZGlkYXRlVHJpY2tsZUVuZCAoKSB7XG4gICAgZGVidWcoJ1tpY2VjYW5kaWRhdGV0cmlja2xlOmVuZF0nKVxuICB9XG5cbiAgb25Tb2NrZXRJY2VDYW5kaWRhdGVFbmQgKCkge1xuICAgIGRlYnVnKCdbc29ja2V0aWNlY2FuZGlkYXRlOmVuZF0nKVxuICAgIHRoaXMuX2dldFRyaWNrbGVFbmQoKS5yZXNvbHZlKClcbiAgICB0aGlzLl90cmlja2xlRW5kRnV0dXJlID0gdW5kZWZpbmVkXG4gIH1cblxuICBvblB1Ymxpc2hlclN0YXR1cyAoc3RhdHVzKSB7XG4gICAgZGVidWcoJ1twdWJsaXNoZXJzdGF0dXNdIC0gJyArIEpTT04uc3RyaW5naWZ5KHN0YXR1cywgbnVsbCwgMikpXG4gICAgY29uc3Qgc3RvcFJlc3VsdCA9IHB1YlN0b3BSZWdleC5leGVjKHN0YXR1cy5tZXNzYWdlKVxuICAgIGNvbnN0IHN0YXJ0UmVzdWx0ID0gcHViU3RhcnRSZWdleC5leGVjKHN0YXR1cy5tZXNzYWdlKVxuICAgIGlmIChzdG9wUmVzdWx0ICYmIHN0b3BSZXN1bHRbMV0gPT09IHRoaXMuX29wdGlvbnMuc3RyZWFtTmFtZSkge1xuICAgICAgdGhpcy5fdW5wdWJsaXNoRnV0dXJlLnJlc29sdmUoKVxuICAgIH0gZWxzZSBpZiAoc3RhcnRSZXN1bHQgJiYgc3RhcnRSZXN1bHRbMV0gPT09IHRoaXMuX29wdGlvbnMuc3RyZWFtTmFtZSkge1xuICAgICAgdGhpcy5fcHVibGlzaEZ1dHVyZS5yZXNvbHZlKClcbiAgICB9IGVsc2Uge1xuICAgICAgd2FybignUHVibGlzaGVyIHN0YXR1cyByZWNlaXZlZCwgYnV0IGNvdWxkIG5vdCBoYW5kbGUuJylcbiAgICB9XG4gIH1cblxuICBnZXQgc29ja2V0ICgpIHtcbiAgICByZXR1cm4gdGhpcy5fd2Vic29ja2V0XG4gIH1cblxuICBnZXRQZWVyQ29ubmVjdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BlZXJIZWxwZXIgPyB0aGlzLl9wZWVySGVscGVyLmNvbm5lY3Rpb24gOiB1bmRlZmluZWRcbiAgfVxuXG4gIGdldE1lZGlhU3RyZWFtICgpIHtcbiAgICByZXR1cm4gdGhpcy5fbWVkaWFTdHJlYW1cbiAgfVxuXG4gIGdldFR5cGUgKCkge1xuICAgIHJldHVybiBQdWJsaXNoVHlwZXMuUlRDLnRvVXBwZXJDYXNlKClcbiAgfVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFJUQ1B1Ymxpc2hlclxuXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9qcy9wdWJsaXNoZXIvcmVkNXByby1ydGMuanNcbiAqKi8iLCIndXNlIHN0cmljdCdcblxuaW1wb3J0IFNvY2tldEhlbHBlciBmcm9tICcuL3NvY2tldC1oZWxwZXInXG5pbXBvcnQgeyB3YXJuLCBlcnJvciB9IGZyb20gJy4uL2xvZydcblxuY29uc3QgTkFNRSA9ICdSNVByb1B1Ymxpc2hlclNvY2tldCdcblxuY2xhc3MgUHVibGlzaGVyU29ja2V0SGVscGVyIGV4dGVuZHMgU29ja2V0SGVscGVyIHtcblxuICBjb25zdHJ1Y3RvciAocmVzcG9uZGVyKSB7XG4gICAgc3VwZXIocmVzcG9uZGVyLCBOQU1FKVxuICB9XG5cbiAgcmVzcG9uZCAobWVzc2FnZSkge1xuICAgIC8vICAgIGNvbnNvbGUubG9nKG1lc3NhZ2UpXG4gICAgaWYgKG1lc3NhZ2UuZGF0YSkge1xuICAgICAgbGV0IGpzb24gPSB0aGlzLmdldEpzb25Gcm9tU29ja2V0TWVzc2FnZShtZXNzYWdlKVxuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFzdXBlci5yZXNwb25kKG1lc3NhZ2UpKSB7XG4gICAgICAgICAgaWYgKGpzb24uZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoanNvbi5kYXRhLnNkcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGlmIChqc29uLmRhdGEuc2RwLnR5cGUgPT09ICdhbnN3ZXInKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzcG9uZGVyLm9uU0RQQW5zd2VyKGpzb24uZGF0YSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGpzb24uZGF0YS5jYW5kaWRhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB0aGlzLl9yZXNwb25kZXIub25BZGRJY2VDYW5kaWRhdGUoanNvbi5kYXRhLmNhbmRpZGF0ZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChqc29uLmRhdGEudHlwZSA9PT0gJ3N0YXR1cycpIHtcbiAgICAgICAgICAgICAgaWYgKGpzb24uZGF0YS5jb2RlID09PSAnTmV0Q29ubmVjdGlvbi5JQ0UuVHJpY2xlQ29tcGxldGVkJykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Jlc3BvbmRlci5vblNvY2tldEljZUNhbmRpZGF0ZUVuZCgpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzcG9uZGVyLm9uUHVibGlzaGVyU3RhdHVzKGpzb24uZGF0YSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBlcnJvcihOQU1FLCBgW3dzLm9ubWVzc2FnZV0gLSBFcnJvciBpbiBhY2Nlc3NpbmcgbWVzc2FnZSBkYXRhIGFzIEpTT04uICR7ZS5tZXNzYWdlfWApXG4gICAgICAgIHRoaXMuX3Jlc3BvbmRlci5vblNvY2tldE1lc3NhZ2VFcnJvcihgW3dzLm9ubWVzc2FnZV0gLSBFcnJvciBpbiBhY2Nlc3NpbmcgbWVzc2FnZSBkYXRhIGFzIEpTT04uICR7ZS5tZXNzYWdlfWApXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm4oTkFNRSwgJ1t3cy5vbm1lc3NhZ2VdIC0gTm8gTWVzc2FnZSBEYXRhLicpXG4gICAgfVxuICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgUHVibGlzaGVyU29ja2V0SGVscGVyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9qcy9oZWxwZXIvc29ja2V0LWhlbHBlci1wdWIuanNcbiAqKi8iLCIndXNlIHN0cmljdCdcbmltcG9ydCAqIGFzIHdlYnJ0YyBmcm9tICcuLi9hZGFwdGVyL3dlYnJ0YydcbmltcG9ydCB7IERlZmVycmVkUHJvbWlzZSB9IGZyb20gJy4uL3V0aWwvcHJvbWlzZSdcbmltcG9ydCB7IGRlYnVnLCB3YXJuIH0gZnJvbSAnLi4vbG9nJ1xuXG5jb25zdCBOQU1FID0gJ1I1UHJvUHVibGlzaFBlZXInXG5cbmNsYXNzIFB1Ymxpc2hlclBlZXJIZWxwZXIge1xuXG4gIGNvbnN0cnVjdG9yIChyZXNwb25kZXIpIHtcbiAgICB0aGlzLl9yZXNwb25kZXIgPSByZXNwb25kZXJcbiAgICB0aGlzLl9wZWVyQ29ubmVjdGlvbiA9IHVuZGVmaW5lZFxuICB9XG5cbiAgX3JlbW92ZUNvbm5lY3Rpb25IYW5kbGVycyAoY29ubmVjdGlvbikge1xuICAgIGNvbm5lY3Rpb24ub25jb25uZWN0aW9uc3RhdGVjaGFuZ2UgPSB1bmRlZmluZWRcbiAgICBjb25uZWN0aW9uLm9uaWNlY2FuZGlkYXRlID0gdW5kZWZpbmVkXG4gIH1cblxuICBfYWRkQ29ubmVjdGlvbkhhbmRsZXJzIChjb25uZWN0aW9uLCBwcm9taXNlKSB7XG4gICAgY29ubmVjdGlvbi5vbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZSA9ICgpID0+IHtcbiAgICAgIGlmIChjb25uZWN0aW9uLmNvbm5lY3Rpb25TdGF0ZSA9PT0gJ2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgZGVidWcoTkFNRSwgJ1twZWVyY29ubmVjdGlvbjpvcGVuXScpXG4gICAgICAgIGlmIChwcm9taXNlKSB7XG4gICAgICAgICAgcHJvbWlzZS5yZXNvbHZlKHRoaXMpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY29ubmVjdGlvbi5jb25uZWN0aW9uU3RhdGUgPT09ICdmYWlsZWQnIHx8XG4gICAgICAgIGNvbm5lY3Rpb24uY29ubmVjdGlvblN0YXRlID09PSAnZGlzY29ubmVjdGVkJykge1xuICAgICAgICB3YXJuKE5BTUUsICdbcGVlcmNvbm5lY3Rpb246ZXJyb3JdJylcbiAgICAgICAgaWYgKHByb21pc2UpIHtcbiAgICAgICAgICBwcm9taXNlLnJlamVjdCgpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25uZWN0aW9uLm9uaWNlY2FuZGlkYXRlID0gKGV2ZW50KSA9PiB7XG4gICAgICBkZWJ1ZyhOQU1FLCBgW3BlZXIub25pY2VjYW5kaWRhdGVdIC0gUGVlciBDYW5kaWRhdGU6ICR7ZXZlbnQuY2FuZGlkYXRlfWApXG4gICAgICBpZiAoZXZlbnQuY2FuZGlkYXRlKSB7XG4gICAgICAgIHRoaXMuX3Jlc3BvbmRlci5vbkljZUNhbmRpZGF0ZShldmVudC5jYW5kaWRhdGUpXG4gICAgICB9IGVsc2UgaWYgKGV2ZW50LmNhbmRpZGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAvLyBudWxsIG1lYW5zIHRoZXkgaGF2ZSBmaW5pc2hlZCBzZW5kaW5nIGNhbmRpZGF0ZXMgYmFjayBhbmQgZm9ydGg/XG4gICAgICAgIC8vIE1vdmVkIHRvIG5vdGlmaWNhdGlvbiBmcm9tIHNlcnZlciBvbiB0cmlja2xlIGVuZCBldmVudC5cbiAgICAgICAgLy8gdGhpcy5fcmVzcG9uZGVyLm9uSWNlQ2FuZGlkYXRlVHJpY2tsZUVuZCgpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY3JlYXRlT2ZmZXIgKGJhbmR3aWR0aCA9IG51bGwsIG9mZmVyUHJvbWlzZSA9IG51bGwpIHtcbiAgICBkZWJ1ZyhOQU1FLCAnW2NyZWF0ZW9mZmVyXScpXG4gICAgY29uc3QgcCA9IG9mZmVyUHJvbWlzZSB8fCBuZXcgRGVmZXJyZWRQcm9taXNlKClcbiAgICB0aGlzLl9wZWVyQ29ubmVjdGlvbi5jcmVhdGVPZmZlcigpXG4gICAgICAudGhlbigoc2Vzc2lvbkRlc2NyaXB0aW9uKSA9PiB7XG4gICAgICAgIHRoaXMuc2V0TG9jYWxEZXNjcmlwdGlvbihzZXNzaW9uRGVzY3JpcHRpb24sIGJhbmR3aWR0aClcbiAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9yZXNwb25kZXIub25TRFBTdWNjZXNzKClcbiAgICAgICAgICAgIHAucmVzb2x2ZShzZXNzaW9uRGVzY3JpcHRpb24pXG4gICAgICAgICAgfSlcbiAgICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgdGhpcy5fcmVzcG9uZGVyLm9uU0RQRXJyb3IoZXJyKVxuICAgICAgICAgICAgcC5yZWplY3QoZXJyKVxuICAgICAgICAgIH0pXG4gICAgICB9KVxuICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgIGRlYnVnKE5BTUUsICdbY3JlYXRlb2ZmZXI6ZXJyb3JdJylcbiAgICAgICAgcC5yZWplY3QoZXJyKVxuICAgICAgfSlcbiAgICByZXR1cm4gcC5oYXNPd25Qcm9wZXJ0eSgncHJvbWlzZScpID8gcC5wcm9taXNlIDogcFxuICB9XG5cbiAgc2V0TG9jYWxEZXNjcmlwdGlvbiAoc2Vzc2lvbkRlc2NyaXB0aW9uLCBiYW5kd2lkdGggPSBudWxsKSB7XG4gICAgZGVidWcoTkFNRSwgJ1tzZXRsb2NhbGRlc2NyaXB0aW9uXScpXG4gICAgaWYgKGJhbmR3aWR0aCkge1xuICAgICAgc2Vzc2lvbkRlc2NyaXB0aW9uLnNkcCA9IHdlYnJ0Yy51cGRhdGVCYW5kd2lkdGgoYmFuZHdpZHRoLCBzZXNzaW9uRGVzY3JpcHRpb24uc2RwKVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcGVlckNvbm5lY3Rpb24uc2V0TG9jYWxEZXNjcmlwdGlvbihzZXNzaW9uRGVzY3JpcHRpb24pXG4gIH1cblxuICBzZXRSZW1vdGVEZXNjcmlwdGlvbiAoc2RwKSB7XG4gICAgZGVidWcoTkFNRSwgJ1tzZXRyZW1vdGVkZXNjcmlwdGlvbl0nKVxuICAgIHJldHVybiB0aGlzLl9wZWVyQ29ubmVjdGlvbi5zZXRSZW1vdGVEZXNjcmlwdGlvbihuZXcgd2VicnRjLlJUQ1Nlc3Npb25EZXNjcmlwdGlvbihzZHApKVxuICB9XG5cbiAgYWRkSWNlQ2FuZGlkYXRlIChjYW5kaWRhdGUpIHtcbiAgICBkZWJ1ZyhOQU1FLCAnW2FkZGNhbmRpZGF0ZV0nKVxuICAgIHJldHVybiB0aGlzLl9wZWVyQ29ubmVjdGlvbi5hZGRJY2VDYW5kaWRhdGUoY2FuZGlkYXRlKVxuICB9XG5cbiAgc2V0VXAgKGljZVNlcnZlcnMsIHNldFVwUHJvbWlzZSA9IG51bGwpIHtcbiAgICB0aGlzLnRlYXJEb3duKClcbiAgICBkZWJ1ZyhOQU1FLCAnW3NldHVwXScpXG4gICAgY29uc3QgcCA9IHNldFVwUHJvbWlzZSB8fCBuZXcgRGVmZXJyZWRQcm9taXNlKClcbiAgICB0cnkge1xuICAgICAgbGV0IHBlZXIgPSBuZXcgd2VicnRjLlJUQ1BlZXJDb25uZWN0aW9uKHtcbiAgICAgICAgaWNlU2VydmVyczogaWNlU2VydmVyc1xuICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG9wdGlvbmFsOiBbXG4gICAgICAgICAgICB7RHRsc1NydHBLZXlBZ3JlZW1lbnQ6IHRydWV9LFxuICAgICAgICAgICAge1J0cERhdGFDaGFubmVsczogZmFsc2V9LFxuICAgICAgICAgICAge2dvb2dDcHVPdmVydXNlRGV0ZWN0aW9uOiB0cnVlfVxuICAgICAgICAgIF1cbiAgICAgICAgfSlcbiAgICAgIHRoaXMuX2FkZENvbm5lY3Rpb25IYW5kbGVycyhwZWVyKVxuICAgICAgdGhpcy5fcGVlckNvbm5lY3Rpb24gPSBwZWVyXG4gICAgICBwLnJlc29sdmUocGVlcilcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB3YXJuKE5BTUUsIGBDb3VsZCBub3QgZXN0YWJsaXNoIGEgUGVlckNvbm5lY3Rpb24uICR7ZS5tZXNzYWdlfWApXG4gICAgICBwLnJlamVjdChlLm1lc3NhZ2UpXG4gICAgfVxuICAgIHJldHVybiBwLmhhc093blByb3BlcnR5KCdwcm9taXNlJykgPyBwLnByb21pc2UgOiBwXG4gIH1cblxuICB0ZWFyRG93biAoKSB7XG4gICAgZGVidWcoTkFNRSwgJ1t0ZWFyZG93bl0nKVxuICAgIGlmICh0aGlzLl9wZWVyQ29ubmVjdGlvbikge1xuICAgICAgdGhpcy5fcmVtb3ZlQ29ubmVjdGlvbkhhbmRsZXJzKHRoaXMuX3BlZXJDb25uZWN0aW9uKVxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5fcGVlckNvbm5lY3Rpb24uY2xvc2UoKVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB3YXJuKE5BTUUsIGBbcGVlcmNvbm5lY3Rpb24uY2xvc2VdIGVycm9yOiAke2UubWVzc2FnZX1gKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGdldCBjb25uZWN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGVlckNvbm5lY3Rpb25cbiAgfVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFB1Ymxpc2hlclBlZXJIZWxwZXJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL2pzL2hlbHBlci93ZWJydGMtaGVscGVyLXB1Yi5qc1xuICoqLyIsIid1c2Ugc2NyaXB0J1xuXG5pbXBvcnQgZW52aXJvbm1lbnQgZnJvbSAnLi4vZW52L2Jyb3dzZXInXG5pbXBvcnQgeyBkZWJ1Zywgd2FybiwgZXJyb3IgfSBmcm9tICcuLi9sb2cnXG5cbmNvbnN0IE5BTUUgPSAnUjVQcm9QbGF5YmFja1ZpZXcnXG5jb25zdCBwbGF5YmFja0lkID0gJ3JlZDVwcm8tc3Vic2NyaWJlcidcblxuZXhwb3J0IGNsYXNzIFBsYXliYWNrVmlldyB7XG5cbiAgY29uc3RydWN0b3IgKGVsZW1lbnRJZCA9IHBsYXliYWNrSWQpIHtcbiAgICB0cnkge1xuICAgICAgLy8gVGFyZ2V0IHZpZGVvIGVsZW1lbnQuXG4gICAgICB0aGlzLl90YXJnZXRFbGVtZW50ID0gZW52aXJvbm1lbnQucmVzb2x2ZUVsZW1lbnQoZWxlbWVudElkKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGVycm9yKE5BTUUsIGBDb3VsZCBub3QgaW5zdGFudGlhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgUmVkNVByb1N1YnNjcmliZXIuIFJlYXNvbjogJHtlLm1lc3NhZ2V9YClcbiAgICAgIHRocm93IGVcbiAgICB9XG4gIH1cblxuICBhdHRhY2hTdWJzY3JpYmVyIChzdWJzY3JpYmVyKSB7XG4gICAgZGVidWcoTkFNRSwgJ1thdHRhY2hzdWJzY3JpYmVyXScpXG4gICAgc3Vic2NyaWJlci5zZXRWaWV3KHRoaXMpXG4gIH1cblxuICBhdHRhY2hTdHJlYW0gKG1lZGlhU3RyZWFtLCBhdXRvcGxheSA9IGZhbHNlKSB7XG4gICAgZGVidWcoTkFNRSwgYFthdHRhY2hzdHJlYW1dOiBhdXRvcGxheSgke2F1dG9wbGF5fSlgKVxuICAgIGVudmlyb25tZW50LnNldFZpZGVvU291cmNlKHRoaXMuX3RhcmdldEVsZW1lbnQsIG1lZGlhU3RyZWFtLCBhdXRvcGxheSlcbiAgfVxuXG4gIHN0b3AgKCkge1xuICAgIGRlYnVnKE5BTUUsICdbc3RvcF0nKVxuICAgIHRyeSB7XG4gICAgICB0aGlzLl90YXJnZXRFbGVtZW50LnBhdXNlKClcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB3YXJuKE5BTUUsIGBDb3VsZCBub3Qgc3RvcCB2aWRlbyBlbGVtZW50OiAke2UubWVzc2FnZX1gKVxuICAgIH1cbiAgfVxuXG4gIGdldCB2aWV3ICgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGFyZ2V0RWxlbWVudFxuICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgUGxheWJhY2tWaWV3XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9qcy92aWV3L3BsYXliYWNrLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5cbmltcG9ydCBlbnZpcm9ubWVudCBmcm9tICcuLi9lbnYvYnJvd3NlcidcblxuaW1wb3J0IHsgZGVidWcsIGVycm9yIH0gZnJvbSAnLi4vbG9nJ1xuY29uc3QgTkFNRSA9ICdSNVByb1B1Ymxpc2hWaWV3J1xuXG5jb25zdCBwdWJsaXNoZXJJZCA9ICdyZWQ1cHJvLXB1Ymxpc2hlcidcblxuY2xhc3MgUHVibGlzaFZpZXcge1xuXG4gIGNvbnN0cnVjdG9yIChlbGVtZW50SWQgPSBwdWJsaXNoZXJJZCkge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLl90YXJnZXRFbGVtZW50ID0gZW52aXJvbm1lbnQucmVzb2x2ZUVsZW1lbnQoZWxlbWVudElkKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGVycm9yKE5BTUUsIGBDb3VsZCBub3QgaW5zdGFudGlhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgUmVkNVByb1B1Ymxpc2hlci4gUmVhc29uOiAke2UubWVzc2FnZX1gKVxuICAgICAgdGhyb3cgZVxuICAgIH1cbiAgfVxuXG4gIGF0dGFjaFB1Ymxpc2hlciAocHVibGlzaGVyKSB7XG4gICAgZGVidWcoTkFNRSwgJ1thdHRhY2hwdWJsaXNoZXJdJylcbiAgICBwdWJsaXNoZXIuc2V0Vmlldyh0aGlzKVxuICB9XG5cbiAgcHJldmlldyAobWVkaWFTdHJlYW0sIGF1dG9wbGF5ID0gZmFsc2UpIHtcbiAgICBkZWJ1ZyhOQU1FLCBgW3ByZXZpZXddOiBhdXRvcGxheSgke2F1dG9wbGF5fSlgKVxuICAgIGVudmlyb25tZW50LnNldFZpZGVvU291cmNlKHRoaXMuX3RhcmdldEVsZW1lbnQsIG1lZGlhU3RyZWFtLCBhdXRvcGxheSlcbiAgfVxuXG4gIGdldCB2aWV3ICgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGFyZ2V0RWxlbWVudFxuICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgUHVibGlzaFZpZXdcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL2pzL3ZpZXcvcHVibGlzaC5qc1xuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=